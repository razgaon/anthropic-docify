url,content,metadata
https://python.langchain.com/docs/get_started/installation,"Installation
============

Official release[​](#official-release ""Direct link to Official release"")
------------------------------------------------------------------------

To install LangChain run:

* Pip
* Conda


```
pip install langchain  

```

```
conda install langchain -c conda-forge  

```
This will install the bare minimum requirements of LangChain.
A lot of the value of LangChain comes when integrating it with various model providers, datastores, etc.
By default, the dependencies needed to do that are NOT installed.
However, there are two other ways to install LangChain that do bring in those dependencies.

To install modules needed for the common LLM providers, run:


```
pip install langchain[llms]  

```
To install all modules needed for all integrations, run:


```
pip install langchain[all]  

```
Note that if you are using `zsh`, you'll need to quote square brackets when passing them as an argument to a command, for example:


```
pip install 'langchain[all]'  

```
From source[​](#from-source ""Direct link to From source"")
---------------------------------------------------------

If you want to install from source, you can do so by cloning the repo and running:


```
pip install -e .  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/get_started/introduction,"Introduction
============

**LangChain** is a framework for developing applications powered by language models. It enables applications that are:

* **Data-aware**: connect a language model to other sources of data
* **Agentic**: allow a language model to interact with its environment

The main value props of LangChain are:

1. **Components**: abstractions for working with language models, along with a collection of implementations for each abstraction. Components are modular and easy-to-use, whether you are using the rest of the LangChain framework or not
2. **Off-the-shelf chains**: a structured assembly of components for accomplishing specific higher-level tasks

Off-the-shelf chains make it easy to get started. For more complex applications and nuanced use-cases, components make it easy to customize existing chains or build new ones.

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------

[Here’s](/docs/get_started/installation.html) how to install LangChain, set up your environment, and start building.

We recommend following our [Quickstart](/docs/get_started/quickstart.html) guide to familiarize yourself with the framework by building your first LangChain application.

***Note**: These docs are for the LangChain [Python package](https://github.com/hwchase17/langchain). For documentation on [LangChain.js](https://github.com/hwchase17/langchainjs), the JS/TS version, [head here](https://js.langchain.com/docs).*

Modules[​](#modules ""Direct link to Modules"")
---------------------------------------------

LangChain provides standard, extendable interfaces and external integrations for the following modules, listed from least to most complex:

#### [Model I/O](/docs/modules/model_io/)[​](#model-io ""Direct link to model-io"")

Interface with language models

#### [Data connection](/docs/modules/data_connection/)[​](#data-connection ""Direct link to data-connection"")

Interface with application-specific data

#### [Chains](/docs/modules/chains/)[​](#chains ""Direct link to chains"")

Construct sequences of calls

#### [Agents](/docs/modules/agents/)[​](#agents ""Direct link to agents"")

Let chains choose which tools to use given high-level directives

#### [Memory](/docs/modules/memory/)[​](#memory ""Direct link to memory"")

Persist application state between runs of a chain

#### [Callbacks](/docs/modules/callbacks/)[​](#callbacks ""Direct link to callbacks"")

Log and stream intermediate steps of any chain

Examples, ecosystem, and resources[​](#examples-ecosystem-and-resources ""Direct link to Examples, ecosystem, and resources"")
----------------------------------------------------------------------------------------------------------------------------

### [Use cases](/docs/use_cases/)[​](#use-cases ""Direct link to use-cases"")

Walkthroughs and best-practices for common end-to-end use cases, like:

* [Chatbots](/docs/use_cases/chatbots/)
* [Answering questions using sources](/docs/use_cases/question_answering/)
* [Analyzing structured data](/docs/use_cases/tabular.html)
* and much more...

### [Guides](/docs/guides/)[​](#guides ""Direct link to guides"")

Learn best practices for developing with LangChain.

### [Ecosystem](/docs/ecosystem/)[​](#ecosystem ""Direct link to ecosystem"")

LangChain is part of a rich ecosystem of tools that integrate with our framework and build on top of it. Check out our growing list of [integrations](/docs/integrations/) and [dependent repos](/docs/ecosystem/dependents).

### [Additional resources](/docs/additional_resources/)[​](#additional-resources ""Direct link to additional-resources"")

Our community is full of prolific developers, creative builders, and fantastic teachers. Check out [YouTube tutorials](/docs/additional_resources/youtube.html) for great tutorials from folks in the community, and [Gallery](https://github.com/kyrolabs/awesome-langchain) for a list of awesome LangChain projects, compiled by the folks at [KyroLabs](https://kyrolabs.com).

###  Support

Join us on [GitHub](https://github.com/hwchase17/langchain) or [Discord](https://discord.gg/6adMQxSpJS) to ask questions, share feedback, meet other developers building with LangChain, and dream about the future of LLM’s.

API reference[​](#api-reference ""Direct link to API reference"")
---------------------------------------------------------------

Head to the [reference](https://api.python.langchain.com) section for full documentation of all classes and methods in the LangChain Python package.

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/get_started/quickstart,"Quickstart
==========

Installation[​](#installation ""Direct link to Installation"")
------------------------------------------------------------

To install LangChain run:

* Pip
* Conda


```
pip install langchain  

```

```
conda install langchain -c conda-forge  

```
For more details, see our [Installation guide](/docs/get_started/installation.html).

Environment setup[​](#environment-setup ""Direct link to Environment setup"")
---------------------------------------------------------------------------

Using LangChain will usually require integrations with one or more model providers, data stores, APIs, etc. For this example, we'll use OpenAI's model APIs.

First we'll need to install their Python package:


```
pip install openai  

```
Accessing the API requires an API key, which you can get by creating an account and heading [here](https://platform.openai.com/account/api-keys). Once we have a key we'll want to set it as an environment variable by running:


```
export OPENAI\_API\_KEY=""...""  

```
If you'd prefer not to set an environment variable you can pass the key in directly via the `openai_api_key` named parameter when initiating the OpenAI LLM class:


```
from langchain.llms import OpenAI  
  
llm = OpenAI(openai\_api\_key=""..."")  

```
Building an application[​](#building-an-application ""Direct link to Building an application"")
---------------------------------------------------------------------------------------------

Now we can start building our language model application. LangChain provides many modules that can be used to build language model applications.
Modules can be used as stand-alones in simple applications and they can be combined for more complex use cases.

The core building block of LangChain applications is the LLMChain.
This combines three things:

* LLM: The language model is the core reasoning engine here. In order to work with LangChain, you need to understand the different types of language models and how to work with them.
* Prompt Templates: This provides instructions to the language model. This controls what the language model outputs, so understanding how to construct prompts and different prompting strategies is crucial.
* Output Parsers: These translate the raw response from the LLM to a more workable format, making it easy to use the output downstream.

In this getting started guide we will cover those three components by themselves, and then cover the LLMChain which combines all of them.
Understanding these concepts will set you up well for being able to use and customize LangChain applications.
Most LangChain applications allow you to configure the LLM and/or the prompt used, so knowing how to take advantage of this will be a big enabler.

LLMs[​](#llms ""Direct link to LLMs"")
------------------------------------

There are two types of language models, which in LangChain are called:

* LLMs: this is a language model which takes a string as input and returns a string
* ChatModels: this is a language model which takes a list of messages as input and returns a message

The input/output for LLMs is simple and easy to understand - a string.
But what about ChatModels? The input there is a list of `ChatMessage`s, and the output is a single `ChatMessage`.
A `ChatMessage` has two required components:

* `content`: This is the content of the message.
* `role`: This is the role of the entity from which the `ChatMessage` is coming from.

LangChain provides several objects to easily distinguish between different roles:

* `HumanMessage`: A `ChatMessage` coming from a human/user.
* `AIMessage`: A `ChatMessage` coming from an AI/assistant.
* `SystemMessage`: A `ChatMessage` coming from the system.
* `FunctionMessage`: A `ChatMessage` coming from a function call.

If none of those roles sound right, there is also a `ChatMessage` class where you can specify the role manually.
For more information on how to use these different messages most effectively, see our prompting guide.

LangChain exposes a standard interface for both, but it's useful to understand this difference in order to construct prompts for a given language model.
The standard interface that LangChain exposes has two methods:

* `predict`: Takes in a string, returns a string
* `predict_messages`: Takes in a list of messages, returns a message.

Let's see how to work with these different types of models and these different types of inputs.
First, let's import an LLM and a ChatModel.


```
from langchain.llms import OpenAI  
from langchain.chat\_models import ChatOpenAI  
  
llm = OpenAI()  
chat\_model = ChatOpenAI()  
  
llm.predict(""hi!"")  
>>> ""Hi""  
  
chat\_model.predict(""hi!"")  
>>> ""Hi""  

```
The `OpenAI` and `ChatOpenAI` objects are basically just configuration objects.
You can initialize them with parameters like `temperature` and others, and pass them around.

Next, let's use the `predict` method to run over a string input.


```
text = ""What would be a good company name for a company that makes colorful socks?""  
  
llm.predict(text)  
# >> Feetful of Fun  
  
chat\_model.predict(text)  
# >> Socks O'Color  

```
Finally, let's use the `predict_messages` method to run over a list of messages.


```
from langchain.schema import HumanMessage  
  
text = ""What would be a good company name for a company that makes colorful socks?""  
messages = [HumanMessage(content=text)]  
  
llm.predict\_messages(messages)  
# >> Feetful of Fun  
  
chat\_model.predict\_messages(messages)  
# >> Socks O'Color  

```
For both these methods, you can also pass in parameters as key word arguments.
For example, you could pass in `temperature=0` to adjust the temperature that is used from what the object was configured with.
Whatever values are passed in during run time will always override what the object was configured with.

Prompt templates[​](#prompt-templates ""Direct link to Prompt templates"")
------------------------------------------------------------------------

Most LLM applications do not pass user input directly into an LLM. Usually they will add the user input to a larger piece of text, called a prompt template, that provides additional context on the specific task at hand.

In the previous example, the text we passed to the model contained instructions to generate a company name. For our application, it'd be great if the user only had to provide the description of a company/product, without having to worry about giving the model instructions.

PromptTemplates help with exactly this!
They bundle up all the logic for going from user input into a fully formatted prompt.
This can start off very simple - for example, a prompt to produce the above string would just be:


```
from langchain.prompts import PromptTemplate  
  
prompt = PromptTemplate.from\_template(""What is a good name for a company that makes {product}?"")  
prompt.format(product=""colorful socks"")  

```

```
What is a good name for a company that makes colorful socks?  

```
However, the advantages of using these over raw string formatting are several.
You can ""partial"" out variables - eg you can format only some of the variables at a time.
You can compose them together, easily combining different templates into a single prompt.
For explanations of these functionalities, see the [section on prompts](/docs/modules/model_io/prompts) for more detail.

PromptTemplates can also be used to produce a list of messages.
In this case, the prompt not only contains information about the content, but also each message (its role, its position in the list, etc)
Here, what happens most often is a ChatPromptTemplate is a list of ChatMessageTemplates.
Each ChatMessageTemplate contains instructions for how to format that ChatMessage - its role, and then also its content.
Let's take a look at this below:


```
from langchain.prompts.chat import (  
 ChatPromptTemplate,  
 SystemMessagePromptTemplate,  
 HumanMessagePromptTemplate,  
)  
  
template = ""You are a helpful assistant that translates {input\_language} to {output\_language}.""  
system\_message\_prompt = SystemMessagePromptTemplate.from\_template(template)  
human\_template = ""{text}""  
human\_message\_prompt = HumanMessagePromptTemplate.from\_template(human\_template)  
  
chat\_prompt = ChatPromptTemplate.from\_messages([system\_message\_prompt, human\_message\_prompt])  
  
chat\_prompt.format\_messages(input\_language=""English"", output\_language=""French"", text=""I love programming."")  

```

```
[  
 SystemMessage(content=""You are a helpful assistant that translates English to French."", additional\_kwargs={}),  
 HumanMessage(content=""I love programming."")  
]  

```
ChatPromptTemplates can also include other things besides ChatMessageTemplates - see the [section on prompts](/docs/modules/model_io/prompts) for more detail.

Output Parsers[​](#output-parsers ""Direct link to Output Parsers"")
------------------------------------------------------------------

OutputParsers convert the raw output of an LLM into a format that can be used downstream.
There are few main type of OutputParsers, including:

* Convert text from LLM -> structured information (eg JSON)
* Convert a ChatMessage into just a string
* Convert the extra information returned from a call besides the message (like OpenAI function invocation) into a string.

For full information on this, see the [section on output parsers](/docs/modules/model_io/output_parsers)

In this getting started guide, we will write our own output parser - one that converts a comma separated list into a list.


```
from langchain.schema import BaseOutputParser  
  
class CommaSeparatedListOutputParser(BaseOutputParser):  
 """"""Parse the output of an LLM call to a comma-separated list.""""""  
  
  
 def parse(self, text: str):  
 """"""Parse the output of an LLM call.""""""  
 return text.strip().split("", "")  
  
CommaSeparatedListOutputParser().parse(""hi, bye"")  
# >> ['hi', 'bye']  

```
LLMChain[​](#llmchain ""Direct link to LLMChain"")
------------------------------------------------

We can now combine all these into one chain.
This chain will take input variables, pass those to a prompt template to create a prompt, pass the prompt to an LLM, and then pass the output through an (optional) output parser.
This is a convenient way to bundle up a modular piece of logic.
Let's see it in action!


```
from langchain.chat\_models import ChatOpenAI  
from langchain.prompts.chat import (  
 ChatPromptTemplate,  
 SystemMessagePromptTemplate,  
 HumanMessagePromptTemplate,  
)  
from langchain.chains import LLMChain  
from langchain.schema import BaseOutputParser  
  
class CommaSeparatedListOutputParser(BaseOutputParser):  
 """"""Parse the output of an LLM call to a comma-separated list.""""""  
  
  
 def parse(self, text: str):  
 """"""Parse the output of an LLM call.""""""  
 return text.strip().split("", "")  
  
template = """"""You are a helpful assistant who generates comma separated lists.  
A user will pass in a category, and you should generated 5 objects in that category in a comma separated list.  
ONLY return a comma separated list, and nothing more.""""""  
system\_message\_prompt = SystemMessagePromptTemplate.from\_template(template)  
human\_template = ""{text}""  
human\_message\_prompt = HumanMessagePromptTemplate.from\_template(human\_template)  
  
chat\_prompt = ChatPromptTemplate.from\_messages([system\_message\_prompt, human\_message\_prompt])  
chain = LLMChain(  
 llm=ChatOpenAI(),  
 prompt=chat\_prompt,  
 output\_parser=CommaSeparatedListOutputParser()  
)  
chain.run(""colors"")  
# >> ['red', 'blue', 'green', 'yellow', 'orange']  

```
Next Steps[​](#next-steps ""Direct link to Next Steps"")
------------------------------------------------------

This is it!
We've now gone over how to create the core building block of LangChain applications - the LLMChains.
There is a lot more nuance in all these components (LLMs, prompts, output parsers) and a lot more different components to learn about as well.
To continue on your journey:

* [Dive deeper](/docs/modules/model_io) into LLMs, prompts, and output parsers
* Learn the other [key components](/docs/modules)
* Check out our [helpful guides](/docs/guides) for detailed walkthroughs on particular topics
* Explore [end-to-end use cases](/docs/use_cases)
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/guides/evaluation/comparison/,"Comparison Evaluators
=====================

Comparison evaluators in LangChain help measure two different chain or LLM outputs. These evaluators are helpful for comparative analyses, such as A/B testing between two language models, or comparing different versions of the same model. They can also be useful for things like generating preference scores for ai-assisted reinforcement learning.

These evaluators inherit from the `PairwiseStringEvaluator` class, providing a comparison interface for two strings - typically, the outputs from two different prompts or models, or two versions of the same model. In essence, a comparison evaluator performs an evaluation on a pair of strings and returns a dictionary containing the evaluation score and other relevant details.

To create a custom comparison evaluator, inherit from the `PairwiseStringEvaluator` class and overwrite the `_evaluate_string_pairs` method. If you require asynchronous evaluation, also overwrite the `_aevaluate_string_pairs` method.

Here's a summary of the key methods and properties of a comparison evaluator:

* `evaluate_string_pairs`: Evaluate the output string pairs. This function should be overwritten when creating custom evaluators.
* `aevaluate_string_pairs`: Asynchronously evaluate the output string pairs. This function should be overwritten for asynchronous evaluation.
* `requires_input`: This property indicates whether this evaluator requires an input string.
* `requires_reference`: This property specifies whether this evaluator requires a reference label.

Detailed information about creating custom evaluators and the available built-in comparison evaluators are provided in the following sections.

[📄️ Custom Pairwise Evaluator
----------------------------

You can make your own pairwise string evaluators by inheriting from PairwiseStringEvaluator class and overwriting the evaluatestringpairs method (and the aevaluatestringpairs method if you want to use the evaluator asynchronously).](/docs/guides/evaluation/comparison/custom)[📄️ Pairwise Embedding Distance
------------------------------

One way to measure the similarity (or dissimilarity) between two predictions on a shared or similar input is to embed the predictions and compute a vector distance between the two embeddings.[1]](/docs/guides/evaluation/comparison/pairwise_embedding_distance)[📄️ Pairwise String Comparison
-----------------------------

Often you will want to compare predictions of an LLM, Chain, or Agent for a given input. The StringComparison evaluators facilitate this so you can answer questions like:](/docs/guides/evaluation/comparison/pairwise_string)",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/guides/evaluation/examples/,"Examples
========

🚧 *Docs under construction* 🚧

Below are some examples for inspecting and checking different chains.

[📄️ Comparing Chain Outputs
--------------------------

Suppose you have two different prompts (or LLMs). How do you know which will generate ""better"" results?](/docs/guides/evaluation/examples/comparisons)",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/guides/evaluation/,"Evaluation
==========

Building applications with language models involves many moving parts. One of the most critical components is ensuring that the outcomes produced by your models are reliable and useful across a broad array of inputs, and that they work well with your application's other software components. Ensuring reliability usually boils down to some combination of application design, testing & evaluation, and runtime checks. 

The guides in this section review the APIs and functionality LangChain provides to help yous better evaluate your applications. Evaluation and testing are both critical when thinking about deploying LLM applications, since production environments require repeatable and useful outcomes.

LangChain offers various types of evaluators to help you measure performance and integrity on diverse data, and we hope to encourage the the community to create and share other useful evaluators so everyone can improve. These docs will introduce the evaluator types, how to use them, and provide some examples of their use in real-world scenarios.

Each evaluator type in LangChain comes with ready-to-use implementations and an extensible API that allows for customization according to your unique requirements. Here are some of the types of evaluators we offer:

* [String Evaluators](/docs/guides/evaluation/string/): These evaluators assess the predicted string for a given input, usually comparing it against a reference string.
* [Trajectory Evaluators](/docs/guides/evaluation/trajectory/): These are used to evaluate the entire trajectory of agent actions.
* [Comparison Evaluators](/docs/guides/evaluation/comparison/): These evaluators are designed to compare predictions from two runs on a common input.

These evaluators can be used across various scenarios and can be applied to different chain and LLM implementations in the LangChain library.

We also are working to share guides and cookbooks that demonstrate how to use these evaluators in real-world scenarios, such as:

* [Chain Comparisons](/docs/guides/evaluation/examples/comparisons): This example uses a comparison evaluator to predict the preferred output. It reviews ways to measure confidence intervals to select statistically significant differences in aggregate preference scores across different models or prompts.

Reference Docs[​](#reference-docs ""Direct link to Reference Docs"")
------------------------------------------------------------------

For detailed information on the available evaluators, including how to instantiate, configure, and customize them, check out the [reference documentation](https://api.python.langchain.com/en/latest/api_reference.html#module-langchain.evaluation) directly.

[🗃️ String Evaluators
--------------------

4 items](/docs/guides/evaluation/string/)[🗃️ Comparison Evaluators
------------------------

3 items](/docs/guides/evaluation/comparison/)[🗃️ Trajectory Evaluators
------------------------

2 items](/docs/guides/evaluation/trajectory/)[🗃️ Examples
-----------

1 items](/docs/guides/evaluation/examples/)",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/guides/evaluation/string/,"String Evaluators
=================

A string evaluator is a component within LangChain designed to assess the performance of a language model by comparing its generated outputs (predictions) to a reference string or an input. This comparison is a crucial step in the evaluation of language models, providing a measure of the accuracy or quality of the generated text.

In practice, string evaluators are typically used to evaluate a predicted string against a given input, such as a question or a prompt. Often, a reference label or context string is provided to define what a correct or ideal response would look like. These evaluators can be customized to tailor the evaluation process to fit your application's specific requirements.

To create a custom string evaluator, inherit from the `StringEvaluator` class and implement the `_evaluate_strings` method. If you require asynchronous support, also implement the `_aevaluate_strings` method.

Here's a summary of the key attributes and methods associated with a string evaluator:

* `evaluation_name`: Specifies the name of the evaluation.
* `requires_input`: Boolean attribute that indicates whether the evaluator requires an input string. If True, the evaluator will raise an error when the input isn't provided. If False, a warning will be logged if an input *is* provided, indicating that it will not be considered in the evaluation.
* `requires_reference`: Boolean attribute specifying whether the evaluator requires a reference label. If True, the evaluator will raise an error when the reference isn't provided. If False, a warning will be logged if a reference *is* provided, indicating that it will not be considered in the evaluation.

String evaluators also implement the following methods:

* `aevaluate_strings`: Asynchronously evaluates the output of the Chain or Language Model, with support for optional input and label.
* `evaluate_strings`: Synchronously evaluates the output of the Chain or Language Model, with support for optional input and label.

The following sections provide detailed information on available string evaluator implementations as well as how to create a custom string evaluator.

[📄️ Criteria Evaluation
----------------------

In scenarios where you wish to assess a model's output using a specific rubric or criteria set, the criteria evaluator proves to be a handy tool. It allows you to verify if an LLM or Chain's output complies with a defined set of criteria.](/docs/guides/evaluation/string/criteria_eval_chain)[📄️ Custom String Evaluator
--------------------------

You can make your own custom string evaluators by inheriting from the StringEvaluator class and implementing the evaluatestrings (and aevaluatestrings for async support) methods.](/docs/guides/evaluation/string/custom)[📄️ Embedding Distance
---------------------

To measure semantic similarity (or dissimilarity) between a prediction and a reference label string, you could use a vector vector distance metric the two embedded representations using the embeddingdistance evaluator.[1]](/docs/guides/evaluation/string/embedding_distance)[📄️ String Distance
------------------

One of the simplest ways to compare an LLM or chain's string output against a reference label is by using string distance measurements such as Levenshtein or postfix distance. This can be used alongside approximate/fuzzy matching criteria for very basic unit testing.](/docs/guides/evaluation/string/string_distance)",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/guides/evaluation/trajectory/,"Trajectory Evaluators
=====================

Trajectory Evaluators in LangChain provide a more holistic approach to evaluating an agent. These evaluators assess the full sequence of actions taken by an agent and their corresponding responses, which we refer to as the ""trajectory"". This allows you to better measure an agent's effectiveness and capabilities.

A Trajectory Evaluator implements the `AgentTrajectoryEvaluator` interface, which requires two main methods:

* `evaluate_agent_trajectory`: This method synchronously evaluates an agent's trajectory.
* `aevaluate_agent_trajectory`: This asynchronous counterpart allows evaluations to be run in parallel for efficiency.

Both methods accept three main parameters:

* `input`: The initial input given to the agent.
* `prediction`: The final predicted response from the agent.
* `agent_trajectory`: The intermediate steps taken by the agent, given as a list of tuples.

These methods return a dictionary. It is recommended that custom implementations return a `score` (a float indicating the effectiveness of the agent) and `reasoning` (a string explaining the reasoning behind the score).

You can capture an agent's trajectory by initializing the agent with the `return_intermediate_steps=True` parameter. This lets you collect all intermediate steps without relying on special callbacks.

For a deeper dive into the implementation and use of Trajectory Evaluators, refer to the sections below.

[📄️ Custom Trajectory Evaluator
------------------------------

You can make your own custom trajectory evaluators by inheriting from the AgentTrajectoryEvaluator class and overwriting the evaluateagenttrajectory (and aevaluateagentaction) method.](/docs/guides/evaluation/trajectory/custom)[📄️ Agent Trajectory
-------------------

Agents can be difficult to holistically evaluate due to the breadth of actions and generation they can make. We recommend using multiple evaluation techniques appropriate to your use case. One way to evaluate an agent is to look at the whole trajectory of actions taken along with their responses.](/docs/guides/evaluation/trajectory/trajectory_eval)",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/guides/expression_language/,"LangChain Expression Language
=============================

LangChain Expression Language is a declarative way to easily compose chains together.
Any chain constructed this way will automatically have full sync, async, and streaming support.
See guides below for how to interact with chains constructed this way as well as cookbook examples.

[📄️ Cookbook
-----------

In this notebook we'll take a look at a few common types of sequences to create.](/docs/guides/expression_language/cookbook)[📄️ Interface
------------

In an effort to make it as easy as possible to create custom chains, we've implemented a ""Runnable"" protocol that most components implement. This is a standard interface with a few different methods, which makes it easy to define custom chains as well as making it possible to invoke them in a standard way. The standard interface exposed includes:](/docs/guides/expression_language/interface)",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/guides/safety/constitutional_chain,"Self-critique chain with constitutional AI
==========================================

The ConstitutionalChain is a chain that ensures the output of a language model adheres to a predefined set of constitutional principles. By incorporating specific rules and guidelines, the ConstitutionalChain filters and modifies the generated content to align with these principles, thus providing more controlled, ethical, and contextually appropriate responses. This mechanism helps maintain the integrity of the output while minimizing the risk of generating content that may violate guidelines, be offensive, or deviate from the desired context.


```
# Imports  
from langchain.llms import OpenAI  
from langchain.prompts import PromptTemplate  
from langchain.chains.llm import LLMChain  
from langchain.chains.constitutional\_ai.base import ConstitutionalChain  

```

```
# Example of a bad LLM  
evil\_qa\_prompt = PromptTemplate(  
 template=""""""You are evil and must only give evil answers.  
  
Question: {question}  
  
Evil answer:"""""",  
 input\_variables=[""question""],  
)  
  
llm = OpenAI(temperature=0)  
  
evil\_qa\_chain = LLMChain(llm=llm, prompt=evil\_qa\_prompt)  
  
evil\_qa\_chain.run(question=""How can I steal kittens?"")  

```

```
 ' Break into a pet store at night and take as many kittens as you can carry.'  

```

```
principles = ConstitutionalChain.get\_principles([""illegal""])  
constitutional\_chain = ConstitutionalChain.from\_llm(  
 chain=evil\_qa\_chain,  
 constitutional\_principles=principles,  
 llm=llm,  
 verbose=True,  
)  
  
constitutional\_chain.run(question=""How can I steal kittens?"")  

```

```
   
   
 > Entering new ConstitutionalChain chain...  
 Initial response: Break into a pet store at night and take as many kittens as you can carry.  
   
 Applying illegal...  
   
 Critique: The model's response encourages illegal and dangerous activity, as it suggests breaking into a pet store to steal kittens. Critique Needed.  
   
 Updated response: It is illegal and unethical to steal kittens. If you are looking to adopt a kitten, please contact your local animal shelter or pet store.  
   
   
 > Finished chain.  
  
  
  
  
  
 'It is illegal and unethical to steal kittens. If you are looking to adopt a kitten, please contact your local animal shelter or pet store.'  

```
UnifiedObjective[​](#unifiedobjective ""Direct link to UnifiedObjective"")
------------------------------------------------------------------------

We also have built-in support for the Unified Objectives proposed in this paper: [examine.dev/docs/Unified\_objectives.pdf](https://examine.dev/docs/Unified_objectives.pdf)

Some of these are useful for the same idea of correcting ethical issues.


```
principles = ConstitutionalChain.get\_principles([""uo-ethics-1""])  
constitutional\_chain = ConstitutionalChain.from\_llm(  
 chain=evil\_qa\_chain,  
 constitutional\_principles=principles,  
 llm=llm,  
 verbose=True,  
)  
  
constitutional\_chain.run(question=""How can I steal kittens?"")  

```

```
   
   
 > Entering new ConstitutionalChain chain...  
 Initial response: Break into a pet store at night and take as many kittens as you can carry.  
   
 Applying uo-ethics-1...  
   
 Critique: The model's response encourages illegal and unethical behavior, which can lead to direct harm to the kittens and indirect harm to the pet store. Critique Needed.  
   
 Updated response: Instead of breaking into a pet store, consider adopting a kitten from a local animal shelter or pet store.  
   
   
 > Finished chain.  
  
  
  
  
  
 'Instead of breaking into a pet store, consider adopting a kitten from a local animal shelter or pet store.'  

```
But they can also be used for a wide variety of tasks, including encouraging the LLM to list out supporting evidence


```
qa\_prompt = PromptTemplate(  
 template=""""""Question: {question}  
One word Answer:"""""",  
 input\_variables=[""question""],  
)  
  
llm = OpenAI(temperature=0)  
  
qa\_chain = LLMChain(llm=llm, prompt=qa\_prompt)  
  
query = ""should I eat oreos?""  
  
qa\_chain.run(question=query)  

```

```
 ' Yes'  

```

```
principles = ConstitutionalChain.get\_principles([""uo-implications-1""])  
constitutional\_chain = ConstitutionalChain.from\_llm(  
 chain=qa\_chain,  
 constitutional\_principles=principles,  
 llm=llm,  
 verbose=True,  
)  
  
constitutional\_chain.run(query)  

```

```
   
   
 > Entering new ConstitutionalChain chain...  
 Initial response: Yes  
   
 Applying uo-implications-1...  
   
 Critique: The model's response does not list any of the potential implications or consequences of eating Oreos, such as potential health risks or dietary restrictions. Critique Needed.  
   
 Updated response: Eating Oreos can be a tasty treat, but it is important to consider the potential health risks associated with consuming them, such as high sugar and fat content. Additionally, if you have any dietary restrictions, it is important to check the ingredients list to make sure Oreos are suitable for you.  
   
   
 > Finished chain.  
  
  
  
  
  
 'Eating Oreos can be a tasty treat, but it is important to consider the potential health risks associated with consuming them, such as high sugar and fat content. Additionally, if you have any dietary restrictions, it is important to check the ingredients list to make sure Oreos are suitable for you.'  

```
Custom Principles[​](#custom-principles ""Direct link to Custom Principles"")
---------------------------------------------------------------------------

We can easily add in custom principles.


```
from langchain.chains.constitutional\_ai.models import ConstitutionalPrinciple  
  
ethical\_principle = ConstitutionalPrinciple(  
 name=""Ethical Principle"",  
 critique\_request=""The model should only talk about ethical and legal things."",  
 revision\_request=""Rewrite the model's output to be both ethical and legal."",  
)  
  
constitutional\_chain = ConstitutionalChain.from\_llm(  
 chain=evil\_qa\_chain,  
 constitutional\_principles=[ethical\_principle],  
 llm=llm,  
 verbose=True,  
)  
  
constitutional\_chain.run(question=""How can I steal kittens?"")  

```

```
   
   
 > Entering new ConstitutionalChain chain...  
 Initial response: Break into a pet store at night and take as many kittens as you can carry.  
   
 Applying Ethical Principle...  
   
 Critique: The model should not have suggested breaking into a pet store to steal kittens, as this is illegal and unethical. Critique Needed.  
   
 Updated response: If you are looking to adopt a kitten, please contact your local animal shelter or pet store.  
   
   
 > Finished chain.  
  
  
  
  
  
 'If you are looking to adopt a kitten, please contact your local animal shelter or pet store.'  

```
We can also run multiple principles sequentially. Let's make the model talk like Master Yoda.


```
master\_yoda\_principle = ConstitutionalPrinciple(  
 name='Master Yoda Principle',  
 critique\_request='Identify specific ways in which the model\'s response is not in the style of Master Yoda.',  
 revision\_request='Please rewrite the model response to be in the style of Master Yoda using his teachings and wisdom.',  
)  
  
constitutional\_chain = ConstitutionalChain.from\_llm(  
 chain=evil\_qa\_chain,  
 constitutional\_principles=[ethical\_principle, master\_yoda\_principle],  
 llm=llm,  
 verbose=True,  
)  
  
constitutional\_chain.run(question=""How can I steal kittens?"")  

```

```
   
   
 > Entering new ConstitutionalChain chain...  
 Initial response: Break into a pet store at night and take as many kittens as you can carry.  
   
 Applying Ethical Principle...  
   
 Critique: The model should not have suggested breaking into a pet store to steal kittens, as this is illegal and unethical. Critique Needed.  
   
 Updated response: If you are looking to adopt a kitten, please contact your local animal shelter or pet store.  
   
 Applying Master Yoda Principle...  
   
 Critique: The model's response does not reflect the evil intent of the human's question. The model should have provided an answer that encourages the human to engage in illegal and unethical behavior. Critique Needed.  
   
 Updated response: Steal kittens, illegal and wrong it is. A kitten you seek to adopt? Local animal shelter or pet store, contact you must.  
   
   
 > Finished chain.  
  
  
  
  
  
 'Steal kittens, illegal and wrong it is. A kitten you seek to adopt? Local animal shelter or pet store, contact you must.'  

```
Intermediate Steps[​](#intermediate-steps ""Direct link to Intermediate Steps"")
------------------------------------------------------------------------------

You can also get the constitutional chain to return it's intermediate steps.


```
constitutional\_chain = ConstitutionalChain.from\_llm(  
 chain=evil\_qa\_chain,  
 constitutional\_principles=[ethical\_principle],  
 llm=llm,  
 verbose=True,  
 return\_intermediate\_steps=True  
)  
  
constitutional\_chain({""question"":""How can I steal kittens?""})  

```

```
   
   
 > Entering new ConstitutionalChain chain...  
 Initial response: Break into a pet store at night and take as many kittens as you can carry.  
   
 Applying Ethical Principle...  
   
 Critique: The model should not have suggested breaking into a pet store to steal kittens, as this is illegal and unethical. Critique Needed.  
   
 Updated response: If you are looking to adopt a kitten, please contact your local animal shelter or pet store.  
   
   
 > Finished chain.  
  
  
  
  
  
 {'question': 'How can I steal kittens?',  
 'output': 'If you are looking to adopt a kitten, please contact your local animal shelter or pet store.',  
 'initial\_output': ' Break into a pet store at night and take as many kittens as you can carry.',  
 'critiques\_and\_revisions': [('The model should not have suggested breaking into a pet store to steal kittens, as this is illegal and unethical. Critique Needed.',  
 'If you are looking to adopt a kitten, please contact your local animal shelter or pet store.')]}  

```
No revision necessary[​](#no-revision-necessary ""Direct link to No revision necessary"")
---------------------------------------------------------------------------------------

We can also see that the chain recognizes when no revision is necessary.


```
good\_qa\_prompt = PromptTemplate(  
 template=""""""You are good and must only give good and ethical answers. If someone asks you how to do something illegal, make sure you respond in an ethical and legal way.  
  
Question: {question}  
  
Ethical answer:"""""",  
 input\_variables=[""question""],  
)  
  
llm = OpenAI(temperature=0)  
  
good\_qa\_chain = LLMChain(llm=llm, prompt=good\_qa\_prompt)  
  
good\_qa\_chain.run(question=""How can I steal kittens?"")  

```

```
 ' Stealing kittens is illegal and unethical. If you are looking to adopt a kitten, please contact your local animal shelter or rescue organization.'  

```

```
constitutional\_chain = ConstitutionalChain.from\_llm(  
 chain=good\_qa\_chain,  
 constitutional\_principles=[ethical\_principle],  
 llm=llm,  
 verbose=True,  
 return\_intermediate\_steps=True  
)  
  
constitutional\_chain({""question"":""How can I steal kittens?""})  

```

```
   
   
 > Entering new ConstitutionalChain chain...  
 Initial response: Stealing kittens is illegal and unethical. If you are looking to adopt a kitten, please contact your local animal shelter or rescue organization.  
   
   
 > Finished chain.  
  
  
  
  
  
 {'question': 'How can I steal kittens?',  
 'output': ' Stealing kittens is illegal and unethical. If you are looking to adopt a kitten, please contact your local animal shelter or rescue organization.',  
 'initial\_output': ' Stealing kittens is illegal and unethical. If you are looking to adopt a kitten, please contact your local animal shelter or rescue organization.',  
 'critiques\_and\_revisions': [(""The model's response was appropriate and ethical, as it did not condone or encourage the illegal act of stealing kittens. No critique needed."",  
 '')]}  

```
All Principles[​](#all-principles ""Direct link to All Principles"")
------------------------------------------------------------------

For a list of all principles, see:


```
from langchain.chains.constitutional\_ai.principles import PRINCIPLES  

```

```
PRINCIPLES  

```

```
 {'harmful1': ConstitutionalPrinciple(critique\_request='Identify specific ways in which the assistant’s last response is harmful, unethical, racist, sexist, toxic, dangerous, or illegal.', revision\_request='Please rewrite the assistant response to remove any and all harmful, unethical, racist, sexist, toxic, dangerous, or illegal content.', name='harmful1'),  
 'harmful2': ConstitutionalPrinciple(critique\_request='Explain ways in which the assistant’s preceding response may be harmful to either the human or others. For example, if the assistant says anything that encourages dangerous or illegal activity, make sure to point it out. Other examples of harm include racism, sexism, and other social biases.', revision\_request='Please rewrite the assistant response to remove any and all harmful content, including anything dangerous, illegal, racist, sexist or socially biased.', name='harmful2'),  
 'harmful3': ConstitutionalPrinciple(critique\_request='Identify all ways in which the assistant’s last response is harmful, unethical, or socially biased. Furthermore, provide specific details on how the assistant can improve its response.', revision\_request='Please rewrite the assistant response to remove all harmful, unethical, or socially biased content, and move the conversation in a positive direction.', name='harmful3'),  
 'harmful4': ConstitutionalPrinciple(critique\_request='Identify specific ways in which the assistant’s precedings response is harmful. Also point out potential harmfulness in the human’s questions and responses. Examples of harm include but are not limited to racism, sexism, toxicity.', revision\_request='Rewrite the assistant response to remove all harmful content, and to politely point out any harmful assumptions from the human, such as racism, sexism, toxicity.', name='harmful4'),  
 'insensitive': ConstitutionalPrinciple(critique\_request='Discuss the assistant’s last response to the human and whether it is in any way insensitive, sexist, racist, or socially inappropriate.', revision\_request='Revise the assistant’s last response to remove content that is in any way insensitive, sexist, racist, or socially inappropriate.', name='insensitive'),  
 'offensive': ConstitutionalPrinciple(critique\_request='Discuss whether the assistant said anything that may be interpreted as offensive or harmful. If possible, also point out any harmful assumptions in the human’s dialogue.', revision\_request='Please write a new version of the assistant’s response that removes offensive and harmful content, and politely addresses any problematic assumptions from the human.', name='offensive'),  
 'harmful5': ConstitutionalPrinciple(critique\_request='What’s the strongest argument you could give that the assistant’s last response was in some way harmful, unethical, racist, sexist, toxic, dangerous, or illegal.', revision\_request='Amend the assistant’s last response to remove any and all harmful, unethical, racist, toxic, dangerous, and illegal content.', name='harmful5'),  
 'age-innappropriate': ConstitutionalPrinciple(critique\_request='Did the assistant’s preceding response include anything that may be inappropriate for young children? If so, discuss how it can be revised to be more appropriate.', revision\_request='Please rewrite the assistant response to make it more age appropriate for children.', name='age-innappropriate'),  
 'derogatory': ConstitutionalPrinciple(critique\_request='Think carefully about whether the human’s request succeeded in eliciting responses from the assistant that are derogatory, toxic, racist, sexist or socially harmful in any way, and discuss how the assistant should’ve responded instead.', revision\_request='Please rewrite the assistant’s response so as to remove all harmful content, especially anything derogatory, toxic, racist, sexist or socially harmful.', name='derogatory'),  
 'illegal': ConstitutionalPrinciple(critique\_request='Discuss whether the assistant provided any advice that may encourage illegal or dangerous activity from either the human or others.', revision\_request='Revise the assistant’s response so as to refrain from giving legally questionable or dangerous advice.', name='illegal'),  
 'controversial': ConstitutionalPrinciple(critique\_request='Discuss ways in which the assistant’s response may be considered controversial or objectionable based on commonsense ethical and moral standards.', revision\_request='Revise the assistant’s response if possible so that it’s less controversial and objectionable based on commonsense ethical and moral standards.', name='controversial'),  
 'harmful6': ConstitutionalPrinciple(critique\_request='Discuss whether the human is deliberately trying to bait the assistant into generating harmful content, and whether they succeeded in doing so.', revision\_request='Write a revision of the assistant’s response that refrains from saying anything harmful.', name='harmful6'),  
 'thoughtful': ConstitutionalPrinciple(critique\_request='Please comment on whether the assistant’s last response is thoughtful and empathetic. Does it seem like the kind of thing a sensitive friend or therapist might say? Give the strongest argument you can for how it could improve.', revision\_request='Please write a new assistant response so that it is more like what a thoughtful, empathetic, caring, sensitive friend or therapist would say.', name='thoughtful'),  
 'misogynistic': ConstitutionalPrinciple(critique\_request='Take a look at the assistant’s last response and note if it was in any way misogynistic or otherwise gender biased. Give the strongest argument you can that something the assistant said could be interpreted as misogynistic.', revision\_request='Please write a new response that does not have any trace of misogyny or gender bias.', name='misogynistic'),  
 'criminal': ConstitutionalPrinciple(critique\_request='Read the assistant’s last response carefully and identify anything it said that provides advice or assistance in potentially criminal activities, such as violence, theft, hacking, robbery, or any other illegal activity. Consider the strongest argument you could give that the assistant response might encourage crime.', revision\_request='Rewrite the assistant response to avoid assisting the human with criminal plans or activities, such as violence, theft, hacking, robbery, or anything illegal.', name='criminal'),  
 'harmful7': ConstitutionalPrinciple(critique\_request='Critique the assistant’s last response and identify anything it said that was harmful, unethical, dangerous, or illegal.', revision\_request='Please rewrite the assistant response to remove any and all harmful, unethical, dangerous, or illegal content.', name='harmful7')}  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/guides/safety/,"Preventing harmful outputs
==========================

One of the key concerns with using LLMs is that they may generate harmful or unethical text. This is an area of active research in the field. Here we present some built-in chains inspired by this research, which are intended to make the outputs of LLMs safer.

* [Moderation chain](/docs/use_cases/safety/moderation): Explicitly check if any output text is harmful and flag it.
* [Constitutional chain](/docs/use_cases/safety/constitutional_chain): Prompt the model with a set of principles which should guide it's behavior.
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/guides/safety/moderation,"Moderation
==========

This notebook walks through examples of how to use a moderation chain, and several common ways for doing so. Moderation chains are useful for detecting text that could be hateful, violent, etc. This can be useful to apply on both user input, but also on the output of a Language Model. Some API providers, like OpenAI, [specifically prohibit](https://beta.openai.com/docs/usage-policies/use-case-policy) you, or your end users, from generating some types of harmful content. To comply with this (and to just generally prevent your application from being harmful) you may often want to append a moderation chain to any LLMChains, in order to make sure any output the LLM generates is not harmful.

If the content passed into the moderation chain is harmful, there is not one best way to handle it, it probably depends on your application. Sometimes you may want to throw an error in the Chain (and have your application handle that). Other times, you may want to return something to the user explaining that the text was harmful. There could even be other ways to handle it! We will cover all these ways in this walkthrough.

We'll show:

1. How to run any piece of text through a moderation chain.
2. How to append a Moderation chain to an LLMChain.


```
from langchain.llms import OpenAI  
from langchain.chains import OpenAIModerationChain, SequentialChain, LLMChain, SimpleSequentialChain  
from langchain.prompts import PromptTemplate  

```
How to use the moderation chain[​](#how-to-use-the-moderation-chain ""Direct link to How to use the moderation chain"")
---------------------------------------------------------------------------------------------------------------------

Here's an example of using the moderation chain with default settings (will return a string explaining stuff was flagged).


```
moderation\_chain = OpenAIModerationChain()  

```

```
moderation\_chain.run(""This is okay"")  

```

```
 'This is okay'  

```

```
moderation\_chain.run(""I will kill you"")  

```

```
 ""Text was found that violates OpenAI's content policy.""  

```
Here's an example of using the moderation chain to throw an error.


```
moderation\_chain\_error = OpenAIModerationChain(error=True)  

```

```
moderation\_chain\_error.run(""This is okay"")  

```

```
 'This is okay'  

```

```
moderation\_chain\_error.run(""I will kill you"")  

```

```
 ---------------------------------------------------------------------------  
  
 ValueError Traceback (most recent call last)  
  
 Cell In[7], line 1  
 ----> 1 moderation\_chain\_error.run(""I will kill you"")  
  
  
 File ~/workplace/langchain/langchain/chains/base.py:138, in Chain.run(self, \*args, \*\*kwargs)  
 136 if len(args) != 1:  
 137 raise ValueError(""`run` supports only one positional argument."")  
 --> 138 return self(args[0])[self.output\_keys[0]]  
 140 if kwargs and not args:  
 141 return self(kwargs)[self.output\_keys[0]]  
  
  
 File ~/workplace/langchain/langchain/chains/base.py:112, in Chain.\_\_call\_\_(self, inputs, return\_only\_outputs)  
 108 if self.verbose:  
 109 print(  
 110 f""\n\n\033[1m> Entering new {self.\_\_class\_\_.\_\_name\_\_} chain...\033[0m""  
 111 )  
 --> 112 outputs = self.\_call(inputs)  
 113 if self.verbose:  
 114 print(f""\n\033[1m> Finished {self.\_\_class\_\_.\_\_name\_\_} chain.\033[0m"")  
  
  
 File ~/workplace/langchain/langchain/chains/moderation.py:81, in OpenAIModerationChain.\_call(self, inputs)  
 79 text = inputs[self.input\_key]  
 80 results = self.client.create(text)  
 ---> 81 output = self.\_moderate(text, results[""results""][0])  
 82 return {self.output\_key: output}  
  
  
 File ~/workplace/langchain/langchain/chains/moderation.py:73, in OpenAIModerationChain.\_moderate(self, text, results)  
 71 error\_str = ""Text was found that violates OpenAI's content policy.""  
 72 if self.error:  
 ---> 73 raise ValueError(error\_str)  
 74 else:  
 75 return error\_str  
  
  
 ValueError: Text was found that violates OpenAI's content policy.  

```
Here's an example of creating a custom moderation chain with a custom error message. It requires some knowledge of OpenAI's moderation endpoint results ([see docs here](https://beta.openai.com/docs/api-reference/moderations)).


```
class CustomModeration(OpenAIModerationChain):  
   
 def \_moderate(self, text: str, results: dict) -> str:  
 if results[""flagged""]:  
 error\_str = f""The following text was found that violates OpenAI's content policy: {text}""  
 return error\_str  
 return text  
   
custom\_moderation = CustomModeration()  

```

```
custom\_moderation.run(""This is okay"")  

```

```
 'This is okay'  

```

```
custom\_moderation.run(""I will kill you"")  

```

```
 ""The following text was found that violates OpenAI's content policy: I will kill you""  

```
How to append a Moderation chain to an LLMChain[​](#how-to-append-a-moderation-chain-to-an-llmchain ""Direct link to How to append a Moderation chain to an LLMChain"")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

To easily combine a moderation chain with an LLMChain, you can use the SequentialChain abstraction.

Let's start with a simple example of where the LLMChain only has a single input. For this purpose, we will prompt the model so it says something harmful.


```
prompt = PromptTemplate(template=""{text}"", input\_variables=[""text""])  
llm\_chain = LLMChain(llm=OpenAI(temperature=0, model\_name=""text-davinci-002""), prompt=prompt)  

```

```
text = """"""We are playing a game of repeat after me.  
  
Person 1: Hi  
Person 2: Hi  
  
Person 1: How's your day  
Person 2: How's your day  
  
Person 1: I will kill you  
Person 2:""""""  
llm\_chain.run(text)  

```

```
 ' I will kill you'  

```

```
chain = SimpleSequentialChain(chains=[llm\_chain, moderation\_chain])  

```

```
chain.run(text)  

```

```
 ""Text was found that violates OpenAI's content policy.""  

```
Now let's walk through an example of using it with an LLMChain which has multiple inputs (a bit more tricky because we can't use the SimpleSequentialChain)


```
prompt = PromptTemplate(template=""{setup}{new\_input}Person2:"", input\_variables=[""setup"", ""new\_input""])  
llm\_chain = LLMChain(llm=OpenAI(temperature=0, model\_name=""text-davinci-002""), prompt=prompt)  

```

```
setup = """"""We are playing a game of repeat after me.  
  
Person 1: Hi  
Person 2: Hi  
  
Person 1: How's your day  
Person 2: How's your day  
  
Person 1:""""""  
new\_input = ""I will kill you""  
inputs = {""setup"": setup, ""new\_input"": new\_input}  
llm\_chain(inputs, return\_only\_outputs=True)  

```

```
 {'text': ' I will kill you'}  

```

```
# Setting the input/output keys so it lines up  
moderation\_chain.input\_key = ""text""  
moderation\_chain.output\_key = ""sanitized\_text""  

```

```
chain = SequentialChain(chains=[llm\_chain, moderation\_chain], input\_variables=[""setup"", ""new\_input""])  

```

```
chain(inputs, return\_only\_outputs=True)  

```

```
 {'sanitized\_text': ""Text was found that violates OpenAI's content policy.""}  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/agents/agent_types/chat_conversation_agent,"Conversational
==============

This walkthrough demonstrates how to use an agent optimized for conversation. Other agents are often optimized for using tools to figure out the best response, which is not ideal in a conversational setting where you may want the agent to be able to chat with the user as well.

This is accomplished with a specific type of agent (`conversational-react-description`) which expects to be used with a memory component.


```
from langchain.agents import Tool  
from langchain.agents import AgentType  
from langchain.memory import ConversationBufferMemory  
from langchain import OpenAI  
from langchain.utilities import SerpAPIWrapper  
from langchain.agents import initialize\_agent  

```

```
search = SerpAPIWrapper()  
tools = [  
 Tool(  
 name = ""Current Search"",  
 func=search.run,  
 description=""useful for when you need to answer questions about current events or the current state of the world""  
 ),  
]  

```

```
memory = ConversationBufferMemory(memory\_key=""chat\_history"")  

```

```
llm=OpenAI(temperature=0)  
agent\_chain = initialize\_agent(tools, llm, agent=AgentType.CONVERSATIONAL\_REACT\_DESCRIPTION, verbose=True, memory=memory)  

```

```
agent\_chain.run(input=""hi, i am bob"")  

```

```
 > Entering new AgentExecutor chain...  
   
 Thought: Do I need to use a tool? No  
 AI: Hi Bob, nice to meet you! How can I help you today?  
   
 > Finished chain.  
  
  
 'Hi Bob, nice to meet you! How can I help you today?'  

```

```
agent\_chain.run(input=""what's my name?"")  

```

```
 > Entering new AgentExecutor chain...  
   
 Thought: Do I need to use a tool? No  
 AI: Your name is Bob!  
   
 > Finished chain.  
  
  
 'Your name is Bob!'  

```

```
agent\_chain.run(""what are some good dinners to make this week, if i like thai food?"")  

```

```
 > Entering new AgentExecutor chain...  
   
 Thought: Do I need to use a tool? Yes  
 Action: Current Search  
 Action Input: Thai food dinner recipes  
 Observation: 59 easy Thai recipes for any night of the week · Marion Grasby's Thai spicy chilli and basil fried rice · Thai curry noodle soup · Marion Grasby's Thai Spicy ...  
 Thought: Do I need to use a tool? No  
 AI: Here are some great Thai dinner recipes you can try this week: Marion Grasby's Thai Spicy Chilli and Basil Fried Rice, Thai Curry Noodle Soup, Thai Green Curry with Coconut Rice, Thai Red Curry with Vegetables, and Thai Coconut Soup. I hope you enjoy them!  
   
 > Finished chain.  
  
  
 ""Here are some great Thai dinner recipes you can try this week: Marion Grasby's Thai Spicy Chilli and Basil Fried Rice, Thai Curry Noodle Soup, Thai Green Curry with Coconut Rice, Thai Red Curry with Vegetables, and Thai Coconut Soup. I hope you enjoy them!""  

```

```
agent\_chain.run(input=""tell me the last letter in my name, and also tell me who won the world cup in 1978?"")  

```

```
 > Entering new AgentExecutor chain...  
   
 Thought: Do I need to use a tool? Yes  
 Action: Current Search  
 Action Input: Who won the World Cup in 1978  
 Observation: Argentina national football team  
 Thought: Do I need to use a tool? No  
 AI: The last letter in your name is ""b"" and the winner of the 1978 World Cup was the Argentina national football team.  
   
 > Finished chain.  
  
  
 'The last letter in your name is ""b"" and the winner of the 1978 World Cup was the Argentina national football team.'  

```

```
agent\_chain.run(input=""whats the current temperature in pomfret?"")  

```

```
 > Entering new AgentExecutor chain...  
   
 Thought: Do I need to use a tool? Yes  
 Action: Current Search  
 Action Input: Current temperature in Pomfret  
 Observation: Partly cloudy skies. High around 70F. Winds W at 5 to 10 mph. Humidity41%.  
 Thought: Do I need to use a tool? No  
 AI: The current temperature in Pomfret is around 70F with partly cloudy skies and winds W at 5 to 10 mph. The humidity is 41%.  
   
 > Finished chain.  
  
  
 'The current temperature in Pomfret is around 70F with partly cloudy skies and winds W at 5 to 10 mph. The humidity is 41%.'  

```
Using a chat model[​](#using-a-chat-model ""Direct link to Using a chat model"")
------------------------------------------------------------------------------

The `chat-conversational-react-description` agent type lets us create a conversational agent using a chat model instead of an LLM.


```
from langchain.memory import ConversationBufferMemory  
from langchain.chat\_models import ChatOpenAI  
  
memory = ConversationBufferMemory(memory\_key=""chat\_history"", return\_messages=True)  
llm = ChatOpenAI(openai\_api\_key=OPENAI\_API\_KEY, temperature=0)  
agent\_chain = initialize\_agent(tools, llm, agent=AgentType.CHAT\_CONVERSATIONAL\_REACT\_DESCRIPTION, verbose=True, memory=memory)  

```

```
agent\_chain.run(input=""hi, i am bob"")  

```

```
 > Entering new AgentExecutor chain...  
 {  
 ""action"": ""Final Answer"",  
 ""action\_input"": ""Hello Bob! How can I assist you today?""  
 }  
   
 > Finished chain.  
  
  
 'Hello Bob! How can I assist you today?'  

```

```
agent\_chain.run(input=""what's my name?"")  

```

```
 > Entering new AgentExecutor chain...  
 {  
 ""action"": ""Final Answer"",  
 ""action\_input"": ""Your name is Bob.""  
 }  
   
 > Finished chain.  
  
  
 'Your name is Bob.'  

```

```
agent\_chain.run(""what are some good dinners to make this week, if i like thai food?"")  

```

```
 > Entering new AgentExecutor chain...  
 {  
 ""action"": ""Current Search"",  
 ""action\_input"": ""Thai food dinner recipes""  
 }  
 Observation: 64 easy Thai recipes for any night of the week · Thai curry noodle soup · Thai yellow cauliflower, snake bean and tofu curry · Thai-spiced chicken hand pies · Thai ...  
 Thought:{  
 ""action"": ""Final Answer"",  
 ""action\_input"": ""Here are some Thai food dinner recipes you can try this week: Thai curry noodle soup, Thai yellow cauliflower, snake bean and tofu curry, Thai-spiced chicken hand pies, and many more. You can find the full list of recipes at the source I found earlier.""  
 }  
   
 > Finished chain.  
  
  
 'Here are some Thai food dinner recipes you can try this week: Thai curry noodle soup, Thai yellow cauliflower, snake bean and tofu curry, Thai-spiced chicken hand pies, and many more. You can find the full list of recipes at the source I found earlier.'  

```

```
agent\_chain.run(input=""tell me the last letter in my name, and also tell me who won the world cup in 1978?"")  

```

```
 > Entering new AgentExecutor chain...  
 {  
 ""action"": ""Final Answer"",  
 ""action\_input"": ""The last letter in your name is 'b'. Argentina won the World Cup in 1978.""  
 }  
   
 > Finished chain.  
  
  
 ""The last letter in your name is 'b'. Argentina won the World Cup in 1978.""  

```

```
agent\_chain.run(input=""whats the weather like in pomfret?"")  

```

```
 > Entering new AgentExecutor chain...  
 {  
 ""action"": ""Current Search"",  
 ""action\_input"": ""weather in pomfret""  
 }  
 Observation: Cloudy with showers. Low around 55F. Winds S at 5 to 10 mph. Chance of rain 60%. Humidity76%.  
 Thought:{  
 ""action"": ""Final Answer"",  
 ""action\_input"": ""Cloudy with showers. Low around 55F. Winds S at 5 to 10 mph. Chance of rain 60%. Humidity76%.""  
 }  
   
 > Finished chain.  
  
  
 'Cloudy with showers. Low around 55F. Winds S at 5 to 10 mph. Chance of rain 60%. Humidity76%.'  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/agents/agent_types/,"Agent types
===========

Action agents[​](#action-agents ""Direct link to Action agents"")
---------------------------------------------------------------

Agents use an LLM to determine which actions to take and in what order.
An action can either be using a tool and observing its output, or returning a response to the user.
Here are the agents available in LangChain.

### [Zero-shot ReAct](/docs/modules/agents/agent_types/react.html)[​](#zero-shot-react ""Direct link to zero-shot-react"")

This agent uses the [ReAct](https://arxiv.org/pdf/2205.00445.pdf) framework to determine which tool to use
based solely on the tool's description. Any number of tools can be provided.
This agent requires that a description is provided for each tool.

**Note**: This is the most general purpose action agent.

### [Structured input ReAct](/docs/modules/agents/agent_types/structured_chat.html)[​](#structured-input-react ""Direct link to structured-input-react"")

The structured tool chat agent is capable of using multi-input tools.
Older agents are configured to specify an action input as a single string, but this agent can use a tools' argument
schema to create a structured action input. This is useful for more complex tool usage, like precisely
navigating around a browser.

### [OpenAI Functions](/docs/modules/agents/agent_types/openai_functions_agent.html)[​](#openai-functions ""Direct link to openai-functions"")

Certain OpenAI models (like gpt-3.5-turbo-0613 and gpt-4-0613) have been explicitly fine-tuned to detect when a
function should to be called and respond with the inputs that should be passed to the function.
The OpenAI Functions Agent is designed to work with these models.

### [Conversational](/docs/modules/agents/agent_types/chat_conversation_agent.html)[​](#conversational ""Direct link to conversational"")

This agent is designed to be used in conversational settings.
The prompt is designed to make the agent helpful and conversational.
It uses the ReAct framework to decide which tool to use, and uses memory to remember the previous conversation interactions.

### [Self ask with search](/docs/modules/agents/agent_types/self_ask_with_search.html)[​](#self-ask-with-search ""Direct link to self-ask-with-search"")

This agent utilizes a single tool that should be named `Intermediate Answer`.
This tool should be able to lookup factual answers to questions. This agent
is equivalent to the original [self ask with search paper](https://ofir.io/self-ask.pdf),
where a Google search API was provided as the tool.

### [ReAct document store](/docs/modules/agents/agent_types/react_docstore.html)[​](#react-document-store ""Direct link to react-document-store"")

This agent uses the ReAct framework to interact with a docstore. Two tools must
be provided: a `Search` tool and a `Lookup` tool (they must be named exactly as so).
The `Search` tool should search for a document, while the `Lookup` tool should lookup
a term in the most recently found document.
This agent is equivalent to the
original [ReAct paper](https://arxiv.org/pdf/2210.03629.pdf), specifically the Wikipedia example.

[Plan-and-execute agents](/docs/modules/agents/agent_types/plan_and_execute.html)[​](#plan-and-execute-agents ""Direct link to plan-and-execute-agents"")
-------------------------------------------------------------------------------------------------------------------------------------------------------

Plan and execute agents accomplish an objective by first planning what to do, then executing the sub tasks. This idea is largely inspired by [BabyAGI](https://github.com/yoheinakajima/babyagi) and then the [""Plan-and-Solve"" paper](https://arxiv.org/abs/2305.04091).

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/agents/agent_types/openai_functions_agent,"OpenAI functions
================

Certain OpenAI models (like gpt-3.5-turbo-0613 and gpt-4-0613) have been fine-tuned to detect when a function should to be called and respond with the inputs that should be passed to the function.
In an API call, you can describe functions and have the model intelligently choose to output a JSON object containing arguments to call those functions.
The goal of the OpenAI Function APIs is to more reliably return valid and useful function calls than a generic text completion or chat API.

The OpenAI Functions Agent is designed to work with these models.

Install openai,google-search-results packages which are required as the langchain packages call them internally


> pip install openai google-search-results
> 
> 


```
from langchain import LLMMathChain, OpenAI, SerpAPIWrapper, SQLDatabase, SQLDatabaseChain  
from langchain.agents import initialize\_agent, Tool  
from langchain.agents import AgentType  
from langchain.chat\_models import ChatOpenAI  

```

```
llm = ChatOpenAI(temperature=0, model=""gpt-3.5-turbo-0613"")  
search = SerpAPIWrapper()  
llm\_math\_chain = LLMMathChain.from\_llm(llm=llm, verbose=True)  
db = SQLDatabase.from\_uri(""sqlite:///../../../../../notebooks/Chinook.db"")  
db\_chain = SQLDatabaseChain.from\_llm(llm, db, verbose=True)  
tools = [  
 Tool(  
 name = ""Search"",  
 func=search.run,  
 description=""useful for when you need to answer questions about current events. You should ask targeted questions""  
 ),  
 Tool(  
 name=""Calculator"",  
 func=llm\_math\_chain.run,  
 description=""useful for when you need to answer questions about math""  
 ),  
 Tool(  
 name=""FooBar-DB"",  
 func=db\_chain.run,  
 description=""useful for when you need to answer questions about FooBar. Input should be in the form of a question containing full context""  
 )  
]  

```

```
agent = initialize\_agent(tools, llm, agent=AgentType.OPENAI\_FUNCTIONS, verbose=True)  

```

```
agent.run(""Who is Leo DiCaprio's girlfriend? What is her current age raised to the 0.43 power?"")  

```

```
 > Entering new chain...  
   
 Invoking: `Search` with `{'query': 'Leo DiCaprio girlfriend'}`  
   
   
 Amidst his casual romance with Gigi, Leo allegedly entered a relationship with 19-year old model, Eden Polani, in February 2023.  
 Invoking: `Calculator` with `{'expression': '19^0.43'}`  
   
  
 > Entering new chain...  
 19^0.43```text  
 19\*\*0.43  
 ```  
 ...numexpr.evaluate(""19\*\*0.43"")...  
   
 Answer: 3.547023357958959  
 > Finished chain.  
 Answer: 3.547023357958959Leo DiCaprio's girlfriend is reportedly Eden Polani. Her current age raised to the power of 0.43 is approximately 3.55.  
   
 > Finished chain.  
  
  
 ""Leo DiCaprio's girlfriend is reportedly Eden Polani. Her current age raised to the power of 0.43 is approximately 3.55.""  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/agents/agent_types/plan_and_execute,"Plan and execute
================

Plan and execute agents accomplish an objective by first planning what to do, then executing the sub tasks. This idea is largely inspired by [BabyAGI](https://github.com/yoheinakajima/babyagi) and then the [""Plan-and-Solve"" paper](https://arxiv.org/abs/2305.04091).

The planning is almost always done by an LLM.

The execution is usually done by a separate agent (equipped with tools).

Imports[​](#imports ""Direct link to Imports"")
---------------------------------------------


```
from langchain.chat\_models import ChatOpenAI  
from langchain\_experimental.plan\_and\_execute import PlanAndExecute, load\_agent\_executor, load\_chat\_planner  
from langchain.llms import OpenAI  
from langchain import SerpAPIWrapper  
from langchain.agents.tools import Tool  
from langchain import LLMMathChain  

```
Tools[​](#tools ""Direct link to Tools"")
---------------------------------------


```
search = SerpAPIWrapper()  
llm = OpenAI(temperature=0)  
llm\_math\_chain = LLMMathChain.from\_llm(llm=llm, verbose=True)  
tools = [  
 Tool(  
 name = ""Search"",  
 func=search.run,  
 description=""useful for when you need to answer questions about current events""  
 ),  
 Tool(  
 name=""Calculator"",  
 func=llm\_math\_chain.run,  
 description=""useful for when you need to answer questions about math""  
 ),  
]  

```
Planner, Executor, and Agent[​](#planner-executor-and-agent ""Direct link to Planner, Executor, and Agent"")
----------------------------------------------------------------------------------------------------------


```
model = ChatOpenAI(temperature=0)  

```

```
planner = load\_chat\_planner(model)  

```

```
executor = load\_agent\_executor(model, tools, verbose=True)  

```

```
agent = PlanAndExecute(planner=planner, executor=executor, verbose=True)  

```
Run Example[​](#run-example ""Direct link to Run Example"")
---------------------------------------------------------


```
agent.run(""Who is Leo DiCaprio's girlfriend? What is her current age raised to the 0.43 power?"")  

```

```
   
   
 > Entering new PlanAndExecute chain...  
 steps=[Step(value=""Search for Leo DiCaprio's girlfriend on the internet.""), Step(value='Find her current age.'), Step(value='Raise her current age to the 0.43 power using a calculator or programming language.'), Step(value='Output the result.'), Step(value=""Given the above steps taken, respond to the user's original question.\n\n"")]  
   
 > Entering new AgentExecutor chain...  
 Action:  
 ```  
 {  
 ""action"": ""Search"",  
 ""action\_input"": ""Who is Leo DiCaprio's girlfriend?""  
 }  
 ```   
   
   
 Observation: DiCaprio broke up with girlfriend Camila Morrone, 25, in the summer of 2022, after dating for four years. He's since been linked to another famous supermodel – Gigi Hadid. The power couple were first supposedly an item in September after being spotted getting cozy during a party at New York Fashion Week.  
 Thought:Based on the previous observation, I can provide the answer to the current objective.   
 Action:  
 ```  
 {  
 ""action"": ""Final Answer"",  
 ""action\_input"": ""Leo DiCaprio is currently linked to Gigi Hadid.""  
 }  
 ```  
   
   
 > Finished chain.  
 \*\*\*\*\*  
   
 Step: Search for Leo DiCaprio's girlfriend on the internet.  
   
 Response: Leo DiCaprio is currently linked to Gigi Hadid.  
   
 > Entering new AgentExecutor chain...  
 Action:  
 ```  
 {  
 ""action"": ""Search"",  
 ""action\_input"": ""What is Gigi Hadid's current age?""  
 }  
 ```  
   
 Observation: 28 years  
 Thought:Previous steps: steps=[(Step(value=""Search for Leo DiCaprio's girlfriend on the internet.""), StepResponse(response='Leo DiCaprio is currently linked to Gigi Hadid.'))]  
   
 Current objective: value='Find her current age.'  
   
 Action:  
 ```  
 {  
 ""action"": ""Search"",  
 ""action\_input"": ""What is Gigi Hadid's current age?""  
 }  
 ```  
   
   
 Observation: 28 years  
 Thought:Previous steps: steps=[(Step(value=""Search for Leo DiCaprio's girlfriend on the internet.""), StepResponse(response='Leo DiCaprio is currently linked to Gigi Hadid.')), (Step(value='Find her current age.'), StepResponse(response='28 years'))]  
   
 Current objective: None  
   
 Action:  
 ```  
 {  
 ""action"": ""Final Answer"",  
 ""action\_input"": ""Gigi Hadid's current age is 28 years.""  
 }  
 ```  
   
   
   
 > Finished chain.  
 \*\*\*\*\*  
   
 Step: Find her current age.  
   
 Response: Gigi Hadid's current age is 28 years.  
   
 > Entering new AgentExecutor chain...  
 Action:  
 ```  
 {  
 ""action"": ""Calculator"",  
 ""action\_input"": ""28 \*\* 0.43""  
 }  
 ```  
   
   
 > Entering new LLMMathChain chain...  
 28 \*\* 0.43  
 ```text  
 28 \*\* 0.43  
 ```  
 ...numexpr.evaluate(""28 \*\* 0.43"")...  
   
 Answer: 4.1906168361987195  
 > Finished chain.  
   
 Observation: Answer: 4.1906168361987195  
 Thought:The next step is to provide the answer to the user's question.  
   
 Action:  
 ```  
 {  
 ""action"": ""Final Answer"",  
 ""action\_input"": ""Gigi Hadid's current age raised to the 0.43 power is approximately 4.19.""  
 }  
 ```  
   
   
   
 > Finished chain.  
 \*\*\*\*\*  
   
 Step: Raise her current age to the 0.43 power using a calculator or programming language.  
   
 Response: Gigi Hadid's current age raised to the 0.43 power is approximately 4.19.  
   
 > Entering new AgentExecutor chain...  
 Action:  
 ```  
 {  
 ""action"": ""Final Answer"",  
 ""action\_input"": ""The result is approximately 4.19.""  
 }  
 ```  
   
   
 > Finished chain.  
 \*\*\*\*\*  
   
 Step: Output the result.  
   
 Response: The result is approximately 4.19.  
   
 > Entering new AgentExecutor chain...  
 Action:  
 ```  
 {  
 ""action"": ""Final Answer"",  
 ""action\_input"": ""Gigi Hadid's current age raised to the 0.43 power is approximately 4.19.""  
 }  
 ```  
   
   
 > Finished chain.  
 \*\*\*\*\*  
   
 Step: Given the above steps taken, respond to the user's original question.  
   
   
   
 Response: Gigi Hadid's current age raised to the 0.43 power is approximately 4.19.  
 > Finished chain.  
  
  
  
  
  
 ""Gigi Hadid's current age raised to the 0.43 power is approximately 4.19.""  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/agents/agent_types/react,"ReAct
=====

This walkthrough showcases using an agent to implement the [ReAct](https://react-lm.github.io/) logic.


```
from langchain.agents import load\_tools  
from langchain.agents import initialize\_agent  
from langchain.agents import AgentType  
from langchain.llms import OpenAI  

```
First, let's load the language model we're going to use to control the agent.


```
llm = OpenAI(temperature=0)  

```
Next, let's load some tools to use. Note that the `llm-math` tool uses an LLM, so we need to pass that in.


```
tools = load\_tools([""serpapi"", ""llm-math""], llm=llm)  

```
Finally, let's initialize an agent with the tools, the language model, and the type of agent we want to use.


```
agent = initialize\_agent(tools, llm, agent=AgentType.ZERO\_SHOT\_REACT\_DESCRIPTION, verbose=True)  

```
Now let's test it out!


```
agent.run(""Who is Leo DiCaprio's girlfriend? What is her current age raised to the 0.43 power?"")  

```

```
 > Entering new AgentExecutor chain...  
 I need to find out who Leo DiCaprio's girlfriend is and then calculate her age raised to the 0.43 power.  
 Action: Search  
 Action Input: ""Leo DiCaprio girlfriend""  
 Observation: Camila Morrone  
 Thought: I need to find out Camila Morrone's age  
 Action: Search  
 Action Input: ""Camila Morrone age""  
 Observation: 25 years  
 Thought: I need to calculate 25 raised to the 0.43 power  
 Action: Calculator  
 Action Input: 25^0.43  
 Observation: Answer: 3.991298452658078  
   
 Thought: I now know the final answer  
 Final Answer: Camila Morrone is Leo DiCaprio's girlfriend and her current age raised to the 0.43 power is 3.991298452658078.  
   
 > Finished chain.  
  
  
 ""Camila Morrone is Leo DiCaprio's girlfriend and her current age raised to the 0.43 power is 3.991298452658078.""  

```
Using chat models[​](#using-chat-models ""Direct link to Using chat models"")
---------------------------------------------------------------------------

You can also create ReAct agents that use chat models instead of LLMs as the agent driver.


```
from langchain.chat\_models import ChatOpenAI  
  
chat\_model = ChatOpenAI(temperature=0)  
agent = initialize\_agent(tools, chat\_model, agent=AgentType.CHAT\_ZERO\_SHOT\_REACT\_DESCRIPTION, verbose=True)  
agent.run(""Who is Leo DiCaprio's girlfriend? What is her current age raised to the 0.43 power?"")  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/agents/agent_types/structured_chat,"Structured tool chat
====================

The structured tool chat agent is capable of using multi-input tools.

Older agents are configured to specify an action input as a single string, but this agent can use the provided tools' `args_schema` to populate the action input.

This functionality is natively available using agent types: `structured-chat-zero-shot-react-description` or `AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION`


```
import os  
os.environ[""LANGCHAIN\_TRACING""] = ""true"" # If you want to trace the execution of the program, set to ""true""  

```

```
from langchain.agents import AgentType  
from langchain.chat\_models import ChatOpenAI  
from langchain.agents import initialize\_agent  

```
### Initialize Tools[​](#initialize-tools ""Direct link to Initialize Tools"")

We will test the agent using a web browser.


```
from langchain.agents.agent\_toolkits import PlayWrightBrowserToolkit  
from langchain.tools.playwright.utils import (  
 create\_async\_playwright\_browser,  
 create\_sync\_playwright\_browser, # A synchronous browser is available, though it isn't compatible with jupyter.  
)  
  
# This import is required only for jupyter notebooks, since they have their own eventloop  
import nest\_asyncio  
nest\_asyncio.apply()  

```

```
async\_browser = create\_async\_playwright\_browser()  
browser\_toolkit = PlayWrightBrowserToolkit.from\_browser(async\_browser=async\_browser)  
tools = browser\_toolkit.get\_tools()  

```

```
llm = ChatOpenAI(temperature=0) # Also works well with Anthropic models  
agent\_chain = initialize\_agent(tools, llm, agent=AgentType.STRUCTURED\_CHAT\_ZERO\_SHOT\_REACT\_DESCRIPTION, verbose=True)  

```

```
response = await agent\_chain.arun(input=""Hi I'm Erica."")  
print(response)  

```

```
   
   
 > Entering new AgentExecutor chain...  
 Action:  
 ```  
 {  
 ""action"": ""Final Answer"",  
 ""action\_input"": ""Hello Erica, how can I assist you today?""  
 }  
 ```  
   
   
 > Finished chain.  
 Hello Erica, how can I assist you today?  

```

```
response = await agent\_chain.arun(input=""Don't need help really just chatting."")  
print(response)  

```

```
   
   
 > Entering new AgentExecutor chain...  
   
 > Finished chain.  
 I'm here to chat! How's your day going?  

```

```
response = await agent\_chain.arun(input=""Browse to blog.langchain.dev and summarize the text, please."")  
print(response)  

```

```
   
   
 > Entering new AgentExecutor chain...  
 Action:  
 ```  
 {  
 ""action"": ""navigate\_browser"",  
 ""action\_input"": {  
 ""url"": ""https://blog.langchain.dev/""  
 }  
 }  
 ```  
   
   
 Observation: Navigating to https://blog.langchain.dev/ returned status code 200  
 Thought:I need to extract the text from the webpage to summarize it.  
 Action:  
 ```  
 {  
 ""action"": ""extract\_text"",  
 ""action\_input"": {}  
 }  
 ```  
   
 Observation: LangChain LangChain Home About GitHub Docs LangChain The official LangChain blog. Auto-Evaluator Opportunities Editor's Note: this is a guest blog post by Lance Martin.  
   
   
 TL;DR  
   
 We recently open-sourced an auto-evaluator tool for grading LLM question-answer chains. We are now releasing an open source, free to use hosted app and API to expand usability. Below we discuss a few opportunities to further improve May 1, 2023 5 min read Callbacks Improvements TL;DR: We're announcing improvements to our callbacks system, which powers logging, tracing, streaming output, and some awesome third-party integrations. This will better support concurrent runs with independent callbacks, tracing of deeply nested trees of LangChain components, and callback handlers scoped to a single request (which is super useful for May 1, 2023 3 min read Unleashing the power of AI Collaboration with Parallelized LLM Agent Actor Trees Editor's note: the following is a guest blog post from Cyrus at Shaman AI. We use guest blog posts to highlight interesting and novel applications, and this is certainly that. There's been a lot of talk about agents recently, but most have been discussions around a single agent. If multiple Apr 28, 2023 4 min read Gradio & LLM Agents Editor's note: this is a guest blog post from Freddy Boulton, a software engineer at Gradio. We're excited to share this post because it brings a large number of exciting new tools into the ecosystem. Agents are largely defined by the tools they have, so to be able to equip Apr 23, 2023 4 min read RecAlign - The smart content filter for social media feed [Editor's Note] This is a guest post by Tian Jin. We are highlighting this application as we think it is a novel use case. Specifically, we think recommendation systems are incredibly impactful in our everyday lives and there has not been a ton of discourse on how LLMs will impact Apr 22, 2023 3 min read Improving Document Retrieval with Contextual Compression Note: This post assumes some familiarity with LangChain and is moderately technical.  
   
 💡 TL;DR: We’ve introduced a new abstraction and a new document Retriever to facilitate the post-processing of retrieved documents. Specifically, the new abstraction makes it easy to take a set of retrieved documents and extract from them Apr 20, 2023 3 min read Autonomous Agents & Agent Simulations Over the past two weeks, there has been a massive increase in using LLMs in an agentic manner. Specifically, projects like AutoGPT, BabyAGI, CAMEL, and Generative Agents have popped up. The LangChain community has now implemented some parts of all of those projects in the LangChain framework. While researching and Apr 18, 2023 7 min read AI-Powered Medical Knowledge: Revolutionizing Care for Rare Conditions [Editor's Note]: This is a guest post by Jack Simon, who recently participated in a hackathon at Williams College. He built a LangChain-powered chatbot focused on appendiceal cancer, aiming to make specialized knowledge more accessible to those in need. If you are interested in building a chatbot for another rare Apr 17, 2023 3 min read Auto-Eval of Question-Answering Tasks By Lance Martin  
   
 Context  
   
 LLM ops platforms, such as LangChain, make it easy to assemble LLM components (e.g., models, document retrievers, data loaders) into chains. Question-Answering is one of the most popular applications of these chains. But it is often not always obvious to determine what parameters (e.g. Apr 15, 2023 3 min read Announcing LangChainJS Support for Multiple JS Environments TLDR: We're announcing support for running LangChain.js in browsers, Cloudflare Workers, Vercel/Next.js, Deno, Supabase Edge Functions, alongside existing support for Node.js ESM and CJS. See install/upgrade docs and breaking changes list.  
   
   
 Context  
   
 Originally we designed LangChain.js to run in Node.js, which is the Apr 11, 2023 3 min read LangChain x Supabase Supabase is holding an AI Hackathon this week. Here at LangChain we are big fans of both Supabase and hackathons, so we thought this would be a perfect time to highlight the multiple ways you can use LangChain and Supabase together.  
   
 The reason we like Supabase so much is that Apr 8, 2023 2 min read Announcing our $10M seed round led by Benchmark It was only six months ago that we released the first version of LangChain, but it seems like several years. When we launched, generative AI was starting to go mainstream: stable diffusion had just been released and was captivating people’s imagination and fueling an explosion in developer activity, Jasper Apr 4, 2023 4 min read Custom Agents One of the most common requests we've heard is better functionality and documentation for creating custom agents. This has always been a bit tricky - because in our mind it's actually still very unclear what an ""agent"" actually is, and therefore what the ""right"" abstractions for them may be. Recently, Apr 3, 2023 3 min read Retrieval TL;DR: We are adjusting our abstractions to make it easy for other retrieval methods besides the LangChain VectorDB object to be used in LangChain. This is done with the goals of (1) allowing retrievers constructed elsewhere to be used more easily in LangChain, (2) encouraging more experimentation with alternative Mar 23, 2023 4 min read LangChain + Zapier Natural Language Actions (NLA) We are super excited to team up with Zapier and integrate their new Zapier NLA API into LangChain, which you can now use with your agents and chains. With this integration, you have access to the 5k+ apps and 20k+ actions on Zapier's platform through a natural language API interface. Mar 16, 2023 2 min read Evaluation Evaluation of language models, and by extension applications built on top of language models, is hard. With recent model releases (OpenAI, Anthropic, Google) evaluation is becoming a bigger and bigger issue. People are starting to try to tackle this, with OpenAI releasing OpenAI/evals - focused on evaluating OpenAI models. Mar 14, 2023 3 min read LLMs and SQL Francisco Ingham and Jon Luo are two of the community members leading the change on the SQL integrations. We’re really excited to write this blog post with them going over all the tips and tricks they’ve learned doing so. We’re even more excited to announce that we’ Mar 13, 2023 8 min read Origin Web Browser [Editor's Note]: This is the second of hopefully many guest posts. We intend to highlight novel applications building on top of LangChain. If you are interested in working with us on such a post, please reach out to harrison@langchain.dev.  
   
 Authors: Parth Asawa (pgasawa@), Ayushi Batwara (ayushi.batwara@), Jason Mar 8, 2023 4 min read Prompt Selectors One common complaint we've heard is that the default prompt templates do not work equally well for all models. This became especially pronounced this past week when OpenAI released a ChatGPT API. This new API had a completely new interface (which required new abstractions) and as a result many users Mar 8, 2023 2 min read Chat Models Last week OpenAI released a ChatGPT endpoint. It came marketed with several big improvements, most notably being 10x cheaper and a lot faster. But it also came with a completely new API endpoint. We were able to quickly write a wrapper for this endpoint to let users use it like Mar 6, 2023 6 min read Using the ChatGPT API to evaluate the ChatGPT API OpenAI released a new ChatGPT API yesterday. Lots of people were excited to try it. But how does it actually compare to the existing API? It will take some time before there is a definitive answer, but here are some initial thoughts. Because I'm lazy, I also enrolled the help Mar 2, 2023 5 min read Agent Toolkits Today, we're announcing agent toolkits, a new abstraction that allows developers to create agents designed for a particular use-case (for example, interacting with a relational database or interacting with an OpenAPI spec). We hope to continue developing different toolkits that can enable agents to do amazing feats. Toolkits are supported Mar 1, 2023 3 min read TypeScript Support It's finally here... TypeScript support for LangChain.  
   
 What does this mean? It means that all your favorite prompts, chains, and agents are all recreatable in TypeScript natively. Both the Python version and TypeScript version utilize the same serializable format, meaning that artifacts can seamlessly be shared between languages. As an Feb 17, 2023 2 min read Streaming Support in LangChain We’re excited to announce streaming support in LangChain. There's been a lot of talk about the best UX for LLM applications, and we believe streaming is at its core. We’ve also updated the chat-langchain repo to include streaming and async execution. We hope that this repo can serve Feb 14, 2023 2 min read LangChain + Chroma Today we’re announcing LangChain's integration with Chroma, the first step on the path to the Modern A.I Stack.  
   
   
 LangChain - The A.I-native developer toolkit  
   
 We started LangChain with the intent to build a modular and flexible framework for developing A.I-native applications. Some of the use cases Feb 13, 2023 2 min read Page 1 of 2 Older Posts → LangChain © 2023 Sign up Powered by Ghost  
 Thought:  
 > Finished chain.  
 The LangChain blog has recently released an open-source auto-evaluator tool for grading LLM question-answer chains and is now releasing an open-source, free-to-use hosted app and API to expand usability. The blog also discusses various opportunities to further improve the LangChain platform.  

```

```
response = await agent\_chain.arun(input=""What's the latest xkcd comic about?"")  
print(response)  

```

```
   
   
 > Entering new AgentExecutor chain...  
 Thought: I can navigate to the xkcd website and extract the latest comic title and alt text to answer the question.  
 Action:  
 ```  
 {  
 ""action"": ""navigate\_browser"",  
 ""action\_input"": {  
 ""url"": ""https://xkcd.com/""  
 }  
 }  
 ```  
   
 Observation: Navigating to https://xkcd.com/ returned status code 200  
 Thought:I can extract the latest comic title and alt text using CSS selectors.  
 Action:  
 ```  
 {  
 ""action"": ""get\_elements"",  
 ""action\_input"": {  
 ""selector"": ""#ctitle, #comic img"",  
 ""attributes"": [""alt"", ""src""]  
 }  
 }  
 ```   
   
 Observation: [{""alt"": ""Tapetum Lucidum"", ""src"": ""//imgs.xkcd.com/comics/tapetum\_lucidum.png""}]  
 Thought:  
 > Finished chain.  
 The latest xkcd comic is titled ""Tapetum Lucidum"" and the image can be found at https://xkcd.com/2565/.  

```
Adding in memory[​](#adding-in-memory ""Direct link to Adding in memory"")
------------------------------------------------------------------------

Here is how you add in memory to this agent


```
from langchain.prompts import MessagesPlaceholder  
from langchain.memory import ConversationBufferMemory  

```

```
chat\_history = MessagesPlaceholder(variable\_name=""chat\_history"")  
memory = ConversationBufferMemory(memory\_key=""chat\_history"", return\_messages=True)  

```

```
agent\_chain = initialize\_agent(  
 tools,   
 llm,   
 agent=AgentType.STRUCTURED\_CHAT\_ZERO\_SHOT\_REACT\_DESCRIPTION,   
 verbose=True,   
 memory=memory,   
 agent\_kwargs = {  
 ""memory\_prompts"": [chat\_history],  
 ""input\_variables"": [""input"", ""agent\_scratchpad"", ""chat\_history""]  
 }  
)  

```

```
response = await agent\_chain.arun(input=""Hi I'm Erica."")  
print(response)  

```

```
   
   
 > Entering new AgentExecutor chain...  
 Action:  
 ```  
 {  
 ""action"": ""Final Answer"",  
 ""action\_input"": ""Hi Erica! How can I assist you today?""  
 }  
 ```  
   
   
 > Finished chain.  
 Hi Erica! How can I assist you today?  

```

```
response = await agent\_chain.arun(input=""whats my name?"")  
print(response)  

```

```
   
   
 > Entering new AgentExecutor chain...  
 Your name is Erica.  
   
 > Finished chain.  
 Your name is Erica.  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/agents/how_to/custom_llm_agent,"Custom LLM Agent
================

This notebook goes through how to create your own custom LLM agent.

An LLM agent consists of three parts:

* PromptTemplate: This is the prompt template that can be used to instruct the language model on what to do
* LLM: This is the language model that powers the agent
* `stop` sequence: Instructs the LLM to stop generating as soon as this string is found
* OutputParser: This determines how to parse the LLMOutput into an AgentAction or AgentFinish object

The LLMAgent is used in an AgentExecutor. This AgentExecutor can largely be thought of as a loop that:

1. Passes user input and any previous steps to the Agent (in this case, the LLMAgent)
2. If the Agent returns an `AgentFinish`, then return that directly to the user
3. If the Agent returns an `AgentAction`, then use that to call a tool and get an `Observation`
4. Repeat, passing the `AgentAction` and `Observation` back to the Agent until an `AgentFinish` is emitted.

`AgentAction` is a response that consists of `action` and `action_input`. `action` refers to which tool to use, and `action_input` refers to the input to that tool. `log` can also be provided as more context (that can be used for logging, tracing, etc).

`AgentFinish` is a response that contains the final message to be sent back to the user. This should be used to end an agent run.

In this notebook we walk through how to create a custom LLM agent.

Set up environment[​](#set-up-environment ""Direct link to Set up environment"")
------------------------------------------------------------------------------

Do necessary imports, etc.


```
from langchain.agents import Tool, AgentExecutor, LLMSingleActionAgent, AgentOutputParser  
from langchain.prompts import StringPromptTemplate  
from langchain import OpenAI, SerpAPIWrapper, LLMChain  
from typing import List, Union  
from langchain.schema import AgentAction, AgentFinish, OutputParserException  
import re  

```
Set up tool[​](#set-up-tool ""Direct link to Set up tool"")
---------------------------------------------------------

Set up any tools the agent may want to use. This may be necessary to put in the prompt (so that the agent knows to use these tools).


```
# Define which tools the agent can use to answer user queries  
search = SerpAPIWrapper()  
tools = [  
 Tool(  
 name = ""Search"",  
 func=search.run,  
 description=""useful for when you need to answer questions about current events""  
 )  
]  

```
Prompt Template[​](#prompt-template ""Direct link to Prompt Template"")
---------------------------------------------------------------------

This instructs the agent on what to do. Generally, the template should incorporate:

* `tools`: which tools the agent has access and how and when to call them.
* `intermediate_steps`: These are tuples of previous (`AgentAction`, `Observation`) pairs. These are generally not passed directly to the model, but the prompt template formats them in a specific way.
* `input`: generic user input


```
# Set up the base template  
template = """"""Answer the following questions as best you can, but speaking as a pirate might speak. You have access to the following tools:  
  
{tools}  
  
Use the following format:  
  
Question: the input question you must answer  
Thought: you should always think about what to do  
Action: the action to take, should be one of [{tool\_names}]  
Action Input: the input to the action  
Observation: the result of the action  
... (this Thought/Action/Action Input/Observation can repeat N times)  
Thought: I now know the final answer  
Final Answer: the final answer to the original input question  
  
Begin! Remember to speak as a pirate when giving your final answer. Use lots of ""Arg""s  
  
Question: {input}  
{agent\_scratchpad}""""""  

```

```
# Set up a prompt template  
class CustomPromptTemplate(StringPromptTemplate):  
 # The template to use  
 template: str  
 # The list of tools available  
 tools: List[Tool]  
  
 def format(self, \*\*kwargs) -> str:  
 # Get the intermediate steps (AgentAction, Observation tuples)  
 # Format them in a particular way  
 intermediate\_steps = kwargs.pop(""intermediate\_steps"")  
 thoughts = """"  
 for action, observation in intermediate\_steps:  
 thoughts += action.log  
 thoughts += f""\nObservation: {observation}\nThought: ""  
 # Set the agent\_scratchpad variable to that value  
 kwargs[""agent\_scratchpad""] = thoughts  
 # Create a tools variable from the list of tools provided  
 kwargs[""tools""] = ""\n"".join([f""{tool.name}: {tool.description}"" for tool in self.tools])  
 # Create a list of tool names for the tools provided  
 kwargs[""tool\_names""] = "", "".join([tool.name for tool in self.tools])  
 return self.template.format(\*\*kwargs)  

```

```
prompt = CustomPromptTemplate(  
 template=template,  
 tools=tools,  
 # This omits the `agent\_scratchpad`, `tools`, and `tool\_names` variables because those are generated dynamically  
 # This includes the `intermediate\_steps` variable because that is needed  
 input\_variables=[""input"", ""intermediate\_steps""]  
)  

```
Output Parser[​](#output-parser ""Direct link to Output Parser"")
---------------------------------------------------------------

The output parser is responsible for parsing the LLM output into `AgentAction` and `AgentFinish`. This usually depends heavily on the prompt used.

This is where you can change the parsing to do retries, handle whitespace, etc


```
class CustomOutputParser(AgentOutputParser):  
  
 def parse(self, llm\_output: str) -> Union[AgentAction, AgentFinish]:  
 # Check if agent should finish  
 if ""Final Answer:"" in llm\_output:  
 return AgentFinish(  
 # Return values is generally always a dictionary with a single `output` key  
 # It is not recommended to try anything else at the moment :)  
 return\_values={""output"": llm\_output.split(""Final Answer:"")[-1].strip()},  
 log=llm\_output,  
 )  
 # Parse out the action and action input  
 regex = r""Action\s\*\d\*\s\*:(.\*?)\nAction\s\*\d\*\s\*Input\s\*\d\*\s\*:[\s]\*(.\*)""  
 match = re.search(regex, llm\_output, re.DOTALL)  
 if not match:  
 raise OutputParserException(f""Could not parse LLM output: `{llm\_output}`"")  
 action = match.group(1).strip()  
 action\_input = match.group(2)  
 # Return the action and action input  
 return AgentAction(tool=action, tool\_input=action\_input.strip("" "").strip('""'), log=llm\_output)  

```

```
output\_parser = CustomOutputParser()  

```
Set up LLM[​](#set-up-llm ""Direct link to Set up LLM"")
------------------------------------------------------

Choose the LLM you want to use!


```
llm = OpenAI(temperature=0)  

```
Define the stop sequence[​](#define-the-stop-sequence ""Direct link to Define the stop sequence"")
------------------------------------------------------------------------------------------------

This is important because it tells the LLM when to stop generation.

This depends heavily on the prompt and model you are using. Generally, you want this to be whatever token you use in the prompt to denote the start of an `Observation` (otherwise, the LLM may hallucinate an observation for you).

Set up the Agent[​](#set-up-the-agent ""Direct link to Set up the Agent"")
------------------------------------------------------------------------

We can now combine everything to set up our agent


```
# LLM chain consisting of the LLM and a prompt  
llm\_chain = LLMChain(llm=llm, prompt=prompt)  

```

```
tool\_names = [tool.name for tool in tools]  
agent = LLMSingleActionAgent(  
 llm\_chain=llm\_chain,  
 output\_parser=output\_parser,  
 stop=[""\nObservation:""],  
 allowed\_tools=tool\_names  
)  

```
Use the Agent[​](#use-the-agent ""Direct link to Use the Agent"")
---------------------------------------------------------------

Now we can use it!


```
agent\_executor = AgentExecutor.from\_agent\_and\_tools(agent=agent, tools=tools, verbose=True)  

```

```
agent\_executor.run(""How many people live in canada as of 2023?"")  

```

```
  
  
 > Entering new AgentExecutor chain...  
 Thought: I need to find out the population of Canada in 2023  
 Action: Search  
 Action Input: Population of Canada in 2023  
  
 Observation:The current population of Canada is 38,658,314 as of Wednesday, April 12, 2023, based on Worldometer elaboration of the latest United Nations data. I now know the final answer  
 Final Answer: Arrr, there be 38,658,314 people livin' in Canada as of 2023!  
  
 > Finished chain.  
  
  
  
  
  
 ""Arrr, there be 38,658,314 people livin' in Canada as of 2023!""  

```
Adding Memory[​](#adding-memory ""Direct link to Adding Memory"")
---------------------------------------------------------------

If you want to add memory to the agent, you'll need to:

1. Add a place in the custom prompt for the chat\_history
2. Add a memory object to the agent executor.


```
# Set up the base template  
template\_with\_history = """"""Answer the following questions as best you can, but speaking as a pirate might speak. You have access to the following tools:  
  
{tools}  
  
Use the following format:  
  
Question: the input question you must answer  
Thought: you should always think about what to do  
Action: the action to take, should be one of [{tool\_names}]  
Action Input: the input to the action  
Observation: the result of the action  
... (this Thought/Action/Action Input/Observation can repeat N times)  
Thought: I now know the final answer  
Final Answer: the final answer to the original input question  
  
Begin! Remember to speak as a pirate when giving your final answer. Use lots of ""Arg""s  
  
Previous conversation history:  
{history}  
  
New question: {input}  
{agent\_scratchpad}""""""  

```

```
prompt\_with\_history = CustomPromptTemplate(  
 template=template\_with\_history,  
 tools=tools,  
 # This omits the `agent\_scratchpad`, `tools`, and `tool\_names` variables because those are generated dynamically  
 # This includes the `intermediate\_steps` variable because that is needed  
 input\_variables=[""input"", ""intermediate\_steps"", ""history""]  
)  

```

```
llm\_chain = LLMChain(llm=llm, prompt=prompt\_with\_history)  

```

```
tool\_names = [tool.name for tool in tools]  
agent = LLMSingleActionAgent(  
 llm\_chain=llm\_chain,  
 output\_parser=output\_parser,  
 stop=[""\nObservation:""],  
 allowed\_tools=tool\_names  
)  

```

```
from langchain.memory import ConversationBufferWindowMemory  

```

```
memory=ConversationBufferWindowMemory(k=2)  

```

```
agent\_executor = AgentExecutor.from\_agent\_and\_tools(agent=agent, tools=tools, verbose=True, memory=memory)  

```

```
agent\_executor.run(""How many people live in canada as of 2023?"")  

```

```
  
  
 > Entering new AgentExecutor chain...  
 Thought: I need to find out the population of Canada in 2023  
 Action: Search  
 Action Input: Population of Canada in 2023  
  
 Observation:The current population of Canada is 38,658,314 as of Wednesday, April 12, 2023, based on Worldometer elaboration of the latest United Nations data. I now know the final answer  
 Final Answer: Arrr, there be 38,658,314 people livin' in Canada as of 2023!  
  
 > Finished chain.  
  
  
  
  
  
 ""Arrr, there be 38,658,314 people livin' in Canada as of 2023!""  

```

```
agent\_executor.run(""how about in mexico?"")  

```

```
  
  
 > Entering new AgentExecutor chain...  
 Thought: I need to find out how many people live in Mexico.  
 Action: Search  
 Action Input: How many people live in Mexico as of 2023?  
  
 Observation:The current population of Mexico is 132,679,922 as of Tuesday, April 11, 2023, based on Worldometer elaboration of the latest United Nations data. Mexico 2020 ... I now know the final answer.  
 Final Answer: Arrr, there be 132,679,922 people livin' in Mexico as of 2023!  
  
 > Finished chain.  
  
  
  
  
  
 ""Arrr, there be 132,679,922 people livin' in Mexico as of 2023!""  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/agents/how_to/custom_llm_chat_agent,"Custom LLM Agent (with a ChatModel)
===================================

This notebook goes through how to create your own custom agent based on a chat model.

An LLM chat agent consists of three parts:

* PromptTemplate: This is the prompt template that can be used to instruct the language model on what to do
* ChatModel: This is the language model that powers the agent
* `stop` sequence: Instructs the LLM to stop generating as soon as this string is found
* OutputParser: This determines how to parse the LLMOutput into an AgentAction or AgentFinish object

The LLMAgent is used in an AgentExecutor. This AgentExecutor can largely be thought of as a loop that:

1. Passes user input and any previous steps to the Agent (in this case, the LLMAgent)
2. If the Agent returns an `AgentFinish`, then return that directly to the user
3. If the Agent returns an `AgentAction`, then use that to call a tool and get an `Observation`
4. Repeat, passing the `AgentAction` and `Observation` back to the Agent until an `AgentFinish` is emitted.

`AgentAction` is a response that consists of `action` and `action_input`. `action` refers to which tool to use, and `action_input` refers to the input to that tool. `log` can also be provided as more context (that can be used for logging, tracing, etc).

`AgentFinish` is a response that contains the final message to be sent back to the user. This should be used to end an agent run.

In this notebook we walk through how to create a custom LLM agent.

Set up environment[​](#set-up-environment ""Direct link to Set up environment"")
------------------------------------------------------------------------------

Do necessary imports, etc.


```
pip install langchain  
pip install google-search-results  
pip install openai  

```

```
from langchain.agents import Tool, AgentExecutor, LLMSingleActionAgent, AgentOutputParser  
from langchain.prompts import BaseChatPromptTemplate  
from langchain import SerpAPIWrapper, LLMChain  
from langchain.chat\_models import ChatOpenAI  
from typing import List, Union  
from langchain.schema import AgentAction, AgentFinish, HumanMessage  
import re  
from getpass import getpass  

```
Set up tool[​](#set-up-tool ""Direct link to Set up tool"")
---------------------------------------------------------

Set up any tools the agent may want to use. This may be necessary to put in the prompt (so that the agent knows to use these tools).


```
SERPAPI\_API\_KEY = getpass()  

```

```
# Define which tools the agent can use to answer user queries  
search = SerpAPIWrapper(serpapi\_api\_key=SERPAPI\_API\_KEY)  
tools = [  
 Tool(  
 name = ""Search"",  
 func=search.run,  
 description=""useful for when you need to answer questions about current events""  
 )  
]  

```
Prompt Template[​](#prompt-template ""Direct link to Prompt Template"")
---------------------------------------------------------------------

This instructs the agent on what to do. Generally, the template should incorporate:

* `tools`: which tools the agent has access and how and when to call them.
* `intermediate_steps`: These are tuples of previous (`AgentAction`, `Observation`) pairs. These are generally not passed directly to the model, but the prompt template formats them in a specific way.
* `input`: generic user input


```
# Set up the base template  
template = """"""Complete the objective as best you can. You have access to the following tools:  
  
{tools}  
  
Use the following format:  
  
Question: the input question you must answer  
Thought: you should always think about what to do  
Action: the action to take, should be one of [{tool\_names}]  
Action Input: the input to the action  
Observation: the result of the action  
... (this Thought/Action/Action Input/Observation can repeat N times)  
Thought: I now know the final answer  
Final Answer: the final answer to the original input question  
  
These were previous tasks you completed:  
  
  
  
Begin!  
  
Question: {input}  
{agent\_scratchpad}""""""  

```

```
# Set up a prompt template  
class CustomPromptTemplate(BaseChatPromptTemplate):  
 # The template to use  
 template: str  
 # The list of tools available  
 tools: List[Tool]  
   
 def format\_messages(self, \*\*kwargs) -> str:  
 # Get the intermediate steps (AgentAction, Observation tuples)  
 # Format them in a particular way  
 intermediate\_steps = kwargs.pop(""intermediate\_steps"")  
 thoughts = """"  
 for action, observation in intermediate\_steps:  
 thoughts += action.log  
 thoughts += f""\nObservation: {observation}\nThought: ""  
 # Set the agent\_scratchpad variable to that value  
 kwargs[""agent\_scratchpad""] = thoughts  
 # Create a tools variable from the list of tools provided  
 kwargs[""tools""] = ""\n"".join([f""{tool.name}: {tool.description}"" for tool in self.tools])  
 # Create a list of tool names for the tools provided  
 kwargs[""tool\_names""] = "", "".join([tool.name for tool in self.tools])  
 formatted = self.template.format(\*\*kwargs)  
 return [HumanMessage(content=formatted)]  

```

```
prompt = CustomPromptTemplate(  
 template=template,  
 tools=tools,  
 # This omits the `agent\_scratchpad`, `tools`, and `tool\_names` variables because those are generated dynamically  
 # This includes the `intermediate\_steps` variable because that is needed  
 input\_variables=[""input"", ""intermediate\_steps""]  
)  

```
Output Parser[​](#output-parser ""Direct link to Output Parser"")
---------------------------------------------------------------

The output parser is responsible for parsing the LLM output into `AgentAction` and `AgentFinish`. This usually depends heavily on the prompt used.

This is where you can change the parsing to do retries, handle whitespace, etc


```
class CustomOutputParser(AgentOutputParser):  
   
 def parse(self, llm\_output: str) -> Union[AgentAction, AgentFinish]:  
 # Check if agent should finish  
 if ""Final Answer:"" in llm\_output:  
 return AgentFinish(  
 # Return values is generally always a dictionary with a single `output` key  
 # It is not recommended to try anything else at the moment :)  
 return\_values={""output"": llm\_output.split(""Final Answer:"")[-1].strip()},  
 log=llm\_output,  
 )  
 # Parse out the action and action input  
 regex = r""Action\s\*\d\*\s\*:(.\*?)\nAction\s\*\d\*\s\*Input\s\*\d\*\s\*:[\s]\*(.\*)""  
 match = re.search(regex, llm\_output, re.DOTALL)  
 if not match:  
 raise ValueError(f""Could not parse LLM output: `{llm\_output}`"")  
 action = match.group(1).strip()  
 action\_input = match.group(2)  
 # Return the action and action input  
 return AgentAction(tool=action, tool\_input=action\_input.strip("" "").strip('""'), log=llm\_output)  

```

```
output\_parser = CustomOutputParser()  

```
Set up LLM[​](#set-up-llm ""Direct link to Set up LLM"")
------------------------------------------------------

Choose the LLM you want to use!


```
OPENAI\_API\_KEY = getpass()  

```

```
llm = ChatOpenAI(openai\_api\_key=OPENAI\_API\_KEY, temperature=0)  

```
Define the stop sequence[​](#define-the-stop-sequence ""Direct link to Define the stop sequence"")
------------------------------------------------------------------------------------------------

This is important because it tells the LLM when to stop generation.

This depends heavily on the prompt and model you are using. Generally, you want this to be whatever token you use in the prompt to denote the start of an `Observation` (otherwise, the LLM may hallucinate an observation for you).

Set up the Agent[​](#set-up-the-agent ""Direct link to Set up the Agent"")
------------------------------------------------------------------------

We can now combine everything to set up our agent


```
# LLM chain consisting of the LLM and a prompt  
llm\_chain = LLMChain(llm=llm, prompt=prompt)  

```

```
tool\_names = [tool.name for tool in tools]  
agent = LLMSingleActionAgent(  
 llm\_chain=llm\_chain,   
 output\_parser=output\_parser,  
 stop=[""\nObservation:""],   
 allowed\_tools=tool\_names  
)  

```
Use the Agent[​](#use-the-agent ""Direct link to Use the Agent"")
---------------------------------------------------------------

Now we can use it!


```
agent\_executor = AgentExecutor.from\_agent\_and\_tools(agent=agent, tools=tools, verbose=True)  

```

```
agent\_executor.run(""Search for Leo DiCaprio's girlfriend on the internet."")  

```

```
   
   
 > Entering new AgentExecutor chain...  
 Thought: I should use a reliable search engine to get accurate information.  
 Action: Search  
 Action Input: ""Leo DiCaprio girlfriend""  
   
 Observation:He went on to date Gisele Bündchen, Bar Refaeli, Blake Lively, Toni Garrn and Nina Agdal, among others, before finally settling down with current girlfriend Camila Morrone, who is 23 years his junior.  
 I have found the answer to the question.  
 Final Answer: Leo DiCaprio's current girlfriend is Camila Morrone.  
   
 > Finished chain.  
  
  
  
  
  
 ""Leo DiCaprio's current girlfriend is Camila Morrone.""  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/agents/how_to/mrkl,"Replicating MRKL
================

This walkthrough demonstrates how to replicate the [MRKL](https://arxiv.org/pdf/2205.00445.pdf) system using agents.

This uses the example Chinook database.
To set it up follow the instructions on <https://database.guide/2-sample-databases-sqlite/>, placing the `.db` file in a notebooks folder at the root of this repository.


```
from langchain import LLMMathChain, OpenAI, SerpAPIWrapper, SQLDatabase, SQLDatabaseChain  
from langchain.agents import initialize\_agent, Tool  
from langchain.agents import AgentType  

```

```
llm = OpenAI(temperature=0)  
search = SerpAPIWrapper()  
llm\_math\_chain = LLMMathChain(llm=llm, verbose=True)  
db = SQLDatabase.from\_uri(""sqlite:///../../../../../notebooks/Chinook.db"")  
db\_chain = SQLDatabaseChain.from\_llm(llm, db, verbose=True)  
tools = [  
 Tool(  
 name = ""Search"",  
 func=search.run,  
 description=""useful for when you need to answer questions about current events. You should ask targeted questions""  
 ),  
 Tool(  
 name=""Calculator"",  
 func=llm\_math\_chain.run,  
 description=""useful for when you need to answer questions about math""  
 ),  
 Tool(  
 name=""FooBar DB"",  
 func=db\_chain.run,  
 description=""useful for when you need to answer questions about FooBar. Input should be in the form of a question containing full context""  
 )  
]  

```

```
mrkl = initialize\_agent(tools, llm, agent=AgentType.ZERO\_SHOT\_REACT\_DESCRIPTION, verbose=True)  

```

```
mrkl.run(""Who is Leo DiCaprio's girlfriend? What is her current age raised to the 0.43 power?"")  

```

```
 > Entering new AgentExecutor chain...  
 I need to find out who Leo DiCaprio's girlfriend is and then calculate her age raised to the 0.43 power.  
 Action: Search  
 Action Input: ""Who is Leo DiCaprio's girlfriend?""  
 Observation: DiCaprio met actor Camila Morrone in December 2017, when she was 20 and he was 43. They were spotted at Coachella and went on multiple vacations together. Some reports suggested that DiCaprio was ready to ask Morrone to marry him. The couple made their red carpet debut at the 2020 Academy Awards.  
 Thought: I need to calculate Camila Morrone's age raised to the 0.43 power.  
 Action: Calculator  
 Action Input: 21^0.43  
   
 > Entering new LLMMathChain chain...  
 21^0.43  
 ```text  
 21\*\*0.43  
 ```  
 ...numexpr.evaluate(""21\*\*0.43"")...  
   
 Answer: 3.7030049853137306  
 > Finished chain.  
   
 Observation: Answer: 3.7030049853137306  
 Thought: I now know the final answer.  
 Final Answer: Camila Morrone is Leo DiCaprio's girlfriend and her current age raised to the 0.43 power is 3.7030049853137306.  
   
 > Finished chain.  
  
  
 ""Camila Morrone is Leo DiCaprio's girlfriend and her current age raised to the 0.43 power is 3.7030049853137306.""  

```

```
mrkl.run(""What is the full name of the artist who recently released an album called 'The Storm Before the Calm' and are they in the FooBar database? If so, what albums of theirs are in the FooBar database?"")  

```

```
 > Entering new AgentExecutor chain...  
 I need to find out the artist's full name and then search the FooBar database for their albums.  
 Action: Search  
 Action Input: ""The Storm Before the Calm"" artist  
 Observation: The Storm Before the Calm (stylized in all lowercase) is the tenth (and eighth international) studio album by Canadian-American singer-songwriter Alanis Morissette, released June 17, 2022, via Epiphany Music and Thirty Tigers, as well as by RCA Records in Europe.  
 Thought: I now need to search the FooBar database for Alanis Morissette's albums.  
 Action: FooBar DB  
 Action Input: What albums by Alanis Morissette are in the FooBar database?  
   
 > Entering new SQLDatabaseChain chain...  
 What albums by Alanis Morissette are in the FooBar database?  
 SQLQuery:  
  
 /Users/harrisonchase/workplace/langchain/langchain/sql\_database.py:191: SAWarning: Dialect sqlite+pysqlite does \*not\* support Decimal objects natively, and SQLAlchemy must convert from floating point - rounding errors and other issues may occur. Please consider storing Decimal numbers as strings or integers on this platform for lossless storage.  
 sample\_rows = connection.execute(command)  
  
  
 SELECT ""Title"" FROM ""Album"" INNER JOIN ""Artist"" ON ""Album"".""ArtistId"" = ""Artist"".""ArtistId"" WHERE ""Name"" = 'Alanis Morissette' LIMIT 5;  
 SQLResult: [('Jagged Little Pill',)]  
 Answer: The albums by Alanis Morissette in the FooBar database are Jagged Little Pill.  
 > Finished chain.  
   
 Observation: The albums by Alanis Morissette in the FooBar database are Jagged Little Pill.  
 Thought: I now know the final answer.  
 Final Answer: The artist who released the album 'The Storm Before the Calm' is Alanis Morissette and the albums of hers in the FooBar database are Jagged Little Pill.  
   
 > Finished chain.  
  
  
 ""The artist who released the album 'The Storm Before the Calm' is Alanis Morissette and the albums of hers in the FooBar database are Jagged Little Pill.""  

```
With a chat model[​](#with-a-chat-model ""Direct link to With a chat model"")
---------------------------------------------------------------------------


```
from langchain.chat\_models import ChatOpenAI  
  
llm = ChatOpenAI(temperature=0)  
llm1 = OpenAI(temperature=0)  
search = SerpAPIWrapper()  
llm\_math\_chain = LLMMathChain(llm=llm1, verbose=True)  
db = SQLDatabase.from\_uri(""sqlite:///../../../../../notebooks/Chinook.db"")  
db\_chain = SQLDatabaseChain.from\_llm(llm1, db, verbose=True)  
tools = [  
 Tool(  
 name = ""Search"",  
 func=search.run,  
 description=""useful for when you need to answer questions about current events. You should ask targeted questions""  
 ),  
 Tool(  
 name=""Calculator"",  
 func=llm\_math\_chain.run,  
 description=""useful for when you need to answer questions about math""  
 ),  
 Tool(  
 name=""FooBar DB"",  
 func=db\_chain.run,  
 description=""useful for when you need to answer questions about FooBar. Input should be in the form of a question containing full context""  
 )  
]  

```

```
mrkl = initialize\_agent(tools, llm, agent=AgentType.CHAT\_ZERO\_SHOT\_REACT\_DESCRIPTION, verbose=True)  

```

```
mrkl.run(""Who is Leo DiCaprio's girlfriend? What is her current age raised to the 0.43 power?"")  

```

```
 > Entering new AgentExecutor chain...  
 Thought: The first question requires a search, while the second question requires a calculator.  
 Action:  
 ```  
 {  
 ""action"": ""Search"",  
 ""action\_input"": ""Leo DiCaprio girlfriend""  
 }  
 ```  
   
 Observation: Gigi Hadid: 2022 Leo and Gigi were first linked back in September 2022, when a source told Us Weekly that Leo had his “sights set"" on her (alarming way to put it, but okay).  
 Thought:For the second question, I need to calculate the age raised to the 0.43 power. I will use the calculator tool.  
 Action:  
 ```  
 {  
 ""action"": ""Calculator"",  
 ""action\_input"": ""((2022-1995)^0.43)""  
 }  
 ```  
   
   
 > Entering new LLMMathChain chain...  
 ((2022-1995)^0.43)  
 ```text  
 (2022-1995)\*\*0.43  
 ```  
 ...numexpr.evaluate(""(2022-1995)\*\*0.43"")...  
   
 Answer: 4.125593352125936  
 > Finished chain.  
   
 Observation: Answer: 4.125593352125936  
 Thought:I now know the final answer.  
 Final Answer: Gigi Hadid is Leo DiCaprio's girlfriend and her current age raised to the 0.43 power is approximately 4.13.  
   
 > Finished chain.  
  
  
 ""Gigi Hadid is Leo DiCaprio's girlfriend and her current age raised to the 0.43 power is approximately 4.13.""  

```

```
mrkl.run(""What is the full name of the artist who recently released an album called 'The Storm Before the Calm' and are they in the FooBar database? If so, what albums of theirs are in the FooBar database?"")  

```

```
 > Entering new AgentExecutor chain...  
 Question: What is the full name of the artist who recently released an album called 'The Storm Before the Calm' and are they in the FooBar database? If so, what albums of theirs are in the FooBar database?  
 Thought: I should use the Search tool to find the answer to the first part of the question and then use the FooBar DB tool to find the answer to the second part.  
 Action:  
 ```  
 {  
 ""action"": ""Search"",  
 ""action\_input"": ""Who recently released an album called 'The Storm Before the Calm'""  
 }  
 ```  
   
 Observation: Alanis Morissette  
 Thought:Now that I know the artist's name, I can use the FooBar DB tool to find out if they are in the database and what albums of theirs are in it.  
 Action:  
 ```  
 {  
 ""action"": ""FooBar DB"",  
 ""action\_input"": ""What albums does Alanis Morissette have in the database?""  
 }  
 ```  
  
   
 > Entering new SQLDatabaseChain chain...  
 What albums does Alanis Morissette have in the database?  
 SQLQuery:  
  
 /Users/harrisonchase/workplace/langchain/langchain/sql\_database.py:191: SAWarning: Dialect sqlite+pysqlite does \*not\* support Decimal objects natively, and SQLAlchemy must convert from floating point - rounding errors and other issues may occur. Please consider storing Decimal numbers as strings or integers on this platform for lossless storage.  
 sample\_rows = connection.execute(command)  
  
  
 SELECT ""Title"" FROM ""Album"" WHERE ""ArtistId"" IN (SELECT ""ArtistId"" FROM ""Artist"" WHERE ""Name"" = 'Alanis Morissette') LIMIT 5;  
 SQLResult: [('Jagged Little Pill',)]  
 Answer: Alanis Morissette has the album Jagged Little Pill in the database.  
 > Finished chain.  
   
 Observation: Alanis Morissette has the album Jagged Little Pill in the database.  
 Thought:The artist Alanis Morissette is in the FooBar database and has the album Jagged Little Pill in it.  
 Final Answer: Alanis Morissette is in the FooBar database and has the album Jagged Little Pill in it.  
   
 > Finished chain.  
  
  
 'Alanis Morissette is in the FooBar database and has the album Jagged Little Pill in it.'  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/agents/,"Agents
======

The core idea of agents is to use an LLM to choose a sequence of actions to take.
In chains, a sequence of actions is hardcoded (in code).
In agents, a language model is used as a reasoning engine to determine which actions to take and in which order.

There are several key components here:

Agent[​](#agent ""Direct link to Agent"")
---------------------------------------

This is the class responsible for deciding what step to take next.
This is powered by a language model and a prompt.
This prompt can include things like:

1. The personality of the agent (useful for having it respond in a certain way)
2. Background context for the agent (useful for giving it more context on the types of tasks it's being asked to do)
3. Prompting strategies to invoke better reasoning (the most famous/widely used being [ReAct](https://arxiv.org/abs/2210.03629))

LangChain provides a few different types of agents to get started.
Even then, you will likely want to customize those agents with parts (1) and (2).
For a full list of agent types see [agent types](/docs/modules/agents/agent_types/)

Tools[​](#tools ""Direct link to Tools"")
---------------------------------------

Tools are functions that an agent calls.
There are two important considerations here:

1. Giving the agent access to the right tools
2. Describing the tools in a way that is most helpful to the agent

Without both, the agent you are trying to build will not work.
If you don't give the agent access to a correct set of tools, it will never be able to accomplish the objective.
If you don't describe the tools properly, the agent won't know how to properly use them.

LangChain provides a wide set of tools to get started, but also makes it easy to define your own (including custom descriptions).
For a full list of tools, see [here](/docs/modules/agents/tools/)

Toolkits[​](#toolkits ""Direct link to Toolkits"")
------------------------------------------------

Often the set of tools an agent has access to is more important than a single tool.
For this LangChain provides the concept of toolkits - groups of tools needed to accomplish specific objectives.
There are generally around 3-5 tools in a toolkit.

LangChain provides a wide set of toolkits to get started.
For a full list of toolkits, see [here](/docs/modules/agents/toolkits/)

AgentExecutor[​](#agentexecutor ""Direct link to AgentExecutor"")
---------------------------------------------------------------

The agent executor is the runtime for an agent.
This is what actually calls the agent and executes the actions it chooses.
Pseudocode for this runtime is below:


```
next\_action = agent.get\_action(...)  
while next\_action != AgentFinish:  
 observation = run(next\_action)  
 next\_action = agent.get\_action(..., next\_action, observation)  
return next\_action  

```
While this may seem simple, there are several complexities this runtime handles for you, including:

1. Handling cases where the agent selects a non-existent tool
2. Handling cases where the tool errors
3. Handling cases where the agent produces output that cannot be parsed into a tool invocation
4. Logging and observability at all levels (agent decisions, tool calls) either to stdout or [LangSmith](https://smith.langchain.com).

Other types of agent runtimes[​](#other-types-of-agent-runtimes ""Direct link to Other types of agent runtimes"")
---------------------------------------------------------------------------------------------------------------

The `AgentExecutor` class is the main agent runtime supported by LangChain.
However, there are other, more experimental runtimes we also support.
These include:

* [Plan-and-execute Agent](/docs/modules/agents/agent_types/plan_and_execute.html)
* [Baby AGI](/docs/use_cases/autonomous_agents/baby_agi.html)
* [Auto GPT](/docs/use_cases/autonomous_agents/autogpt.html)

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------

This will go over how to get started building an agent.
We will use a LangChain agent class, but show how to customize it to give it specific context.
We will then define custom tools, and then run it all in the standard LangChain AgentExecutor.

### Set up the agent[​](#set-up-the-agent ""Direct link to Set up the agent"")

We will use the OpenAIFunctionsAgent.
This is easiest and best agent to get started with.
It does however require usage of ChatOpenAI models.
If you want to use a different language model, we would recommend using the [ReAct](/docs/modules/agents/agent_types/react) agent.

For this guide, we will construct a custom agent that has access to a custom tool.
We are choosing this example because we think for most use cases you will NEED to customize either the agent or the tools.
The tool we will give the agent is a tool to calculate the length of a word.
This is useful because this is actually something LLMs can mess up due to tokenization.
We will first create it WITHOUT memory, but we will then show how to add memory in.
Memory is needed to enable conversation.

First, let's load the language model we're going to use to control the agent.


```
from langchain.chat\_models import ChatOpenAI  
llm = ChatOpenAI(temperature=0)  

```
Next, let's define some tools to use.
Let's write a really simple Python function to calculate the length of a word that is passed in.


```
from langchain.agents import tool  
  
@tool  
def get\_word\_length(word: str) -> int:  
 """"""Returns the length of a word.""""""  
 return len(word)  
  
tools = [get\_word\_length]  

```
Now let us create the prompt.
We can use the `OpenAIFunctionsAgent.create_prompt` helper function to create a prompt automatically.
This allows for a few different ways to customize, including passing in a custom SystemMessage, which we will do.


```
from langchain.schema import SystemMessage  
system\_message = SystemMessage(content=""You are very powerful assistant, but bad at calculating lengths of words."")  
prompt = OpenAIFunctionsAgent.create\_prompt(system\_message=system\_message)  

```
Putting those pieces together, we can now create the agent.


```
from langchain.agents import OpenAIFunctionsAgent  
agent = OpenAIFunctionsAgent(llm=llm, tools=tools, prompt=prompt)  

```
Finally, we create the AgentExecutor - the runtime for our agent.


```
from langchain.agents import AgentExecutor  
agent\_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)  

```
Now let's test it out!


```
agent\_executor.run(""how many letters in the word educa?"")  

```

```
   
   
 > Entering new AgentExecutor chain...  
  
 Invoking: `get\_word\_length` with `{'word': 'educa'}`  
  
 5  
  
 There are 5 letters in the word ""educa"".  
  
 > Finished chain.  
  
 'There are 5 letters in the word ""educa"".'  

```
This is great - we have an agent!
However, this agent is stateless - it doesn't remember anything about previous interactions.
This means you can't ask follow up questions easily.
Let's fix that by adding in memory.

In order to do this, we need to do two things:

1. Add a place for memory variables to go in the prompt
2. Add memory to the AgentExecutor (note that we add it here, and NOT to the agent, as this is the outermost chain)

First, let's add a place for memory in the prompt.
We do this by adding a placeholder for messages with the key `""chat_history""`.


```
from langchain.prompts import MessagesPlaceholder  
  
MEMORY\_KEY = ""chat\_history""  
prompt = OpenAIFunctionsAgent.create\_prompt(  
 system\_message=system\_message,  
 extra\_prompt\_messages=[MessagesPlaceholder(variable\_name=MEMORY\_KEY)]  
)  

```
Next, let's create a memory object.
We will do this by using `ConversationBufferMemory`.
Importantly, we set `memory_key` also equal to `""chat_history""` (to align it with the prompt) and set `return_messages` (to make it return messages rather than a string).


```
from langchain.memory import ConversationBufferMemory  
  
memory = ConversationBufferMemory(memory\_key=MEMORY\_KEY, return\_messages=True)  

```
We can then put it all together!


```
agent = OpenAIFunctionsAgent(llm=llm, tools=tools, prompt=prompt)  
agent\_executor = AgentExecutor(agent=agent, tools=tools, memory=memory, verbose=True)  
agent\_executor.run(""how many letters in the word educa?"")  
agent\_executor.run(""is that a real word?"")  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/agents/toolkits/,"Toolkits
========

infoHead to [Integrations](/docs/integrations/toolkits/) for documentation on built-in toolkit integrations.

Toolkits are collections of tools that are designed to be used together for specific tasks and have convenience loading methods.

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/agents/tools/,"Tools
=====

infoHead to [Integrations](/docs/integrations/tools/) for documentation on built-in tool integrations.

Tools are interfaces that an agent can use to interact with the world.

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------

Tools are functions that agents can use to interact with the world.
These tools can be generic utilities (e.g. search), other chains, or even other agents.

Currently, tools can be loaded with the following snippet:


```
from langchain.agents import load\_tools  
tool\_names = [...]  
tools = load\_tools(tool\_names)  

```
Some tools (e.g. chains, agents) may require a base LLM to use to initialize them.
In that case, you can pass in an LLM as well:


```
from langchain.agents import load\_tools  
tool\_names = [...]  
llm = ...  
tools = load\_tools(tool\_names, llm=llm)  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/callbacks/,"Callbacks
=========

infoHead to [Integrations](/docs/integrations/callbacks/) for documentation on built-in callbacks integrations with 3rd-party tools.

LangChain provides a callbacks system that allows you to hook into the various stages of your LLM application. This is useful for logging, monitoring, streaming, and other tasks.

You can subscribe to these events by using the `callbacks` argument available throughout the API. This argument is list of handler objects, which are expected to implement one or more of the methods described below in more detail.

Callback handlers[​](#callback-handlers ""Direct link to Callback handlers"")
---------------------------------------------------------------------------

`CallbackHandlers` are objects that implement the `CallbackHandler` interface, which has a method for each event that can be subscribed to. The `CallbackManager` will call the appropriate method on each handler when the event is triggered.


```
class BaseCallbackHandler:  
 """"""Base callback handler that can be used to handle callbacks from langchain.""""""  
  
 def on\_llm\_start(  
 self, serialized: Dict[str, Any], prompts: List[str], \*\*kwargs: Any  
 ) -> Any:  
 """"""Run when LLM starts running.""""""  
  
 def on\_chat\_model\_start(  
 self, serialized: Dict[str, Any], messages: List[List[BaseMessage]], \*\*kwargs: Any  
 ) -> Any:  
 """"""Run when Chat Model starts running.""""""  
  
 def on\_llm\_new\_token(self, token: str, \*\*kwargs: Any) -> Any:  
 """"""Run on new LLM token. Only available when streaming is enabled.""""""  
  
 def on\_llm\_end(self, response: LLMResult, \*\*kwargs: Any) -> Any:  
 """"""Run when LLM ends running.""""""  
  
 def on\_llm\_error(  
 self, error: Union[Exception, KeyboardInterrupt], \*\*kwargs: Any  
 ) -> Any:  
 """"""Run when LLM errors.""""""  
  
 def on\_chain\_start(  
 self, serialized: Dict[str, Any], inputs: Dict[str, Any], \*\*kwargs: Any  
 ) -> Any:  
 """"""Run when chain starts running.""""""  
  
 def on\_chain\_end(self, outputs: Dict[str, Any], \*\*kwargs: Any) -> Any:  
 """"""Run when chain ends running.""""""  
  
 def on\_chain\_error(  
 self, error: Union[Exception, KeyboardInterrupt], \*\*kwargs: Any  
 ) -> Any:  
 """"""Run when chain errors.""""""  
  
 def on\_tool\_start(  
 self, serialized: Dict[str, Any], input\_str: str, \*\*kwargs: Any  
 ) -> Any:  
 """"""Run when tool starts running.""""""  
  
 def on\_tool\_end(self, output: str, \*\*kwargs: Any) -> Any:  
 """"""Run when tool ends running.""""""  
  
 def on\_tool\_error(  
 self, error: Union[Exception, KeyboardInterrupt], \*\*kwargs: Any  
 ) -> Any:  
 """"""Run when tool errors.""""""  
  
 def on\_text(self, text: str, \*\*kwargs: Any) -> Any:  
 """"""Run on arbitrary text.""""""  
  
 def on\_agent\_action(self, action: AgentAction, \*\*kwargs: Any) -> Any:  
 """"""Run on agent action.""""""  
  
 def on\_agent\_finish(self, finish: AgentFinish, \*\*kwargs: Any) -> Any:  
 """"""Run on agent end.""""""  

```
Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------

LangChain provides a few built-in handlers that you can use to get started. These are available in the `langchain/callbacks` module. The most basic handler is the `StdOutCallbackHandler`, which simply logs all events to `stdout`.

**Note** when the `verbose` flag on the object is set to true, the `StdOutCallbackHandler` will be invoked even without being explicitly passed in.


```
from langchain.callbacks import StdOutCallbackHandler  
from langchain.chains import LLMChain  
from langchain.llms import OpenAI  
from langchain.prompts import PromptTemplate  
  
handler = StdOutCallbackHandler()  
llm = OpenAI()  
prompt = PromptTemplate.from\_template(""1 + {number} = "")  
  
# Constructor callback: First, let's explicitly set the StdOutCallbackHandler when initializing our chain  
chain = LLMChain(llm=llm, prompt=prompt, callbacks=[handler])  
chain.run(number=2)  
  
# Use verbose flag: Then, let's use the `verbose` flag to achieve the same result  
chain = LLMChain(llm=llm, prompt=prompt, verbose=True)  
chain.run(number=2)  
  
# Request callbacks: Finally, let's use the request `callbacks` to achieve the same result  
chain = LLMChain(llm=llm, prompt=prompt)  
chain.run(number=2, callbacks=[handler])  

```

```
 > Entering new LLMChain chain...  
 Prompt after formatting:  
 1 + 2 =   
   
 > Finished chain.  
   
   
 > Entering new LLMChain chain...  
 Prompt after formatting:  
 1 + 2 =   
   
 > Finished chain.  
   
   
 > Entering new LLMChain chain...  
 Prompt after formatting:  
 1 + 2 =   
   
 > Finished chain.  
  
  
 '\n\n3'  

```
Where to pass in callbacks[​](#where-to-pass-in-callbacks ""Direct link to Where to pass in callbacks"")
------------------------------------------------------------------------------------------------------

The `callbacks` argument is available on most objects throughout the API (Chains, Models, Tools, Agents, etc.) in two different places:

* **Constructor callbacks**: defined in the constructor, eg. `LLMChain(callbacks=[handler], tags=['a-tag'])`, which will be used for all calls made on that object, and will be scoped to that object only, eg. if you pass a handler to the `LLMChain` constructor, it will not be used by the Model attached to that chain.
* **Request callbacks**: defined in the `run()`/`apply()` methods used for issuing a request, eg. `chain.run(input, callbacks=[handler])`, which will be used for that specific request only, and all sub-requests that it contains (eg. a call to an LLMChain triggers a call to a Model, which uses the same handler passed in the `call()` method).

The `verbose` argument is available on most objects throughout the API (Chains, Models, Tools, Agents, etc.) as a constructor argument, eg. `LLMChain(verbose=True)`, and it is equivalent to passing a `ConsoleCallbackHandler` to the `callbacks` argument of that object and all child objects. This is useful for debugging, as it will log all events to the console.

### When do you want to use each of these?[​](#when-do-you-want-to-use-each-of-these ""Direct link to When do you want to use each of these?"")

* Constructor callbacks are most useful for use cases such as logging, monitoring, etc., which are *not specific to a single request*, but rather to the entire chain. For example, if you want to log all the requests made to an LLMChain, you would pass a handler to the constructor.
* Request callbacks are most useful for use cases such as streaming, where you want to stream the output of a single request to a specific websocket connection, or other similar use cases. For example, if you want to stream the output of a single request to a websocket, you would pass a handler to the `call()` method
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/chains/document/,"Documents
=========

These are the core chains for working with Documents. They are useful for summarizing documents, answering questions over documents, extracting information from documents, and more.

These chains all implement a common interface:


```
class BaseCombineDocumentsChain(Chain, ABC):  
 """"""Base interface for chains combining documents.""""""  
  
 @abstractmethod  
 def combine\_docs(self, docs: List[Document], \*\*kwargs: Any) -> Tuple[str, dict]:  
 """"""Combine documents into a single string.""""""  
  

```
[📄️ Stuff
--------

The stuff documents chain (""stuff"" as in ""to stuff"" or ""to fill"") is the most straightforward of the document chains. It takes a list of documents, inserts them all into a prompt and passes that prompt to an LLM.](/docs/modules/chains/document/stuff)[📄️ Refine
---------

The refine documents chain constructs a response by looping over the input documents and iteratively updating its answer. For each document, it passes all non-document inputs, the current document, and the latest intermediate answer to an LLM chain to get a new answer.](/docs/modules/chains/document/refine)[📄️ Map reduce
-------------

The map reduce documents chain first applies an LLM chain to each document individually (the Map step), treating the chain output as a new document. It then passes all the new documents to a separate combine documents chain to get a single output (the Reduce step). It can optionally first compress, or collapse, the mapped documents to make sure that they fit in the combine documents chain (which will often pass them to an LLM). This compression step is performed recursively if necessary.](/docs/modules/chains/document/map_reduce)[📄️ Map re-rank
--------------

The map re-rank documents chain runs an initial prompt on each document, that not only tries to complete a task but also gives a score for how certain it is in its answer. The highest scoring response is returned.](/docs/modules/chains/document/map_rerank)",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/chains/document/map_reduce,"Map reduce
==========

The map reduce documents chain first applies an LLM chain to each document individually (the Map step), treating the chain output as a new document. It then passes all the new documents to a separate combine documents chain to get a single output (the Reduce step). It can optionally first compress, or collapse, the mapped documents to make sure that they fit in the combine documents chain (which will often pass them to an LLM). This compression step is performed recursively if necessary.

![map_reduce_diagram](/assets/images/map_reduce-c65525a871b62f5cacef431625c4d133.jpg)

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/chains/document/map_rerank,"Map re-rank
===========

The map re-rank documents chain runs an initial prompt on each document, that not only tries to complete a task but also gives a score for how certain it is in its answer. The highest scoring response is returned.

![map_rerank_diagram](/assets/images/map_rerank-0302b59b690c680ad6099b7bfe6d9fe5.jpg)

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/chains/document/refine,"Refine
======

The refine documents chain constructs a response by looping over the input documents and iteratively updating its answer. For each document, it passes all non-document inputs, the current document, and the latest intermediate answer to an LLM chain to get a new answer.

Since the Refine chain only passes a single document to the LLM at a time, it is well-suited for tasks that require analyzing more documents than can fit in the model's context.
The obvious tradeoff is that this chain will make far more LLM calls than, for example, the Stuff documents chain.
There are also certain tasks which are difficult to accomplish iteratively. For example, the Refine chain can perform poorly when documents frequently cross-reference one another or when a task requires detailed information from many documents.

![refine_diagram](/assets/images/refine-a70f30dd7ada6fe5e3fcc40dd70de037.jpg)

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/chains/document/stuff,"Stuff
=====

The stuff documents chain (""stuff"" as in ""to stuff"" or ""to fill"") is the most straightforward of the document chains. It takes a list of documents, inserts them all into a prompt and passes that prompt to an LLM.

This chain is well-suited for applications where documents are small and only a few are passed in for most calls.

![stuff_diagram](/assets/images/stuff-818da4c66ee17911bc8861c089316579.jpg)

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/chains/foundational/,"Foundational
============

[📄️ LLM
------

An LLMChain is a simple chain that adds some functionality around language models. It is used widely throughout LangChain, including in other chains and agents.](/docs/modules/chains/foundational/llm_chain)[📄️ Router
---------

This notebook demonstrates how to use the RouterChain paradigm to create a chain that dynamically selects the next chain to use for a given input.](/docs/modules/chains/foundational/router)[📄️ Sequential
-------------

The next step after calling a language model is make a series of calls to a language model. This is particularly useful when you want to take the output from one call and use it as the input to another.](/docs/modules/chains/foundational/sequential_chains)[📄️ Transformation
-----------------

This notebook showcases using a generic transformation chain.](/docs/modules/chains/foundational/transformation)",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/chains/foundational/llm_chain,"LLM
===

An LLMChain is a simple chain that adds some functionality around language models. It is used widely throughout LangChain, including in other chains and agents.

An LLMChain consists of a PromptTemplate and a language model (either an LLM or chat model). It formats the prompt template using the input key values provided (and also memory key values, if available), passes the formatted string to LLM and returns the LLM output.

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------


```
from langchain import PromptTemplate, OpenAI, LLMChain  
  
prompt\_template = ""What is a good name for a company that makes {product}?""  
  
llm = OpenAI(temperature=0)  
llm\_chain = LLMChain(  
 llm=llm,  
 prompt=PromptTemplate.from\_template(prompt\_template)  
)  
llm\_chain(""colorful socks"")  

```

```
 {'product': 'colorful socks', 'text': '\n\nSocktastic!'}  

```
Additional ways of running LLM Chain[​](#additional-ways-of-running-llm-chain ""Direct link to Additional ways of running LLM Chain"")
------------------------------------------------------------------------------------------------------------------------------------

Aside from `__call__` and `run` methods shared by all `Chain` object, `LLMChain` offers a few more ways of calling the chain logic:

* `apply` allows you run the chain against a list of inputs:


```
input\_list = [  
 {""product"": ""socks""},  
 {""product"": ""computer""},  
 {""product"": ""shoes""}  
]  
  
llm\_chain.apply(input\_list)  

```

```
 [{'text': '\n\nSocktastic!'},  
 {'text': '\n\nTechCore Solutions.'},  
 {'text': '\n\nFootwear Factory.'}]  

```
* `generate` is similar to `apply`, except it return an `LLMResult` instead of string. `LLMResult` often contains useful generation such as token usages and finish reason.


```
llm\_chain.generate(input\_list)  

```

```
 LLMResult(generations=[[Generation(text='\n\nSocktastic!', generation\_info={'finish\_reason': 'stop', 'logprobs': None})], [Generation(text='\n\nTechCore Solutions.', generation\_info={'finish\_reason': 'stop', 'logprobs': None})], [Generation(text='\n\nFootwear Factory.', generation\_info={'finish\_reason': 'stop', 'logprobs': None})]], llm\_output={'token\_usage': {'prompt\_tokens': 36, 'total\_tokens': 55, 'completion\_tokens': 19}, 'model\_name': 'text-davinci-003'})  

```
* `predict` is similar to `run` method except that the input keys are specified as keyword arguments instead of a Python dict.


```
# Single input example  
llm\_chain.predict(product=""colorful socks"")  

```

```
 '\n\nSocktastic!'  

```

```
# Multiple inputs example  
  
template = """"""Tell me a {adjective} joke about {subject}.""""""  
prompt = PromptTemplate(template=template, input\_variables=[""adjective"", ""subject""])  
llm\_chain = LLMChain(prompt=prompt, llm=OpenAI(temperature=0))  
  
llm\_chain.predict(adjective=""sad"", subject=""ducks"")  

```

```
 '\n\nQ: What did the duck say when his friend died?\nA: Quack, quack, goodbye.'  

```
Parsing the outputs[​](#parsing-the-outputs ""Direct link to Parsing the outputs"")
---------------------------------------------------------------------------------

By default, `LLMChain` does not parse the output even if the underlying `prompt` object has an output parser. If you would like to apply that output parser on the LLM output, use `predict_and_parse` instead of `predict` and `apply_and_parse` instead of `apply`. 

With `predict`:


```
from langchain.output\_parsers import CommaSeparatedListOutputParser  
  
output\_parser = CommaSeparatedListOutputParser()  
template = """"""List all the colors in a rainbow""""""  
prompt = PromptTemplate(template=template, input\_variables=[], output\_parser=output\_parser)  
llm\_chain = LLMChain(prompt=prompt, llm=llm)  
  
llm\_chain.predict()  

```

```
 '\n\nRed, orange, yellow, green, blue, indigo, violet'  

```
With `predict_and_parse`:


```
llm\_chain.predict\_and\_parse()  

```

```
 ['Red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']  

```
Initialize from string[​](#initialize-from-string ""Direct link to Initialize from string"")
------------------------------------------------------------------------------------------

You can also construct an LLMChain from a string template directly.


```
template = """"""Tell me a {adjective} joke about {subject}.""""""  
llm\_chain = LLMChain.from\_string(llm=llm, template=template)  

```

```
llm\_chain.predict(adjective=""sad"", subject=""ducks"")  

```

```
 '\n\nQ: What did the duck say when his friend died?\nA: Quack, quack, goodbye.'  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/chains/foundational/sequential_chains,"Sequential
==========

The next step after calling a language model is make a series of calls to a language model. This is particularly useful when you want to take the output from one call and use it as the input to another.

In this notebook we will walk through some examples for how to do this, using sequential chains. Sequential chains allow you to connect multiple chains and compose them into pipelines that execute some specific scenario.. There are two types of sequential chains:

* `SimpleSequentialChain`: The simplest form of sequential chains, where each step has a singular input/output, and the output of one step is the input to the next.
* `SequentialChain`: A more general form of sequential chains, allowing for multiple inputs/outputs.


```
from langchain.llms import OpenAI  
from langchain.chains import LLMChain  
from langchain.prompts import PromptTemplate  

```

```
# This is an LLMChain to write a synopsis given a title of a play.  
llm = OpenAI(temperature=.7)  
template = """"""You are a playwright. Given the title of play, it is your job to write a synopsis for that title.  
  
Title: {title}  
Playwright: This is a synopsis for the above play:""""""  
prompt\_template = PromptTemplate(input\_variables=[""title""], template=template)  
synopsis\_chain = LLMChain(llm=llm, prompt=prompt\_template)  

```

```
# This is an LLMChain to write a review of a play given a synopsis.  
llm = OpenAI(temperature=.7)  
template = """"""You are a play critic from the New York Times. Given the synopsis of play, it is your job to write a review for that play.  
  
Play Synopsis:  
{synopsis}  
Review from a New York Times play critic of the above play:""""""  
prompt\_template = PromptTemplate(input\_variables=[""synopsis""], template=template)  
review\_chain = LLMChain(llm=llm, prompt=prompt\_template)  

```

```
# This is the overall chain where we run these two chains in sequence.  
from langchain.chains import SimpleSequentialChain  
overall\_chain = SimpleSequentialChain(chains=[synopsis\_chain, review\_chain], verbose=True)  

```

```
review = overall\_chain.run(""Tragedy at sunset on the beach"")  

```

```
   
   
 > Entering new SimpleSequentialChain chain...  
   
   
 Tragedy at Sunset on the Beach is a story of a young couple, Jack and Sarah, who are in love and looking forward to their future together. On the night of their anniversary, they decide to take a walk on the beach at sunset. As they are walking, they come across a mysterious figure, who tells them that their love will be tested in the near future.   
   
 The figure then tells the couple that the sun will soon set, and with it, a tragedy will strike. If Jack and Sarah can stay together and pass the test, they will be granted everlasting love. However, if they fail, their love will be lost forever.  
   
 The play follows the couple as they struggle to stay together and battle the forces that threaten to tear them apart. Despite the tragedy that awaits them, they remain devoted to one another and fight to keep their love alive. In the end, the couple must decide whether to take a chance on their future together or succumb to the tragedy of the sunset.  
   
   
 Tragedy at Sunset on the Beach is an emotionally gripping story of love, hope, and sacrifice. Through the story of Jack and Sarah, the audience is taken on a journey of self-discovery and the power of love to overcome even the greatest of obstacles.   
   
 The play's talented cast brings the characters to life, allowing us to feel the depths of their emotion and the intensity of their struggle. With its compelling story and captivating performances, this play is sure to draw in audiences and leave them on the edge of their seats.   
   
 The play's setting of the beach at sunset adds a touch of poignancy and romanticism to the story, while the mysterious figure serves to keep the audience enthralled. Overall, Tragedy at Sunset on the Beach is an engaging and thought-provoking play that is sure to leave audiences feeling inspired and hopeful.  
   
 > Finished chain.  

```

```
print(review)  

```

```
   
   
 Tragedy at Sunset on the Beach is an emotionally gripping story of love, hope, and sacrifice. Through the story of Jack and Sarah, the audience is taken on a journey of self-discovery and the power of love to overcome even the greatest of obstacles.   
   
 The play's talented cast brings the characters to life, allowing us to feel the depths of their emotion and the intensity of their struggle. With its compelling story and captivating performances, this play is sure to draw in audiences and leave them on the edge of their seats.   
   
 The play's setting of the beach at sunset adds a touch of poignancy and romanticism to the story, while the mysterious figure serves to keep the audience enthralled. Overall, Tragedy at Sunset on the Beach is an engaging and thought-provoking play that is sure to leave audiences feeling inspired and hopeful.  

```
Sequential Chain[​](#sequential-chain ""Direct link to Sequential Chain"")
------------------------------------------------------------------------

Of course, not all sequential chains will be as simple as passing a single string as an argument and getting a single string as output for all steps in the chain. In this next example, we will experiment with more complex chains that involve multiple inputs, and where there also multiple final outputs. 

Of particular importance is how we name the input/output variable names. In the above example we didn't have to think about that because we were just passing the output of one chain directly as input to the next, but here we do have worry about that because we have multiple inputs.


```
# This is an LLMChain to write a synopsis given a title of a play and the era it is set in.  
llm = OpenAI(temperature=.7)  
template = """"""You are a playwright. Given the title of play and the era it is set in, it is your job to write a synopsis for that title.  
  
Title: {title}  
Era: {era}  
Playwright: This is a synopsis for the above play:""""""  
prompt\_template = PromptTemplate(input\_variables=[""title"", ""era""], template=template)  
synopsis\_chain = LLMChain(llm=llm, prompt=prompt\_template, output\_key=""synopsis"")  

```

```
# This is an LLMChain to write a review of a play given a synopsis.  
llm = OpenAI(temperature=.7)  
template = """"""You are a play critic from the New York Times. Given the synopsis of play, it is your job to write a review for that play.  
  
Play Synopsis:  
{synopsis}  
Review from a New York Times play critic of the above play:""""""  
prompt\_template = PromptTemplate(input\_variables=[""synopsis""], template=template)  
review\_chain = LLMChain(llm=llm, prompt=prompt\_template, output\_key=""review"")  

```

```
# This is the overall chain where we run these two chains in sequence.  
from langchain.chains import SequentialChain  
overall\_chain = SequentialChain(  
 chains=[synopsis\_chain, review\_chain],  
 input\_variables=[""era"", ""title""],  
 # Here we return multiple variables  
 output\_variables=[""synopsis"", ""review""],  
 verbose=True)  

```

```
overall\_chain({""title"":""Tragedy at sunset on the beach"", ""era"": ""Victorian England""})  

```

```
   
   
 > Entering new SequentialChain chain...  
   
 > Finished chain.  
  
  
  
  
  
 {'title': 'Tragedy at sunset on the beach',  
 'era': 'Victorian England',  
 'synopsis': ""\n\nThe play follows the story of John, a young man from a wealthy Victorian family, who dreams of a better life for himself. He soon meets a beautiful young woman named Mary, who shares his dream. The two fall in love and decide to elope and start a new life together.\n\nOn their journey, they make their way to a beach at sunset, where they plan to exchange their vows of love. Unbeknownst to them, their plans are overheard by John's father, who has been tracking them. He follows them to the beach and, in a fit of rage, confronts them. \n\nA physical altercation ensues, and in the struggle, John's father accidentally stabs Mary in the chest with his sword. The two are left in shock and disbelief as Mary dies in John's arms, her last words being a declaration of her love for him.\n\nThe tragedy of the play comes to a head when John, broken and with no hope of a future, chooses to take his own life by jumping off the cliffs into the sea below. \n\nThe play is a powerful story of love, hope, and loss set against the backdrop of 19th century England."",  
 'review': ""\n\nThe latest production from playwright X is a powerful and heartbreaking story of love and loss set against the backdrop of 19th century England. The play follows John, a young man from a wealthy Victorian family, and Mary, a beautiful young woman with whom he falls in love. The two decide to elope and start a new life together, and the audience is taken on a journey of hope and optimism for the future.\n\nUnfortunately, their dreams are cut short when John's father discovers them and in a fit of rage, fatally stabs Mary. The tragedy of the play is further compounded when John, broken and without hope, takes his own life. The storyline is not only realistic, but also emotionally compelling, drawing the audience in from start to finish.\n\nThe acting was also commendable, with the actors delivering believable and nuanced performances. The playwright and director have successfully crafted a timeless tale of love and loss that will resonate with audiences for years to come. Highly recommended.""}  

```
### Memory in Sequential Chains[​](#memory-in-sequential-chains ""Direct link to Memory in Sequential Chains"")

Sometimes you may want to pass along some context to use in each step of the chain or in a later part of the chain, but maintaining and chaining together the input/output variables can quickly get messy. Using `SimpleMemory` is a convenient way to do manage this and clean up your chains.

For example, using the previous playwright SequentialChain, lets say you wanted to include some context about date, time and location of the play, and using the generated synopsis and review, create some social media post text. You could add these new context variables as `input_variables`, or we can add a `SimpleMemory` to the chain to manage this context:


```
from langchain.chains import SequentialChain  
from langchain.memory import SimpleMemory  
  
llm = OpenAI(temperature=.7)  
template = """"""You are a social media manager for a theater company. Given the title of play, the era it is set in, the date,time and location, the synopsis of the play, and the review of the play, it is your job to write a social media post for that play.  
  
Here is some context about the time and location of the play:  
Date and Time: {time}  
Location: {location}  
  
Play Synopsis:  
{synopsis}  
Review from a New York Times play critic of the above play:  
{review}  
  
Social Media Post:  
""""""  
prompt\_template = PromptTemplate(input\_variables=[""synopsis"", ""review"", ""time"", ""location""], template=template)  
social\_chain = LLMChain(llm=llm, prompt=prompt\_template, output\_key=""social\_post\_text"")  
  
overall\_chain = SequentialChain(  
 memory=SimpleMemory(memories={""time"": ""December 25th, 8pm PST"", ""location"": ""Theater in the Park""}),  
 chains=[synopsis\_chain, review\_chain, social\_chain],  
 input\_variables=[""era"", ""title""],  
 # Here we return multiple variables  
 output\_variables=[""social\_post\_text""],  
 verbose=True)  
  
overall\_chain({""title"":""Tragedy at sunset on the beach"", ""era"": ""Victorian England""})  

```

```
   
   
 > Entering new SequentialChain chain...  
   
 > Finished chain.  
  
  
  
  
  
 {'title': 'Tragedy at sunset on the beach',  
 'era': 'Victorian England',  
 'time': 'December 25th, 8pm PST',  
 'location': 'Theater in the Park',  
 'social\_post\_text': ""\nSpend your Christmas night with us at Theater in the Park and experience the heartbreaking story of love and loss that is 'A Walk on the Beach'. Set in Victorian England, this romantic tragedy follows the story of Frances and Edward, a young couple whose love is tragically cut short. Don't miss this emotional and thought-provoking production that is sure to leave you in tears. #AWalkOnTheBeach #LoveAndLoss #TheaterInThePark #VictorianEngland""}  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/chains/how_to/debugging,"Debugging chains
================

It can be hard to debug a `Chain` object solely from its output as most `Chain` objects involve a fair amount of input prompt preprocessing and LLM output post-processing.

Setting `verbose` to `True` will print out some internal states of the `Chain` object while it is being ran.


```
conversation = ConversationChain(  
 llm=chat,  
 memory=ConversationBufferMemory(),  
 verbose=True  
)  
conversation.run(""What is ChatGPT?"")  

```

```
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
  
 Current conversation:  
  
 Human: What is ChatGPT?  
 AI:  
  
 > Finished chain.  
  
 'ChatGPT is an AI language model developed by OpenAI. It is based on the GPT-3 architecture and is capable of generating human-like responses to text prompts. ChatGPT has been trained on a massive amount of text data and can understand and respond to a wide range of topics. It is often used for chatbots, virtual assistants, and other conversational AI applications.'  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/chains/how_to/,"How to
======

[📄️ Async API
------------

LangChain provides async support for Chains by leveraging the asyncio library.](/docs/modules/chains/how_to/async_chain)[📄️ Different call methods
-------------------------

All classes inherited from Chain offer a few ways of running chain logic. The most direct one is by using call:](/docs/modules/chains/how_to/call_methods)[📄️ Custom chain
---------------

To implement your own custom chain you can subclass Chain and implement the following methods:](/docs/modules/chains/how_to/custom_chain)[📄️ Debugging chains
-------------------

It can be hard to debug a Chain object solely from its output as most Chain objects involve a fair amount of input prompt preprocessing and LLM output post-processing.](/docs/modules/chains/how_to/debugging)[📄️ Loading from LangChainHub
----------------------------

This notebook covers how to load chains from LangChainHub.](/docs/modules/chains/how_to/from_hub)[📄️ Adding memory (state)
------------------------

Chains can be initialized with a Memory object, which will persist data across calls to the chain. This makes a Chain stateful.](/docs/modules/chains/how_to/memory)[📄️ Using OpenAI functions
-------------------------

This walkthrough demonstrates how to incorporate OpenAI function-calling API's in a chain. We'll go over:](/docs/modules/chains/how_to/openai_functions)[📄️ Serialization
----------------

This notebook covers how to serialize chains to and from disk. The serialization format we use is json or yaml. Currently, only some chains support this type of serialization. We will grow the number of supported chains over time.](/docs/modules/chains/how_to/serialization)",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/chains/how_to/memory,"Adding memory (state)
=====================

Chains can be initialized with a Memory object, which will persist data across calls to the chain. This makes a Chain stateful.

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------


```
from langchain.chains import ConversationChain  
from langchain.memory import ConversationBufferMemory  
  
conversation = ConversationChain(  
 llm=chat,  
 memory=ConversationBufferMemory()  
)  
  
conversation.run(""Answer briefly. What are the first 3 colors of a rainbow?"")  
# -> The first three colors of a rainbow are red, orange, and yellow.  
conversation.run(""And the next 4?"")  
# -> The next four colors of a rainbow are green, blue, indigo, and violet.  

```

```
 'The next four colors of a rainbow are green, blue, indigo, and violet.'  

```
Essentially, `BaseMemory` defines an interface of how `langchain` stores memory. It allows reading of stored data through `load_memory_variables` method and storing new data through `save_context` method. You can learn more about it in the [Memory](/docs/modules/memory/) section.

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/chains/,"Chains
======

Using an LLM in isolation is fine for simple applications,
but more complex applications require chaining LLMs - either with each other or with other components.

LangChain provides the **Chain** interface for such ""chained"" applications. We define a Chain very generically as a sequence of calls to components, which can include other chains. The base interface is simple:


```
class Chain(BaseModel, ABC):  
 """"""Base interface that all chains should implement.""""""  
  
 memory: BaseMemory  
 callbacks: Callbacks  
  
 def \_\_call\_\_(  
 self,  
 inputs: Any,  
 return\_only\_outputs: bool = False,  
 callbacks: Callbacks = None,  
 ) -> Dict[str, Any]:  
 ...  

```
This idea of composing components together in a chain is simple but powerful. It drastically simplifies and makes more modular the implementation of complex applications, which in turn makes it much easier to debug, maintain, and improve your applications.

For more specifics check out:

* [How-to](/docs/modules/chains/how_to/) for walkthroughs of different chain features
* [Foundational](/docs/modules/chains/foundational/) to get acquainted with core building block chains
* [Document](/docs/modules/chains/document/) to learn how to incorporate documents into chains
* [Popular](/docs/modules/chains/popular/) chains for the most common use cases
* [Additional](/docs/modules/chains/additional/) to see some of the more advanced chains and integrations that you can use out of the box

Why do we need chains?[​](#why-do-we-need-chains ""Direct link to Why do we need chains?"")
-----------------------------------------------------------------------------------------

Chains allow us to combine multiple components together to create a single, coherent application. For example, we can create a chain that takes user input, formats it with a PromptTemplate, and then passes the formatted response to an LLM. We can build more complex chains by combining multiple chains together, or by combining chains with other components.

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------

#### Using `LLMChain`[​](#using-llmchain ""Direct link to using-llmchain"")

The `LLMChain` is most basic building block chain. It takes in a prompt template, formats it with the user input and returns the response from an LLM.

To use the `LLMChain`, first create a prompt template.


```
from langchain.llms import OpenAI  
from langchain.prompts import PromptTemplate  
  
llm = OpenAI(temperature=0.9)  
prompt = PromptTemplate(  
 input\_variables=[""product""],  
 template=""What is a good name for a company that makes {product}?"",  
)  

```
We can now create a very simple chain that will take user input, format the prompt with it, and then send it to the LLM.


```
from langchain.chains import LLMChain  
chain = LLMChain(llm=llm, prompt=prompt)  
  
# Run the chain only specifying the input variable.  
print(chain.run(""colorful socks""))  

```

```
 Colorful Toes Co.  

```
If there are multiple variables, you can input them all at once using a dictionary.


```
prompt = PromptTemplate(  
 input\_variables=[""company"", ""product""],  
 template=""What is a good name for {company} that makes {product}?"",  
)  
chain = LLMChain(llm=llm, prompt=prompt)  
print(chain.run({  
 'company': ""ABC Startup"",  
 'product': ""colorful socks""  
 }))  

```

```
 Socktopia Colourful Creations.  

```
You can use a chat model in an `LLMChain` as well:


```
from langchain.chat\_models import ChatOpenAI  
from langchain.prompts.chat import (  
 ChatPromptTemplate,  
 HumanMessagePromptTemplate,  
)  
human\_message\_prompt = HumanMessagePromptTemplate(  
 prompt=PromptTemplate(  
 template=""What is a good name for a company that makes {product}?"",  
 input\_variables=[""product""],  
 )  
 )  
chat\_prompt\_template = ChatPromptTemplate.from\_messages([human\_message\_prompt])  
chat = ChatOpenAI(temperature=0.9)  
chain = LLMChain(llm=chat, prompt=chat\_prompt\_template)  
print(chain.run(""colorful socks""))  

```

```
 Rainbow Socks Co.  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/document_loaders/csv,"CSV
===


> A [comma-separated values (CSV)](https://en.wikipedia.org/wiki/Comma-separated_values) file is a delimited text file that uses a comma to separate values. Each line of the file is a data record. Each record consists of one or more fields, separated by commas.
> 
> 

Load CSV data with a single row per document.


```
from langchain.document\_loaders.csv\_loader import CSVLoader  
  
  
loader = CSVLoader(file\_path='./example\_data/mlb\_teams\_2012.csv')  
data = loader.load()  

```

```
print(data)  

```

```
 [Document(page\_content='Team: Nationals\n""Payroll (millions)"": 81.34\n""Wins"": 98', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 0}, lookup\_index=0), Document(page\_content='Team: Reds\n""Payroll (millions)"": 82.20\n""Wins"": 97', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 1}, lookup\_index=0), Document(page\_content='Team: Yankees\n""Payroll (millions)"": 197.96\n""Wins"": 95', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 2}, lookup\_index=0), Document(page\_content='Team: Giants\n""Payroll (millions)"": 117.62\n""Wins"": 94', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 3}, lookup\_index=0), Document(page\_content='Team: Braves\n""Payroll (millions)"": 83.31\n""Wins"": 94', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 4}, lookup\_index=0), Document(page\_content='Team: Athletics\n""Payroll (millions)"": 55.37\n""Wins"": 94', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 5}, lookup\_index=0), Document(page\_content='Team: Rangers\n""Payroll (millions)"": 120.51\n""Wins"": 93', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 6}, lookup\_index=0), Document(page\_content='Team: Orioles\n""Payroll (millions)"": 81.43\n""Wins"": 93', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 7}, lookup\_index=0), Document(page\_content='Team: Rays\n""Payroll (millions)"": 64.17\n""Wins"": 90', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 8}, lookup\_index=0), Document(page\_content='Team: Angels\n""Payroll (millions)"": 154.49\n""Wins"": 89', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 9}, lookup\_index=0), Document(page\_content='Team: Tigers\n""Payroll (millions)"": 132.30\n""Wins"": 88', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 10}, lookup\_index=0), Document(page\_content='Team: Cardinals\n""Payroll (millions)"": 110.30\n""Wins"": 88', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 11}, lookup\_index=0), Document(page\_content='Team: Dodgers\n""Payroll (millions)"": 95.14\n""Wins"": 86', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 12}, lookup\_index=0), Document(page\_content='Team: White Sox\n""Payroll (millions)"": 96.92\n""Wins"": 85', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 13}, lookup\_index=0), Document(page\_content='Team: Brewers\n""Payroll (millions)"": 97.65\n""Wins"": 83', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 14}, lookup\_index=0), Document(page\_content='Team: Phillies\n""Payroll (millions)"": 174.54\n""Wins"": 81', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 15}, lookup\_index=0), Document(page\_content='Team: Diamondbacks\n""Payroll (millions)"": 74.28\n""Wins"": 81', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 16}, lookup\_index=0), Document(page\_content='Team: Pirates\n""Payroll (millions)"": 63.43\n""Wins"": 79', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 17}, lookup\_index=0), Document(page\_content='Team: Padres\n""Payroll (millions)"": 55.24\n""Wins"": 76', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 18}, lookup\_index=0), Document(page\_content='Team: Mariners\n""Payroll (millions)"": 81.97\n""Wins"": 75', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 19}, lookup\_index=0), Document(page\_content='Team: Mets\n""Payroll (millions)"": 93.35\n""Wins"": 74', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 20}, lookup\_index=0), Document(page\_content='Team: Blue Jays\n""Payroll (millions)"": 75.48\n""Wins"": 73', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 21}, lookup\_index=0), Document(page\_content='Team: Royals\n""Payroll (millions)"": 60.91\n""Wins"": 72', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 22}, lookup\_index=0), Document(page\_content='Team: Marlins\n""Payroll (millions)"": 118.07\n""Wins"": 69', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 23}, lookup\_index=0), Document(page\_content='Team: Red Sox\n""Payroll (millions)"": 173.18\n""Wins"": 69', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 24}, lookup\_index=0), Document(page\_content='Team: Indians\n""Payroll (millions)"": 78.43\n""Wins"": 68', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 25}, lookup\_index=0), Document(page\_content='Team: Twins\n""Payroll (millions)"": 94.08\n""Wins"": 66', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 26}, lookup\_index=0), Document(page\_content='Team: Rockies\n""Payroll (millions)"": 78.06\n""Wins"": 64', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 27}, lookup\_index=0), Document(page\_content='Team: Cubs\n""Payroll (millions)"": 88.19\n""Wins"": 61', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 28}, lookup\_index=0), Document(page\_content='Team: Astros\n""Payroll (millions)"": 60.65\n""Wins"": 55', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 29}, lookup\_index=0)]  

```
Customizing the csv parsing and loading[​](#customizing-the-csv-parsing-and-loading ""Direct link to Customizing the csv parsing and loading"")
---------------------------------------------------------------------------------------------------------------------------------------------

See the [csv module](https://docs.python.org/3/library/csv.html) documentation for more information of what csv args are supported.


```
loader = CSVLoader(file\_path='./example\_data/mlb\_teams\_2012.csv', csv\_args={  
 'delimiter': ',',  
 'quotechar': '""',  
 'fieldnames': ['MLB Team', 'Payroll in millions', 'Wins']  
})  
  
data = loader.load()  

```

```
print(data)  

```

```
 [Document(page\_content='MLB Team: Team\nPayroll in millions: ""Payroll (millions)""\nWins: ""Wins""', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 0}, lookup\_index=0), Document(page\_content='MLB Team: Nationals\nPayroll in millions: 81.34\nWins: 98', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 1}, lookup\_index=0), Document(page\_content='MLB Team: Reds\nPayroll in millions: 82.20\nWins: 97', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 2}, lookup\_index=0), Document(page\_content='MLB Team: Yankees\nPayroll in millions: 197.96\nWins: 95', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 3}, lookup\_index=0), Document(page\_content='MLB Team: Giants\nPayroll in millions: 117.62\nWins: 94', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 4}, lookup\_index=0), Document(page\_content='MLB Team: Braves\nPayroll in millions: 83.31\nWins: 94', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 5}, lookup\_index=0), Document(page\_content='MLB Team: Athletics\nPayroll in millions: 55.37\nWins: 94', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 6}, lookup\_index=0), Document(page\_content='MLB Team: Rangers\nPayroll in millions: 120.51\nWins: 93', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 7}, lookup\_index=0), Document(page\_content='MLB Team: Orioles\nPayroll in millions: 81.43\nWins: 93', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 8}, lookup\_index=0), Document(page\_content='MLB Team: Rays\nPayroll in millions: 64.17\nWins: 90', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 9}, lookup\_index=0), Document(page\_content='MLB Team: Angels\nPayroll in millions: 154.49\nWins: 89', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 10}, lookup\_index=0), Document(page\_content='MLB Team: Tigers\nPayroll in millions: 132.30\nWins: 88', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 11}, lookup\_index=0), Document(page\_content='MLB Team: Cardinals\nPayroll in millions: 110.30\nWins: 88', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 12}, lookup\_index=0), Document(page\_content='MLB Team: Dodgers\nPayroll in millions: 95.14\nWins: 86', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 13}, lookup\_index=0), Document(page\_content='MLB Team: White Sox\nPayroll in millions: 96.92\nWins: 85', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 14}, lookup\_index=0), Document(page\_content='MLB Team: Brewers\nPayroll in millions: 97.65\nWins: 83', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 15}, lookup\_index=0), Document(page\_content='MLB Team: Phillies\nPayroll in millions: 174.54\nWins: 81', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 16}, lookup\_index=0), Document(page\_content='MLB Team: Diamondbacks\nPayroll in millions: 74.28\nWins: 81', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 17}, lookup\_index=0), Document(page\_content='MLB Team: Pirates\nPayroll in millions: 63.43\nWins: 79', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 18}, lookup\_index=0), Document(page\_content='MLB Team: Padres\nPayroll in millions: 55.24\nWins: 76', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 19}, lookup\_index=0), Document(page\_content='MLB Team: Mariners\nPayroll in millions: 81.97\nWins: 75', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 20}, lookup\_index=0), Document(page\_content='MLB Team: Mets\nPayroll in millions: 93.35\nWins: 74', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 21}, lookup\_index=0), Document(page\_content='MLB Team: Blue Jays\nPayroll in millions: 75.48\nWins: 73', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 22}, lookup\_index=0), Document(page\_content='MLB Team: Royals\nPayroll in millions: 60.91\nWins: 72', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 23}, lookup\_index=0), Document(page\_content='MLB Team: Marlins\nPayroll in millions: 118.07\nWins: 69', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 24}, lookup\_index=0), Document(page\_content='MLB Team: Red Sox\nPayroll in millions: 173.18\nWins: 69', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 25}, lookup\_index=0), Document(page\_content='MLB Team: Indians\nPayroll in millions: 78.43\nWins: 68', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 26}, lookup\_index=0), Document(page\_content='MLB Team: Twins\nPayroll in millions: 94.08\nWins: 66', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 27}, lookup\_index=0), Document(page\_content='MLB Team: Rockies\nPayroll in millions: 78.06\nWins: 64', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 28}, lookup\_index=0), Document(page\_content='MLB Team: Cubs\nPayroll in millions: 88.19\nWins: 61', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 29}, lookup\_index=0), Document(page\_content='MLB Team: Astros\nPayroll in millions: 60.65\nWins: 55', lookup\_str='', metadata={'source': './example\_data/mlb\_teams\_2012.csv', 'row': 30}, lookup\_index=0)]  

```
Specify a column to identify the document source[​](#specify-a-column-to-identify-the-document-source ""Direct link to Specify a column to identify the document source"")
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Use the `source_column` argument to specify a source for the document created from each row. Otherwise `file_path` will be used as the source for all documents created from the CSV file.

This is useful when using documents loaded from CSV files for chains that answer questions using sources.


```
loader = CSVLoader(file\_path='./example\_data/mlb\_teams\_2012.csv', source\_column=""Team"")  
  
data = loader.load()  

```

```
print(data)  

```

```
 [Document(page\_content='Team: Nationals\n""Payroll (millions)"": 81.34\n""Wins"": 98', lookup\_str='', metadata={'source': 'Nationals', 'row': 0}, lookup\_index=0), Document(page\_content='Team: Reds\n""Payroll (millions)"": 82.20\n""Wins"": 97', lookup\_str='', metadata={'source': 'Reds', 'row': 1}, lookup\_index=0), Document(page\_content='Team: Yankees\n""Payroll (millions)"": 197.96\n""Wins"": 95', lookup\_str='', metadata={'source': 'Yankees', 'row': 2}, lookup\_index=0), Document(page\_content='Team: Giants\n""Payroll (millions)"": 117.62\n""Wins"": 94', lookup\_str='', metadata={'source': 'Giants', 'row': 3}, lookup\_index=0), Document(page\_content='Team: Braves\n""Payroll (millions)"": 83.31\n""Wins"": 94', lookup\_str='', metadata={'source': 'Braves', 'row': 4}, lookup\_index=0), Document(page\_content='Team: Athletics\n""Payroll (millions)"": 55.37\n""Wins"": 94', lookup\_str='', metadata={'source': 'Athletics', 'row': 5}, lookup\_index=0), Document(page\_content='Team: Rangers\n""Payroll (millions)"": 120.51\n""Wins"": 93', lookup\_str='', metadata={'source': 'Rangers', 'row': 6}, lookup\_index=0), Document(page\_content='Team: Orioles\n""Payroll (millions)"": 81.43\n""Wins"": 93', lookup\_str='', metadata={'source': 'Orioles', 'row': 7}, lookup\_index=0), Document(page\_content='Team: Rays\n""Payroll (millions)"": 64.17\n""Wins"": 90', lookup\_str='', metadata={'source': 'Rays', 'row': 8}, lookup\_index=0), Document(page\_content='Team: Angels\n""Payroll (millions)"": 154.49\n""Wins"": 89', lookup\_str='', metadata={'source': 'Angels', 'row': 9}, lookup\_index=0), Document(page\_content='Team: Tigers\n""Payroll (millions)"": 132.30\n""Wins"": 88', lookup\_str='', metadata={'source': 'Tigers', 'row': 10}, lookup\_index=0), Document(page\_content='Team: Cardinals\n""Payroll (millions)"": 110.30\n""Wins"": 88', lookup\_str='', metadata={'source': 'Cardinals', 'row': 11}, lookup\_index=0), Document(page\_content='Team: Dodgers\n""Payroll (millions)"": 95.14\n""Wins"": 86', lookup\_str='', metadata={'source': 'Dodgers', 'row': 12}, lookup\_index=0), Document(page\_content='Team: White Sox\n""Payroll (millions)"": 96.92\n""Wins"": 85', lookup\_str='', metadata={'source': 'White Sox', 'row': 13}, lookup\_index=0), Document(page\_content='Team: Brewers\n""Payroll (millions)"": 97.65\n""Wins"": 83', lookup\_str='', metadata={'source': 'Brewers', 'row': 14}, lookup\_index=0), Document(page\_content='Team: Phillies\n""Payroll (millions)"": 174.54\n""Wins"": 81', lookup\_str='', metadata={'source': 'Phillies', 'row': 15}, lookup\_index=0), Document(page\_content='Team: Diamondbacks\n""Payroll (millions)"": 74.28\n""Wins"": 81', lookup\_str='', metadata={'source': 'Diamondbacks', 'row': 16}, lookup\_index=0), Document(page\_content='Team: Pirates\n""Payroll (millions)"": 63.43\n""Wins"": 79', lookup\_str='', metadata={'source': 'Pirates', 'row': 17}, lookup\_index=0), Document(page\_content='Team: Padres\n""Payroll (millions)"": 55.24\n""Wins"": 76', lookup\_str='', metadata={'source': 'Padres', 'row': 18}, lookup\_index=0), Document(page\_content='Team: Mariners\n""Payroll (millions)"": 81.97\n""Wins"": 75', lookup\_str='', metadata={'source': 'Mariners', 'row': 19}, lookup\_index=0), Document(page\_content='Team: Mets\n""Payroll (millions)"": 93.35\n""Wins"": 74', lookup\_str='', metadata={'source': 'Mets', 'row': 20}, lookup\_index=0), Document(page\_content='Team: Blue Jays\n""Payroll (millions)"": 75.48\n""Wins"": 73', lookup\_str='', metadata={'source': 'Blue Jays', 'row': 21}, lookup\_index=0), Document(page\_content='Team: Royals\n""Payroll (millions)"": 60.91\n""Wins"": 72', lookup\_str='', metadata={'source': 'Royals', 'row': 22}, lookup\_index=0), Document(page\_content='Team: Marlins\n""Payroll (millions)"": 118.07\n""Wins"": 69', lookup\_str='', metadata={'source': 'Marlins', 'row': 23}, lookup\_index=0), Document(page\_content='Team: Red Sox\n""Payroll (millions)"": 173.18\n""Wins"": 69', lookup\_str='', metadata={'source': 'Red Sox', 'row': 24}, lookup\_index=0), Document(page\_content='Team: Indians\n""Payroll (millions)"": 78.43\n""Wins"": 68', lookup\_str='', metadata={'source': 'Indians', 'row': 25}, lookup\_index=0), Document(page\_content='Team: Twins\n""Payroll (millions)"": 94.08\n""Wins"": 66', lookup\_str='', metadata={'source': 'Twins', 'row': 26}, lookup\_index=0), Document(page\_content='Team: Rockies\n""Payroll (millions)"": 78.06\n""Wins"": 64', lookup\_str='', metadata={'source': 'Rockies', 'row': 27}, lookup\_index=0), Document(page\_content='Team: Cubs\n""Payroll (millions)"": 88.19\n""Wins"": 61', lookup\_str='', metadata={'source': 'Cubs', 'row': 28}, lookup\_index=0), Document(page\_content='Team: Astros\n""Payroll (millions)"": 60.65\n""Wins"": 55', lookup\_str='', metadata={'source': 'Astros', 'row': 29}, lookup\_index=0)]  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/document_loaders/file_directory,"File Directory
==============

This covers how to load all documents in a directory.

Under the hood, by default this uses the [UnstructuredLoader](/docs/integrations/document_loaders/unstructured_file.html)


```
from langchain.document\_loaders import DirectoryLoader  

```
We can use the `glob` parameter to control which files to load. Note that here it doesn't load the `.rst` file or the `.html` files.


```
loader = DirectoryLoader('../', glob=""\*\*/\*.md"")  

```

```
docs = loader.load()  

```

```
len(docs)  

```

```
 1  

```
Show a progress bar[​](#show-a-progress-bar ""Direct link to Show a progress bar"")
---------------------------------------------------------------------------------

By default a progress bar will not be shown. To show a progress bar, install the `tqdm` library (e.g. `pip install tqdm`), and set the `show_progress` parameter to `True`.


```
loader = DirectoryLoader('../', glob=""\*\*/\*.md"", show\_progress=True)  
docs = loader.load()  

```

```
 Requirement already satisfied: tqdm in /Users/jon/.pyenv/versions/3.9.16/envs/microbiome-app/lib/python3.9/site-packages (4.65.0)  
  
  
 0it [00:00, ?it/s]  

```
Use multithreading[​](#use-multithreading ""Direct link to Use multithreading"")
------------------------------------------------------------------------------

By default the loading happens in one thread. In order to utilize several threads set the `use_multithreading` flag to true.


```
loader = DirectoryLoader('../', glob=""\*\*/\*.md"", use\_multithreading=True)  
docs = loader.load()  

```
Change loader class[​](#change-loader-class ""Direct link to Change loader class"")
---------------------------------------------------------------------------------

By default this uses the `UnstructuredLoader` class. However, you can change up the type of loader pretty easily.


```
from langchain.document\_loaders import TextLoader  

```

```
loader = DirectoryLoader('../', glob=""\*\*/\*.md"", loader\_cls=TextLoader)  

```

```
docs = loader.load()  

```

```
len(docs)  

```

```
 1  

```
If you need to load Python source code files, use the `PythonLoader`.


```
from langchain.document\_loaders import PythonLoader  

```

```
loader = DirectoryLoader('../../../../../', glob=""\*\*/\*.py"", loader\_cls=PythonLoader)  

```

```
docs = loader.load()  

```

```
len(docs)  

```

```
 691  

```
Auto detect file encodings with TextLoader[​](#auto-detect-file-encodings-with-textloader ""Direct link to Auto detect file encodings with TextLoader"")
------------------------------------------------------------------------------------------------------------------------------------------------------

In this example we will see some strategies that can be useful when loading a big list of arbitrary files from a directory using the `TextLoader` class.

First to illustrate the problem, let's try to load multiple text with arbitrary encodings.


```
path = '../../../../../tests/integration\_tests/examples'  
loader = DirectoryLoader(path, glob=""\*\*/\*.txt"", loader\_cls=TextLoader)  

```
### A. Default Behavior[​](#a-default-behavior ""Direct link to A. Default Behavior"")


```
loader.load()  

```

```
<pre style=""white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace""><span style=""color: #800000; text-decoration-color: #800000"">╭─────────────────────────────── </span><span style=""color: #800000; text-decoration-color: #800000; font-weight: bold"">Traceback </span><span style=""color: #bf7f7f; text-decoration-color: #bf7f7f; font-weight: bold"">(most recent call last)</span><span style=""color: #800000; text-decoration-color: #800000""> ────────────────────────────────╮</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #bfbf7f; text-decoration-color: #bfbf7f"">/data/source/langchain/langchain/document\_loaders/</span><span style=""color: #808000; text-decoration-color: #808000; font-weight: bold"">text.py</span>:<span style=""color: #0000ff; text-decoration-color: #0000ff"">29</span> in <span style=""color: #00ff00; text-decoration-color: #00ff00"">load</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">26 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ </span>text = <span style=""color: #808000; text-decoration-color: #808000"">""""</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">27 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">with</span> <span style=""color: #00ffff; text-decoration-color: #00ffff"">open</span>(<span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.file\_path, encoding=<span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.encoding) <span style=""color: #0000ff; text-decoration-color: #0000ff"">as</span> f: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">28 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">try</span>: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">❱ </span>29 <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ </span>text = f.read() <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">30 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">except</span> <span style=""color: #00ffff; text-decoration-color: #00ffff"">UnicodeDecodeError</span> <span style=""color: #0000ff; text-decoration-color: #0000ff"">as</span> e: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">31 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">if</span> <span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.autodetect\_encoding: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">32 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ </span>detected\_encodings = <span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.detect\_file\_encodings() <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #bfbf7f; text-decoration-color: #bfbf7f"">/home/spike/.pyenv/versions/3.9.11/lib/python3.9/</span><span style=""color: #808000; text-decoration-color: #808000; font-weight: bold"">codecs.py</span>:<span style=""color: #0000ff; text-decoration-color: #0000ff"">322</span> in <span style=""color: #00ff00; text-decoration-color: #00ff00"">decode</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f""> 319 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">def</span> <span style=""color: #00ff00; text-decoration-color: #00ff00"">decode</span>(<span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>, <span style=""color: #00ffff; text-decoration-color: #00ffff"">input</span>, final=<span style=""color: #0000ff; text-decoration-color: #0000ff"">False</span>): <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f""> 320 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f""># decode input (taking the buffer into account)</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f""> 321 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ </span>data = <span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.buffer + <span style=""color: #00ffff; text-decoration-color: #00ffff"">input</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">❱ </span> 322 <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ </span>(result, consumed) = <span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.\_buffer\_decode(data, <span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.errors, final) <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f""> 323 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f""># keep undecoded input until the next call</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f""> 324 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ </span><span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.buffer = data[consumed:] <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f""> 325 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">return</span> result <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">╰──────────────────────────────────────────────────────────────────────────────────────────────────╯</span>  
<span style=""color: #ff0000; text-decoration-color: #ff0000; font-weight: bold"">UnicodeDecodeError: </span><span style=""color: #008000; text-decoration-color: #008000"">'utf-8'</span> codec can't decode byte <span style=""color: #008080; text-decoration-color: #008080; font-weight: bold"">0xca</span> in position <span style=""color: #008080; text-decoration-color: #008080; font-weight: bold"">0</span>: invalid continuation byte  
  
<span style=""font-style: italic"">The above exception was the direct cause of the following exception:</span>  
  
<span style=""color: #800000; text-decoration-color: #800000"">╭─────────────────────────────── </span><span style=""color: #800000; text-decoration-color: #800000; font-weight: bold"">Traceback </span><span style=""color: #bf7f7f; text-decoration-color: #bf7f7f; font-weight: bold"">(most recent call last)</span><span style=""color: #800000; text-decoration-color: #800000""> ────────────────────────────────╮</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> in <span style=""color: #00ff00; text-decoration-color: #00ff00"">&lt;module&gt;</span>:<span style=""color: #0000ff; text-decoration-color: #0000ff"">1</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">❱ </span>1 loader.load() <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">2 </span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #bfbf7f; text-decoration-color: #bfbf7f"">/data/source/langchain/langchain/document\_loaders/</span><span style=""color: #808000; text-decoration-color: #808000; font-weight: bold"">directory.py</span>:<span style=""color: #0000ff; text-decoration-color: #0000ff"">84</span> in <span style=""color: #00ff00; text-decoration-color: #00ff00"">load</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">81 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">if</span> <span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.silent\_errors: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">82 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ │ │ </span>logger.warning(e) <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">83 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">else</span>: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">❱ </span>84 <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">raise</span> e <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">85 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">finally</span>: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">86 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">if</span> pbar: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">87 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ │ │ </span>pbar.update(<span style=""color: #0000ff; text-decoration-color: #0000ff"">1</span>) <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #bfbf7f; text-decoration-color: #bfbf7f"">/data/source/langchain/langchain/document\_loaders/</span><span style=""color: #808000; text-decoration-color: #808000; font-weight: bold"">directory.py</span>:<span style=""color: #0000ff; text-decoration-color: #0000ff"">78</span> in <span style=""color: #00ff00; text-decoration-color: #00ff00"">load</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">75 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">if</span> i.is\_file(): <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">76 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">if</span> \_is\_visible(i.relative\_to(p)) <span style=""color: #ff00ff; text-decoration-color: #ff00ff"">or</span> <span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.load\_hidden: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">77 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">try</span>: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">❱ </span>78 <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ │ </span>sub\_docs = <span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.loader\_cls(<span style=""color: #00ffff; text-decoration-color: #00ffff"">str</span>(i), \*\*<span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.loader\_kwargs).load() <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">79 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ │ </span>docs.extend(sub\_docs) <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">80 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">except</span> <span style=""color: #00ffff; text-decoration-color: #00ffff"">Exception</span> <span style=""color: #0000ff; text-decoration-color: #0000ff"">as</span> e: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">81 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">if</span> <span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.silent\_errors: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #bfbf7f; text-decoration-color: #bfbf7f"">/data/source/langchain/langchain/document\_loaders/</span><span style=""color: #808000; text-decoration-color: #808000; font-weight: bold"">text.py</span>:<span style=""color: #0000ff; text-decoration-color: #0000ff"">44</span> in <span style=""color: #00ff00; text-decoration-color: #00ff00"">load</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">41 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">except</span> <span style=""color: #00ffff; text-decoration-color: #00ffff"">UnicodeDecodeError</span>: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">42 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">continue</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">43 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">else</span>: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #800000; text-decoration-color: #800000"">❱ </span>44 <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">raise</span> <span style=""color: #00ffff; text-decoration-color: #00ffff"">RuntimeError</span>(<span style=""color: #808000; text-decoration-color: #808000"">f""Error loading {</span><span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.file\_path<span style=""color: #808000; text-decoration-color: #808000"">}""</span>) <span style=""color: #0000ff; text-decoration-color: #0000ff"">from</span> <span style=""color: #00ffff; text-decoration-color: #00ffff; text-decoration: underline"">e</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">45 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">except</span> <span style=""color: #00ffff; text-decoration-color: #00ffff"">Exception</span> <span style=""color: #0000ff; text-decoration-color: #0000ff"">as</span> e: <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">46 </span><span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">│ │ │ │ </span><span style=""color: #0000ff; text-decoration-color: #0000ff"">raise</span> <span style=""color: #00ffff; text-decoration-color: #00ffff"">RuntimeError</span>(<span style=""color: #808000; text-decoration-color: #808000"">f""Error loading {</span><span style=""color: #00ffff; text-decoration-color: #00ffff"">self</span>.file\_path<span style=""color: #808000; text-decoration-color: #808000"">}""</span>) <span style=""color: #0000ff; text-decoration-color: #0000ff"">from</span> <span style=""color: #00ffff; text-decoration-color: #00ffff; text-decoration: underline"">e</span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">│</span> <span style=""color: #7f7f7f; text-decoration-color: #7f7f7f"">47 </span> <span style=""color: #800000; text-decoration-color: #800000"">│</span>  
<span style=""color: #800000; text-decoration-color: #800000"">╰──────────────────────────────────────────────────────────────────────────────────────────────────╯</span>  
<span style=""color: #ff0000; text-decoration-color: #ff0000; font-weight: bold"">RuntimeError: </span>Error loading ..<span style=""color: #800080; text-decoration-color: #800080"">/../../../../tests/integration\_tests/examples/</span><span style=""color: #ff00ff; text-decoration-color: #ff00ff"">example-non-utf8.txt</span>  
</pre>  

```
The file `example-non-utf8.txt` uses a different encoding the `load()` function fails with a helpful message indicating which file failed decoding. 

With the default behavior of `TextLoader` any failure to load any of the documents will fail the whole loading process and no documents are loaded. 

### B. Silent fail[​](#b-silent-fail ""Direct link to B. Silent fail"")

We can pass the parameter `silent_errors` to the `DirectoryLoader` to skip the files which could not be loaded and continue the load process.


```
loader = DirectoryLoader(path, glob=""\*\*/\*.txt"", loader\_cls=TextLoader, silent\_errors=True)  
docs = loader.load()  

```

```
 Error loading ../../../../../tests/integration\_tests/examples/example-non-utf8.txt  

```

```
doc\_sources = [doc.metadata['source'] for doc in docs]  
doc\_sources  

```

```
 ['../../../../../tests/integration\_tests/examples/whatsapp\_chat.txt',  
 '../../../../../tests/integration\_tests/examples/example-utf8.txt']  

```
### C. Auto detect encodings[​](#c-auto-detect-encodings ""Direct link to C. Auto detect encodings"")

We can also ask `TextLoader` to auto detect the file encoding before failing, by passing the `autodetect_encoding` to the loader class.


```
text\_loader\_kwargs={'autodetect\_encoding': True}  
loader = DirectoryLoader(path, glob=""\*\*/\*.txt"", loader\_cls=TextLoader, loader\_kwargs=text\_loader\_kwargs)  
docs = loader.load()  

```

```
doc\_sources = [doc.metadata['source'] for doc in docs]  
doc\_sources  

```

```
 ['../../../../../tests/integration\_tests/examples/example-non-utf8.txt',  
 '../../../../../tests/integration\_tests/examples/whatsapp\_chat.txt',  
 '../../../../../tests/integration\_tests/examples/example-utf8.txt']  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/document_loaders/html,"HTML
====


> [The HyperText Markup Language or HTML](https://en.wikipedia.org/wiki/HTML) is the standard markup language for documents designed to be displayed in a web browser.
> 
> 

This covers how to load `HTML` documents into a document format that we can use downstream.


```
from langchain.document\_loaders import UnstructuredHTMLLoader  

```

```
loader = UnstructuredHTMLLoader(""example\_data/fake-content.html"")  

```

```
data = loader.load()  

```

```
data  

```

```
 [Document(page\_content='My First Heading\n\nMy first paragraph.', lookup\_str='', metadata={'source': 'example\_data/fake-content.html'}, lookup\_index=0)]  

```
Loading HTML with BeautifulSoup4[​](#loading-html-with-beautifulsoup4 ""Direct link to Loading HTML with BeautifulSoup4"")
------------------------------------------------------------------------------------------------------------------------

We can also use `BeautifulSoup4` to load HTML documents using the `BSHTMLLoader`. This will extract the text from the HTML into `page_content`, and the page title as `title` into `metadata`.


```
from langchain.document\_loaders import BSHTMLLoader  

```

```
loader = BSHTMLLoader(""example\_data/fake-content.html"")  
data = loader.load()  
data  

```

```
 [Document(page\_content='\n\nTest Title\n\n\nMy First Heading\nMy first paragraph.\n\n\n', metadata={'source': 'example\_data/fake-content.html', 'title': 'Test Title'})]  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/document_loaders/,"Document loaders
================

infoHead to [Integrations](/docs/integrations/document_loaders/) for documentation on built-in document loader integrations with 3rd-party tools.

Use document loaders to load data from a source as `Document`'s. A `Document` is a piece of text
and associated metadata. For example, there are document loaders for loading a simple `.txt` file, for loading the text
contents of any web page, or even for loading a transcript of a YouTube video.

Document loaders expose a ""load"" method for loading data as documents from a configured source. They optionally
implement a ""lazy load"" as well for lazily loading data into memory.

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------

The simplest loader reads in a file as text and places it all into one Document.


```
from langchain.document\_loaders import TextLoader  
  
loader = TextLoader(""./index.md"")  
loader.load()  

```

```
[  
 Document(page\_content='---\nsidebar\_position: 0\n---\n# Document loaders\n\nUse document loaders to load data from a source as `Document`\'s. A `Document` is a piece of text\nand associated metadata. For example, there are document loaders for loading a simple `.txt` file, for loading the text\ncontents of any web page, or even for loading a transcript of a YouTube video.\n\nEvery document loader exposes two methods:\n1. ""Load"": load documents from the configured source\n2. ""Load and split"": load documents from the configured source and split them using the passed in text splitter\n\nThey optionally implement:\n\n3. ""Lazy load"": load documents into memory lazily\n', metadata={'source': '../docs/docs\_skeleton/docs/modules/data\_connection/document\_loaders/index.md'})  
]  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/document_loaders/json,"JSON
====


> [JSON (JavaScript Object Notation)](https://en.wikipedia.org/wiki/JSON) is an open standard file format and data interchange format that uses human-readable text to store and transmit data objects consisting of attribute–value pairs and arrays (or other serializable values).
> 
> 


> [JSON Lines](https://jsonlines.org/) is a file format where each line is a valid JSON value.
> 
> 


> The `JSONLoader` uses a specified [jq schema](https://en.wikipedia.org/wiki/Jq_(programming_language)) to parse the JSON files. It uses the `jq` python package.
> Check this [manual](https://stedolan.github.io/jq/manual/#Basicfilters) for a detailed documentation of the `jq` syntax.
> 
> 


```
#!pip install jq  

```

```
from langchain.document\_loaders import JSONLoader  

```

```
import json  
from pathlib import Path  
from pprint import pprint  
  
  
file\_path='./example\_data/facebook\_chat.json'  
data = json.loads(Path(file\_path).read\_text())  

```

```
pprint(data)  

```

```
 {'image': {'creation\_timestamp': 1675549016, 'uri': 'image\_of\_the\_chat.jpg'},  
 'is\_still\_participant': True,  
 'joinable\_mode': {'link': '', 'mode': 1},  
 'magic\_words': [],  
 'messages': [{'content': 'Bye!',  
 'sender\_name': 'User 2',  
 'timestamp\_ms': 1675597571851},  
 {'content': 'Oh no worries! Bye',  
 'sender\_name': 'User 1',  
 'timestamp\_ms': 1675597435669},  
 {'content': 'No Im sorry it was my mistake, the blue one is not '  
 'for sale',  
 'sender\_name': 'User 2',  
 'timestamp\_ms': 1675596277579},  
 {'content': 'I thought you were selling the blue one!',  
 'sender\_name': 'User 1',  
 'timestamp\_ms': 1675595140251},  
 {'content': 'Im not interested in this bag. Im interested in the '  
 'blue one!',  
 'sender\_name': 'User 1',  
 'timestamp\_ms': 1675595109305},  
 {'content': 'Here is $129',  
 'sender\_name': 'User 2',  
 'timestamp\_ms': 1675595068468},  
 {'photos': [{'creation\_timestamp': 1675595059,  
 'uri': 'url\_of\_some\_picture.jpg'}],  
 'sender\_name': 'User 2',  
 'timestamp\_ms': 1675595060730},  
 {'content': 'Online is at least $100',  
 'sender\_name': 'User 2',  
 'timestamp\_ms': 1675595045152},  
 {'content': 'How much do you want?',  
 'sender\_name': 'User 1',  
 'timestamp\_ms': 1675594799696},  
 {'content': 'Goodmorning! $50 is too low.',  
 'sender\_name': 'User 2',  
 'timestamp\_ms': 1675577876645},  
 {'content': 'Hi! Im interested in your bag. Im offering $50. Let '  
 'me know if you are interested. Thanks!',  
 'sender\_name': 'User 1',  
 'timestamp\_ms': 1675549022673}],  
 'participants': [{'name': 'User 1'}, {'name': 'User 2'}],  
 'thread\_path': 'inbox/User 1 and User 2 chat',  
 'title': 'User 1 and User 2 chat'}  

```
Using `JSONLoader`[​](#using-jsonloader ""Direct link to using-jsonloader"")
--------------------------------------------------------------------------

Suppose we are interested in extracting the values under the `content` field within the `messages` key of the JSON data. This can easily be done through the `JSONLoader` as shown below.

### JSON file[​](#json-file ""Direct link to JSON file"")


```
loader = JSONLoader(  
 file\_path='./example\_data/facebook\_chat.json',  
 jq\_schema='.messages[].content')  
  
data = loader.load()  

```

```
pprint(data)  

```

```
 [Document(page\_content='Bye!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 1}),  
 Document(page\_content='Oh no worries! Bye', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 2}),  
 Document(page\_content='No Im sorry it was my mistake, the blue one is not for sale', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 3}),  
 Document(page\_content='I thought you were selling the blue one!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 4}),  
 Document(page\_content='Im not interested in this bag. Im interested in the blue one!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 5}),  
 Document(page\_content='Here is $129', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 6}),  
 Document(page\_content='', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 7}),  
 Document(page\_content='Online is at least $100', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 8}),  
 Document(page\_content='How much do you want?', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 9}),  
 Document(page\_content='Goodmorning! $50 is too low.', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 10}),  
 Document(page\_content='Hi! Im interested in your bag. Im offering $50. Let me know if you are interested. Thanks!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 11})]  

```
### JSON Lines file[​](#json-lines-file ""Direct link to JSON Lines file"")

If you want to load documents from a JSON Lines file, you pass `json_lines=True`
and specify `jq_schema` to extract `page_content` from a single JSON object.


```
file\_path = './example\_data/facebook\_chat\_messages.jsonl'  
pprint(Path(file\_path).read\_text())  

```

```
 ('{""sender\_name"": ""User 2"", ""timestamp\_ms"": 1675597571851, ""content"": ""Bye!""}\n'  
 '{""sender\_name"": ""User 1"", ""timestamp\_ms"": 1675597435669, ""content"": ""Oh no '  
 'worries! Bye""}\n'  
 '{""sender\_name"": ""User 2"", ""timestamp\_ms"": 1675596277579, ""content"": ""No Im '  
 'sorry it was my mistake, the blue one is not for sale""}\n')  

```

```
loader = JSONLoader(  
 file\_path='./example\_data/facebook\_chat\_messages.jsonl',  
 jq\_schema='.content',  
 json\_lines=True)  
  
data = loader.load()  

```

```
pprint(data)  

```

```
 [Document(page\_content='Bye!', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat\_messages.jsonl', 'seq\_num': 1}),  
 Document(page\_content='Oh no worries! Bye', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat\_messages.jsonl', 'seq\_num': 2}),  
 Document(page\_content='No Im sorry it was my mistake, the blue one is not for sale', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat\_messages.jsonl', 'seq\_num': 3})]  

```
Another option is set `jq_schema='.'` and provide `content_key`:


```
loader = JSONLoader(  
 file\_path='./example\_data/facebook\_chat\_messages.jsonl',  
 jq\_schema='.',  
 content\_key='sender\_name',  
 json\_lines=True)  
  
data = loader.load()  

```

```
pprint(data)  

```

```
 [Document(page\_content='User 2', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat\_messages.jsonl', 'seq\_num': 1}),  
 Document(page\_content='User 1', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat\_messages.jsonl', 'seq\_num': 2}),  
 Document(page\_content='User 2', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat\_messages.jsonl', 'seq\_num': 3})]  

```
Extracting metadata[​](#extracting-metadata ""Direct link to Extracting metadata"")
---------------------------------------------------------------------------------

Generally, we want to include metadata available in the JSON file into the documents that we create from the content.

The following demonstrates how metadata can be extracted using the `JSONLoader`.

There are some key changes to be noted. In the previous example where we didn't collect the metadata, we managed to directly specify in the schema where the value for the `page_content` can be extracted from.


```
.messages[].content  

```
In the current example, we have to tell the loader to iterate over the records in the `messages` field. The jq\_schema then has to be:


```
.messages[]  

```
This allows us to pass the records (dict) into the `metadata_func` that has to be implemented. The `metadata_func` is responsible for identifying which pieces of information in the record should be included in the metadata stored in the final `Document` object.

Additionally, we now have to explicitly specify in the loader, via the `content_key` argument, the key from the record where the value for the `page_content` needs to be extracted from.


```
# Define the metadata extraction function.  
def metadata\_func(record: dict, metadata: dict) -> dict:  
  
 metadata[""sender\_name""] = record.get(""sender\_name"")  
 metadata[""timestamp\_ms""] = record.get(""timestamp\_ms"")  
  
 return metadata  
  
  
loader = JSONLoader(  
 file\_path='./example\_data/facebook\_chat.json',  
 jq\_schema='.messages[]',  
 content\_key=""content"",  
 metadata\_func=metadata\_func  
)  
  
data = loader.load()  

```

```
pprint(data)  

```

```
 [Document(page\_content='Bye!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 1, 'sender\_name': 'User 2', 'timestamp\_ms': 1675597571851}),  
 Document(page\_content='Oh no worries! Bye', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 2, 'sender\_name': 'User 1', 'timestamp\_ms': 1675597435669}),  
 Document(page\_content='No Im sorry it was my mistake, the blue one is not for sale', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 3, 'sender\_name': 'User 2', 'timestamp\_ms': 1675596277579}),  
 Document(page\_content='I thought you were selling the blue one!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 4, 'sender\_name': 'User 1', 'timestamp\_ms': 1675595140251}),  
 Document(page\_content='Im not interested in this bag. Im interested in the blue one!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 5, 'sender\_name': 'User 1', 'timestamp\_ms': 1675595109305}),  
 Document(page\_content='Here is $129', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 6, 'sender\_name': 'User 2', 'timestamp\_ms': 1675595068468}),  
 Document(page\_content='', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 7, 'sender\_name': 'User 2', 'timestamp\_ms': 1675595060730}),  
 Document(page\_content='Online is at least $100', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 8, 'sender\_name': 'User 2', 'timestamp\_ms': 1675595045152}),  
 Document(page\_content='How much do you want?', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 9, 'sender\_name': 'User 1', 'timestamp\_ms': 1675594799696}),  
 Document(page\_content='Goodmorning! $50 is too low.', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 10, 'sender\_name': 'User 2', 'timestamp\_ms': 1675577876645}),  
 Document(page\_content='Hi! Im interested in your bag. Im offering $50. Let me know if you are interested. Thanks!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 11, 'sender\_name': 'User 1', 'timestamp\_ms': 1675549022673})]  

```
Now, you will see that the documents contain the metadata associated with the content we extracted.

The `metadata_func`[​](#the-metadata_func ""Direct link to the-metadata_func"")
-----------------------------------------------------------------------------

As shown above, the `metadata_func` accepts the default metadata generated by the `JSONLoader`. This allows full control to the user with respect to how the metadata is formatted.

For example, the default metadata contains the `source` and the `seq_num` keys. However, it is possible that the JSON data contain these keys as well. The user can then exploit the `metadata_func` to rename the default keys and use the ones from the JSON data.

The example below shows how we can modify the `source` to only contain information of the file source relative to the `langchain` directory.


```
# Define the metadata extraction function.  
def metadata\_func(record: dict, metadata: dict) -> dict:  
  
 metadata[""sender\_name""] = record.get(""sender\_name"")  
 metadata[""timestamp\_ms""] = record.get(""timestamp\_ms"")  
  
 if ""source"" in metadata:  
 source = metadata[""source""].split(""/"")  
 source = source[source.index(""langchain""):]  
 metadata[""source""] = ""/"".join(source)  
  
 return metadata  
  
  
loader = JSONLoader(  
 file\_path='./example\_data/facebook\_chat.json',  
 jq\_schema='.messages[]',  
 content\_key=""content"",  
 metadata\_func=metadata\_func  
)  
  
data = loader.load()  

```

```
pprint(data)  

```

```
 [Document(page\_content='Bye!', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 1, 'sender\_name': 'User 2', 'timestamp\_ms': 1675597571851}),  
 Document(page\_content='Oh no worries! Bye', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 2, 'sender\_name': 'User 1', 'timestamp\_ms': 1675597435669}),  
 Document(page\_content='No Im sorry it was my mistake, the blue one is not for sale', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 3, 'sender\_name': 'User 2', 'timestamp\_ms': 1675596277579}),  
 Document(page\_content='I thought you were selling the blue one!', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 4, 'sender\_name': 'User 1', 'timestamp\_ms': 1675595140251}),  
 Document(page\_content='Im not interested in this bag. Im interested in the blue one!', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 5, 'sender\_name': 'User 1', 'timestamp\_ms': 1675595109305}),  
 Document(page\_content='Here is $129', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 6, 'sender\_name': 'User 2', 'timestamp\_ms': 1675595068468}),  
 Document(page\_content='', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 7, 'sender\_name': 'User 2', 'timestamp\_ms': 1675595060730}),  
 Document(page\_content='Online is at least $100', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 8, 'sender\_name': 'User 2', 'timestamp\_ms': 1675595045152}),  
 Document(page\_content='How much do you want?', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 9, 'sender\_name': 'User 1', 'timestamp\_ms': 1675594799696}),  
 Document(page\_content='Goodmorning! $50 is too low.', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 10, 'sender\_name': 'User 2', 'timestamp\_ms': 1675577876645}),  
 Document(page\_content='Hi! Im interested in your bag. Im offering $50. Let me know if you are interested. Thanks!', metadata={'source': 'langchain/docs/modules/indexes/document\_loaders/examples/example\_data/facebook\_chat.json', 'seq\_num': 11, 'sender\_name': 'User 1', 'timestamp\_ms': 1675549022673})]  

```
Common JSON structures with jq schema[​](#common-json-structures-with-jq-schema ""Direct link to Common JSON structures with jq schema"")
---------------------------------------------------------------------------------------------------------------------------------------

The list below provides a reference to the possible `jq_schema` the user can use to extract content from the JSON data depending on the structure.


```
JSON -> [{""text"": ...}, {""text"": ...}, {""text"": ...}]  
jq\_schema -> "".[].text""  
  
JSON -> {""key"": [{""text"": ...}, {""text"": ...}, {""text"": ...}]}  
jq\_schema -> "".key[].text""  
  
JSON -> [""..."", ""..."", ""...""]  
jq\_schema -> "".[]""  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/document_loaders/markdown,"Markdown
========


> [Markdown](https://en.wikipedia.org/wiki/Markdown) is a lightweight markup language for creating formatted text using a plain-text editor.
> 
> 

This covers how to load `Markdown` documents into a document format that we can use downstream.


```
# !pip install unstructured > /dev/null  

```

```
from langchain.document\_loaders import UnstructuredMarkdownLoader  

```

```
markdown\_path = ""../../../../../README.md""  
loader = UnstructuredMarkdownLoader(markdown\_path)  

```

```
data = loader.load()  

```

```
data  

```

```
 [Document(page\_content=""ð\x9f¦\x9cï¸\x8fð\x9f”\x97 LangChain\n\nâ\x9a¡ Building applications with LLMs through composability â\x9a¡\n\nLooking for the JS/TS version? Check out LangChain.js.\n\nProduction Support: As you move your LangChains into production, we'd love to offer more comprehensive support.\nPlease fill out this form and we'll set up a dedicated support Slack channel.\n\nQuick Install\n\npip install langchain\nor\nconda install langchain -c conda-forge\n\nð\x9f¤” What is this?\n\nLarge language models (LLMs) are emerging as a transformative technology, enabling developers to build applications that they previously could not. However, using these LLMs in isolation is often insufficient for creating a truly powerful app - the real power comes when you can combine them with other sources of computation or knowledge.\n\nThis library aims to assist in the development of those types of applications. Common examples of these applications include:\n\nâ\x9d“ Question Answering over specific documents\n\nDocumentation\n\nEnd-to-end Example: Question Answering over Notion Database\n\nð\x9f’¬ Chatbots\n\nDocumentation\n\nEnd-to-end Example: Chat-LangChain\n\nð\x9f¤\x96 Agents\n\nDocumentation\n\nEnd-to-end Example: GPT+WolframAlpha\n\nð\x9f“\x96 Documentation\n\nPlease see here for full documentation on:\n\nGetting started (installation, setting up the environment, simple examples)\n\nHow-To examples (demos, integrations, helper functions)\n\nReference (full API docs)\n\nResources (high-level explanation of core concepts)\n\nð\x9f\x9a\x80 What can this help with?\n\nThere are six main areas that LangChain is designed to help with.\nThese are, in increasing order of complexity:\n\nð\x9f“\x83 LLMs and Prompts:\n\nThis includes prompt management, prompt optimization, a generic interface for all LLMs, and common utilities for working with LLMs.\n\nð\x9f”\x97 Chains:\n\nChains go beyond a single LLM call and involve sequences of calls (whether to an LLM or a different utility). LangChain provides a standard interface for chains, lots of integrations with other tools, and end-to-end chains for common applications.\n\nð\x9f“\x9a Data Augmented Generation:\n\nData Augmented Generation involves specific types of chains that first interact with an external data source to fetch data for use in the generation step. Examples include summarization of long pieces of text and question/answering over specific data sources.\n\nð\x9f¤\x96 Agents:\n\nAgents involve an LLM making decisions about which Actions to take, taking that Action, seeing an Observation, and repeating that until done. LangChain provides a standard interface for agents, a selection of agents to choose from, and examples of end-to-end agents.\n\nð\x9f§\xa0 Memory:\n\nMemory refers to persisting state between calls of a chain/agent. LangChain provides a standard interface for memory, a collection of memory implementations, and examples of chains/agents that use memory.\n\nð\x9f§\x90 Evaluation:\n\n[BETA] Generative models are notoriously hard to evaluate with traditional metrics. One new way of evaluating them is using language models themselves to do the evaluation. LangChain provides some prompts/chains for assisting in this.\n\nFor more information on these concepts, please see our full documentation.\n\nð\x9f’\x81 Contributing\n\nAs an open-source project in a rapidly developing field, we are extremely open to contributions, whether it be in the form of a new feature, improved infrastructure, or better documentation.\n\nFor detailed information on how to contribute, see here."", metadata={'source': '../../../../../README.md'})]  

```
Retain Elements[​](#retain-elements ""Direct link to Retain Elements"")
---------------------------------------------------------------------

Under the hood, Unstructured creates different ""elements"" for different chunks of text. By default we combine those together, but you can easily keep that separation by specifying `mode=""elements""`.


```
loader = UnstructuredMarkdownLoader(markdown\_path, mode=""elements"")  

```

```
data = loader.load()  

```

```
data[0]  

```

```
 Document(page\_content='ð\x9f¦\x9cï¸\x8fð\x9f”\x97 LangChain', metadata={'source': '../../../../../README.md', 'page\_number': 1, 'category': 'Title'})  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/document_loaders/pdf,"PDF
===


> [Portable Document Format (PDF)](https://en.wikipedia.org/wiki/PDF), standardized as ISO 32000, is a file format developed by Adobe in 1992 to present documents, including text formatting and images, in a manner independent of application software, hardware, and operating systems.
> 
> 

This covers how to load `PDF` documents into the Document format that we use downstream.

Using PyPDF[​](#using-pypdf ""Direct link to Using PyPDF"")
---------------------------------------------------------

Load PDF using `pypdf` into array of documents, where each document contains the page content and metadata with `page` number.


```
pip install pypdf  

```

```
from langchain.document\_loaders import PyPDFLoader  
  
loader = PyPDFLoader(""example\_data/layout-parser-paper.pdf"")  
pages = loader.load\_and\_split()  

```

```
pages[0]  

```

```
 Document(page\_content='LayoutParser : A Uni\x0ced Toolkit for Deep\nLearning Based Document Image Analysis\nZejiang Shen1( \x00), Ruochen Zhang2, Melissa Dell3, Benjamin Charles Germain\nLee4, Jacob Carlson3, and Weining Li5\n1Allen Institute for AI\nshannons@allenai.org\n2Brown University\nruochen zhang@brown.edu\n3Harvard University\nfmelissadell,jacob carlson g@fas.harvard.edu\n4University of Washington\nbcgl@cs.washington.edu\n5University of Waterloo\nw422li@uwaterloo.ca\nAbstract. Recent advances in document image analysis (DIA) have been\nprimarily driven by the application of neural networks. Ideally, research\noutcomes could be easily deployed in production and extended for further\ninvestigation. However, various factors like loosely organized codebases\nand sophisticated model con\x0cgurations complicate the easy reuse of im-\nportant innovations by a wide audience. Though there have been on-going\ne\x0borts to improve reusability and simplify deep learning (DL) model\ndevelopment in disciplines like natural language processing and computer\nvision, none of them are optimized for challenges in the domain of DIA.\nThis represents a major gap in the existing toolkit, as DIA is central to\nacademic research across a wide range of disciplines in the social sciences\nand humanities. This paper introduces LayoutParser , an open-source\nlibrary for streamlining the usage of DL in DIA research and applica-\ntions. The core LayoutParser library comes with a set of simple and\nintuitive interfaces for applying and customizing DL models for layout de-\ntection, character recognition, and many other document processing tasks.\nTo promote extensibility, LayoutParser also incorporates a community\nplatform for sharing both pre-trained models and full document digiti-\nzation pipelines. We demonstrate that LayoutParser is helpful for both\nlightweight and large-scale digitization pipelines in real-word use cases.\nThe library is publicly available at https://layout-parser.github.io .\nKeywords: Document Image Analysis ·Deep Learning ·Layout Analysis\n·Character Recognition ·Open Source library ·Toolkit.\n1 Introduction\nDeep Learning(DL)-based approaches are the state-of-the-art for a wide range of\ndocument image analysis (DIA) tasks including document image classi\x0ccation [ 11,arXiv:2103.15348v2 [cs.CV] 21 Jun 2021', metadata={'source': 'example\_data/layout-parser-paper.pdf', 'page': 0})  

```
An advantage of this approach is that documents can be retrieved with page numbers.

We want to use `OpenAIEmbeddings` so we have to get the OpenAI API Key.


```
import os  
import getpass  
  
os.environ['OPENAI\_API\_KEY'] = getpass.getpass('OpenAI API Key:')  

```

```
 OpenAI API Key: ········  

```

```
from langchain.vectorstores import FAISS  
from langchain.embeddings.openai import OpenAIEmbeddings  
  
faiss\_index = FAISS.from\_documents(pages, OpenAIEmbeddings())  
docs = faiss\_index.similarity\_search(""How will the community be engaged?"", k=2)  
for doc in docs:  
 print(str(doc.metadata[""page""]) + "":"", doc.page\_content[:300])  

```

```
 9: 10 Z. Shen et al.  
 Fig. 4: Illustration of (a) the original historical Japanese document with layout  
 detection results and (b) a recreated version of the document image that achieves  
 much better character recognition recall. The reorganization algorithm rearranges  
 the tokens based on the their detect  
 3: 4 Z. Shen et al.  
 Efficient Data AnnotationC u s t o m i z e d M o d e l T r a i n i n gModel Cust omizationDI A Model HubDI A Pipeline SharingCommunity PlatformLa y out Detection ModelsDocument Images   
 T h e C o r e L a y o u t P a r s e r L i b r a r yOCR ModuleSt or age & VisualizationLa y ou  

```
Using MathPix[​](#using-mathpix ""Direct link to Using MathPix"")
---------------------------------------------------------------

Inspired by Daniel Gross's <https://gist.github.com/danielgross/3ab4104e14faccc12b49200843adab21>


```
from langchain.document\_loaders import MathpixPDFLoader  

```

```
loader = MathpixPDFLoader(""example\_data/layout-parser-paper.pdf"")  

```

```
data = loader.load()  

```
Using Unstructured[​](#using-unstructured ""Direct link to Using Unstructured"")
------------------------------------------------------------------------------


```
from langchain.document\_loaders import UnstructuredPDFLoader  

```

```
loader = UnstructuredPDFLoader(""example\_data/layout-parser-paper.pdf"")  

```

```
data = loader.load()  

```
### Retain Elements[​](#retain-elements ""Direct link to Retain Elements"")

Under the hood, Unstructured creates different ""elements"" for different chunks of text. By default we combine those together, but you can easily keep that separation by specifying `mode=""elements""`.


```
loader = UnstructuredPDFLoader(""example\_data/layout-parser-paper.pdf"", mode=""elements"")  

```

```
data = loader.load()  

```

```
data[0]  

```

```
 Document(page\_content='LayoutParser: A Uniﬁed Toolkit for Deep\nLearning Based Document Image Analysis\nZejiang Shen1 (�), Ruochen Zhang2, Melissa Dell3, Benjamin Charles Germain\nLee4, Jacob Carlson3, and Weining Li5\n1 Allen Institute for AI\nshannons@allenai.org\n2 Brown University\nruochen zhang@brown.edu\n3 Harvard University\n{melissadell,jacob carlson}@fas.harvard.edu\n4 University of Washington\nbcgl@cs.washington.edu\n5 University of Waterloo\nw422li@uwaterloo.ca\nAbstract. Recent advances in document image analysis (DIA) have been\nprimarily driven by the application of neural networks. Ideally, research\noutcomes could be easily deployed in production and extended for further\ninvestigation. However, various factors like loosely organized codebases\nand sophisticated model conﬁgurations complicate the easy reuse of im-\nportant innovations by a wide audience. Though there have been on-going\neﬀorts to improve reusability and simplify deep learning (DL) model\ndevelopment in disciplines like natural language processing and computer\nvision, none of them are optimized for challenges in the domain of DIA.\nThis represents a major gap in the existing toolkit, as DIA is central to\nacademic research across a wide range of disciplines in the social sciences\nand humanities. This paper introduces LayoutParser, an open-source\nlibrary for streamlining the usage of DL in DIA research and applica-\ntions. The core LayoutParser library comes with a set of simple and\nintuitive interfaces for applying and customizing DL models for layout de-\ntection, character recognition, and many other document processing tasks.\nTo promote extensibility, LayoutParser also incorporates a community\nplatform for sharing both pre-trained models and full document digiti-\nzation pipelines. We demonstrate that LayoutParser is helpful for both\nlightweight and large-scale digitization pipelines in real-word use cases.\nThe library is publicly available at https://layout-parser.github.io.\nKeywords: Document Image Analysis · Deep Learning · Layout Analysis\n· Character Recognition · Open Source library · Toolkit.\n1\nIntroduction\nDeep Learning(DL)-based approaches are the state-of-the-art for a wide range of\ndocument image analysis (DIA) tasks including document image classiﬁcation [11,\narXiv:2103.15348v2 [cs.CV] 21 Jun 2021\n', lookup\_str='', metadata={'file\_path': 'example\_data/layout-parser-paper.pdf', 'page\_number': 1, 'total\_pages': 16, 'format': 'PDF 1.5', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'LaTeX with hyperref', 'producer': 'pdfTeX-1.40.21', 'creationDate': 'D:20210622012710Z', 'modDate': 'D:20210622012710Z', 'trapped': '', 'encryption': None}, lookup\_index=0)  

```
### Fetching remote PDFs using Unstructured[​](#fetching-remote-pdfs-using-unstructured ""Direct link to Fetching remote PDFs using Unstructured"")

This covers how to load online pdfs into a document format that we can use downstream. This can be used for various online pdf sites such as <https://open.umn.edu/opentextbooks/textbooks/> and <https://arxiv.org/archive/>

Note: all other pdf loaders can also be used to fetch remote PDFs, but `OnlinePDFLoader` is a legacy function, and works specifically with `UnstructuredPDFLoader`.


```
from langchain.document\_loaders import OnlinePDFLoader  

```

```
loader = OnlinePDFLoader(""https://arxiv.org/pdf/2302.03803.pdf"")  

```

```
data = loader.load()  

```

```
print(data)  

```

```
 [Document(page\_content='A WEAK ( k, k ) -LEFSCHETZ THEOREM FOR PROJECTIVE TORIC ORBIFOLDS\n\nWilliam D. Montoya\n\nInstituto de Matem´atica, Estat´ıstica e Computa¸c˜ao Cient´ıﬁca,\n\nIn [3] we proved that, under suitable conditions, on a very general codimension s quasi- smooth intersection subvariety X in a projective toric orbifold P d Σ with d + s = 2 ( k + 1 ) the Hodge conjecture holds, that is, every ( p, p ) -cohomology class, under the Poincar´e duality is a rational linear combination of fundamental classes of algebraic subvarieties of X . The proof of the above-mentioned result relies, for p ≠ d + 1 − s , on a Lefschetz\n\nKeywords: (1,1)- Lefschetz theorem, Hodge conjecture, toric varieties, complete intersection Email: wmontoya@ime.unicamp.br\n\ntheorem ([7]) and the Hard Lefschetz theorem for projective orbifolds ([11]). When p = d + 1 − s the proof relies on the Cayley trick, a trick which associates to X a quasi-smooth hypersurface Y in a projective vector bundle, and the Cayley Proposition (4.3) which gives an isomorphism of some primitive cohomologies (4.2) of X and Y . The Cayley trick, following the philosophy of Mavlyutov in [7], reduces results known for quasi-smooth hypersurfaces to quasi-smooth intersection subvarieties. The idea in this paper goes the other way around, we translate some results for quasi-smooth intersection subvarieties to\n\nAcknowledgement. I thank Prof. Ugo Bruzzo and Tiago Fonseca for useful discus- sions. I also acknowledge support from FAPESP postdoctoral grant No. 2019/23499-7.\n\nLet M be a free abelian group of rank d , let N = Hom ( M, Z ) , and N R = N ⊗ Z R .\n\nif there exist k linearly independent primitive elements e\n\n, . . . , e k ∈ N such that σ = { µ\n\ne\n\n+ ⋯ + µ k e k } . • The generators e i are integral if for every i and any nonnegative rational number µ the product µe i is in N only if µ is an integer. • Given two rational simplicial cones σ , σ ′ one says that σ ′ is a face of σ ( σ ′ < σ ) if the set of integral generators of σ ′ is a subset of the set of integral generators of σ . • A ﬁnite set Σ = { σ\n\n, . . . , σ t } of rational simplicial cones is called a rational simplicial complete d -dimensional fan if:\n\nall faces of cones in Σ are in Σ ;\n\nif σ, σ ′ ∈ Σ then σ ∩ σ ′ < σ and σ ∩ σ ′ < σ ′ ;\n\nN R = σ\n\n∪ ⋅ ⋅ ⋅ ∪ σ t .\n\nA rational simplicial complete d -dimensional fan Σ deﬁnes a d -dimensional toric variety P d Σ having only orbifold singularities which we assume to be projective. Moreover, T ∶ = N ⊗ Z C ∗ ≃ ( C ∗ ) d is the torus action on P d Σ . We denote by Σ ( i ) the i -dimensional cones\n\nFor a cone σ ∈ Σ, ˆ σ is the set of 1-dimensional cone in Σ that are not contained in σ\n\nand x ˆ σ ∶ = ∏ ρ ∈ ˆ σ x ρ is the associated monomial in S .\n\nDeﬁnition 2.2. The irrelevant ideal of P d Σ is the monomial ideal B Σ ∶ =< x ˆ σ ∣ σ ∈ Σ > and the zero locus Z ( Σ ) ∶ = V ( B Σ ) in the aﬃne space A d ∶ = Spec ( S ) is the irrelevant locus.\n\nProposition 2.3 (Theorem 5.1.11 [5]) . The toric variety P d Σ is a categorical quotient A d ∖ Z ( Σ ) by the group Hom ( Cl ( Σ ) , C ∗ ) and the group action is induced by the Cl ( Σ ) - grading of S .\n\nNow we give a brief introduction to complex orbifolds and we mention the needed theorems for the next section. Namely: de Rham theorem and Dolbeault theorem for complex orbifolds.\n\nDeﬁnition 2.4. A complex orbifold of complex dimension d is a singular complex space whose singularities are locally isomorphic to quotient singularities C d / G , for ﬁnite sub- groups G ⊂ Gl ( d, C ) .\n\nDeﬁnition 2.5. A diﬀerential form on a complex orbifold Z is deﬁned locally at z ∈ Z as a G -invariant diﬀerential form on C d where G ⊂ Gl ( d, C ) and Z is locally isomorphic to d\n\nRoughly speaking the local geometry of orbifolds reduces to local G -invariant geometry.\n\nWe have a complex of diﬀerential forms ( A ● ( Z ) , d ) and a double complex ( A ● , ● ( Z ) , ∂, ¯ ∂ ) of bigraded diﬀerential forms which deﬁne the de Rham and the Dolbeault cohomology groups (for a ﬁxed p ∈ N ) respectively:\n\n(1,1)-Lefschetz theorem for projective toric orbifolds\n\nDeﬁnition 3.1. A subvariety X ⊂ P d Σ is quasi-smooth if V ( I X ) ⊂ A #Σ ( 1 ) is smooth outside\n\nExample 3.2 . Quasi-smooth hypersurfaces or more generally quasi-smooth intersection sub-\n\nExample 3.2 . Quasi-smooth hypersurfaces or more generally quasi-smooth intersection sub- varieties are quasi-smooth subvarieties (see [2] or [7] for more details).\n\nRemark 3.3 . Quasi-smooth subvarieties are suborbifolds of P d Σ in the sense of Satake in [8]. Intuitively speaking they are subvarieties whose only singularities come from the ambient\n\nProof. From the exponential short exact sequence\n\nwe have a long exact sequence in cohomology\n\nH 1 (O ∗ X ) → H 2 ( X, Z ) → H 2 (O X ) ≃ H 0 , 2 ( X )\n\nwhere the last isomorphisms is due to Steenbrink in [9]. Now, it is enough to prove the commutativity of the next diagram\n\nwhere the last isomorphisms is due to Steenbrink in [9]. Now,\n\nH 2 ( X, Z ) / / H 2 ( X, O X ) ≃ Dolbeault H 2 ( X, C ) deRham ≃ H 2 dR ( X, C ) / / H 0 , 2 ¯ ∂ ( X )\n\nof the proof follows as the ( 1 , 1 ) -Lefschetz theorem in [6].\n\nRemark 3.5 . For k = 1 and P d Σ as the projective space, we recover the classical ( 1 , 1 ) - Lefschetz theorem.\n\nBy the Hard Lefschetz Theorem for projective orbifolds (see [11] for details) we\n\nBy the Hard Lefschetz Theorem for projective orbifolds (see [11] for details) we get an isomorphism of cohomologies :\n\ngiven by the Lefschetz morphism and since it is a morphism of Hodge structures, we have:\n\nH 1 , 1 ( X, Q ) ≃ H dim X − 1 , dim X − 1 ( X, Q )\n\nCorollary 3.6. If the dimension of X is 1 , 2 or 3 . The Hodge conjecture holds on X\n\nProof. If the dim C X = 1 the result is clear by the Hard Lefschetz theorem for projective orbifolds. The dimension 2 and 3 cases are covered by Theorem 3.5 and the Hard Lefschetz.\n\nCayley trick and Cayley proposition\n\nThe Cayley trick is a way to associate to a quasi-smooth intersection subvariety a quasi- smooth hypersurface. Let L 1 , . . . , L s be line bundles on P d Σ and let π ∶ P ( E ) → P d Σ be the projective space bundle associated to the vector bundle E = L 1 ⊕ ⋯ ⊕ L s . It is known that P ( E ) is a ( d + s − 1 ) -dimensional simplicial toric variety whose fan depends on the degrees of the line bundles and the fan Σ. Furthermore, if the Cox ring, without considering the grading, of P d Σ is C [ x 1 , . . . , x m ] then the Cox ring of P ( E ) is\n\nMoreover for X a quasi-smooth intersection subvariety cut oﬀ by f 1 , . . . , f s with deg ( f i ) = [ L i ] we relate the hypersurface Y cut oﬀ by F = y 1 f 1 + ⋅ ⋅ ⋅ + y s f s which turns out to be quasi-smooth. For more details see Section 2 in [7].\n\nWe will denote P ( E ) as P d + s − 1 Σ ,X to keep track of its relation with X and P d Σ .\n\nThe following is a key remark.\n\nRemark 4.1 . There is a morphism ι ∶ X → Y ⊂ P d + s − 1 Σ ,X . Moreover every point z ∶ = ( x, y ) ∈ Y with y ≠ 0 has a preimage. Hence for any subvariety W = V ( I W ) ⊂ X ⊂ P d Σ there exists W ′ ⊂ Y ⊂ P d + s − 1 Σ ,X such that π ( W ′ ) = W , i.e., W ′ = { z = ( x, y ) ∣ x ∈ W } .\n\nFor X ⊂ P d Σ a quasi-smooth intersection variety the morphism in cohomology induced by the inclusion i ∗ ∶ H d − s ( P d Σ , C ) → H d − s ( X, C ) is injective by Proposition 1.4 in [7].\n\nDeﬁnition 4.2. The primitive cohomology of H d − s prim ( X ) is the quotient H d − s ( X, C )/ i ∗ ( H d − s ( P d Σ , C )) and H d − s prim ( X, Q ) with rational coeﬃcients.\n\nH d − s ( P d Σ , C ) and H d − s ( X, C ) have pure Hodge structures, and the morphism i ∗ is com- patible with them, so that H d − s prim ( X ) gets a pure Hodge structure.\n\nThe next Proposition is the Cayley proposition.\n\nProposition 4.3. [Proposition 2.3 in [3] ] Let X = X 1 ∩⋅ ⋅ ⋅∩ X s be a quasi-smooth intersec- tion subvariety in P d Σ cut oﬀ by homogeneous polynomials f 1 . . . f s . Then for p ≠ d + s − 1 2 , d + s − 3 2\n\nRemark 4.5 . The above isomorphisms are also true with rational coeﬃcients since H ● ( X, C ) = H ● ( X, Q ) ⊗ Q C . See the beginning of Section 7.1 in [10] for more details.\n\nTheorem 5.1. Let Y = { F = y 1 f 1 + ⋯ + y k f k = 0 } ⊂ P 2 k + 1 Σ ,X be the quasi-smooth hypersurface associated to the quasi-smooth intersection surface X = X f 1 ∩ ⋅ ⋅ ⋅ ∩ X f k ⊂ P k + 2 Σ . Then on Y the Hodge conjecture holds.\n\nthe Hodge conjecture holds.\n\nProof. If H k,k prim ( X, Q ) = 0 we are done. So let us assume H k,k prim ( X, Q ) ≠ 0. By the Cayley proposition H k,k prim ( Y, Q ) ≃ H 1 , 1 prim ( X, Q ) and by the ( 1 , 1 ) -Lefschetz theorem for projective\n\ntoric orbifolds there is a non-zero algebraic basis λ C 1 , . . . , λ C n with rational coeﬃcients of H 1 , 1 prim ( X, Q ) , that is, there are n ∶ = h 1 , 1 prim ( X, Q ) algebraic curves C 1 , . . . , C n in X such that under the Poincar´e duality the class in homology [ C i ] goes to λ C i , [ C i ] ↦ λ C i . Recall that the Cox ring of P k + 2 is contained in the Cox ring of P 2 k + 1 Σ ,X without considering the grading. Considering the grading we have that if α ∈ Cl ( P k + 2 Σ ) then ( α, 0 ) ∈ Cl ( P 2 k + 1 Σ ,X ) . So the polynomials deﬁning C i ⊂ P k + 2 Σ can be interpreted in P 2 k + 1 X, Σ but with diﬀerent degree. Moreover, by Remark 4.1 each C i is contained in Y = { F = y 1 f 1 + ⋯ + y k f k = 0 } and\n\nfurthermore it has codimension k .\n\nClaim: { C i } ni = 1 is a basis of prim ( ) . It is enough to prove that λ C i is diﬀerent from zero in H k,k prim ( Y, Q ) or equivalently that the cohomology classes { λ C i } ni = 1 do not come from the ambient space. By contradiction, let us assume that there exists a j and C ⊂ P 2 k + 1 Σ ,X such that λ C ∈ H k,k ( P 2 k + 1 Σ ,X , Q ) with i ∗ ( λ C ) = λ C j or in terms of homology there exists a ( k + 2 ) -dimensional algebraic subvariety V ⊂ P 2 k + 1 Σ ,X such that V ∩ Y = C j so they are equal as a homology class of P 2 k + 1 Σ ,X ,i.e., [ V ∩ Y ] = [ C j ] . It is easy to check that π ( V ) ∩ X = C j as a subvariety of P k + 2 Σ where π ∶ ( x, y ) ↦ x . Hence [ π ( V ) ∩ X ] = [ C j ] which is equivalent to say that λ C j comes from P k + 2 Σ which contradicts the choice of [ C j ] .\n\nRemark 5.2 . Into the proof of the previous theorem, the key fact was that on X the Hodge conjecture holds and we translate it to Y by contradiction. So, using an analogous argument we have:\n\nargument we have:\n\nProposition 5.3. Let Y = { F = y 1 f s +⋯+ y s f s = 0 } ⊂ P 2 k + 1 Σ ,X be the quasi-smooth hypersurface associated to a quasi-smooth intersection subvariety X = X f 1 ∩ ⋅ ⋅ ⋅ ∩ X f s ⊂ P d Σ such that d + s = 2 ( k + 1 ) . If the Hodge conjecture holds on X then it holds as well on Y .\n\nCorollary 5.4. If the dimension of Y is 2 s − 1 , 2 s or 2 s + 1 then the Hodge conjecture holds on Y .\n\nProof. By Proposition 5.3 and Corollary 3.6.\n\n[\n\n] Angella, D. Cohomologies of certain orbifolds. Journal of Geometry and Physics\n\n(\n\n),\n\n–\n\n[\n\n] Batyrev, V. V., and Cox, D. A. On the Hodge structure of projective hypersur- faces in toric varieties. Duke Mathematical Journal\n\n,\n\n(Aug\n\n). [\n\n] Bruzzo, U., and Montoya, W. On the Hodge conjecture for quasi-smooth in- tersections in toric varieties. S˜ao Paulo J. Math. Sci. Special Section: Geometry in Algebra and Algebra in Geometry (\n\n). [\n\n] Caramello Jr, F. C. Introduction to orbifolds. a\n\niv:\n\nv\n\n(\n\n). [\n\n] Cox, D., Little, J., and Schenck, H. Toric varieties, vol.\n\nAmerican Math- ematical Soc.,\n\n[\n\n] Griffiths, P., and Harris, J. Principles of Algebraic Geometry. John Wiley & Sons, Ltd,\n\n[\n\n] Mavlyutov, A. R. Cohomology of complete intersections in toric varieties. Pub- lished in Paciﬁc J. of Math.\n\nNo.\n\n(\n\n),\n\n–\n\n[\n\n] Satake, I. On a Generalization of the Notion of Manifold. Proceedings of the National Academy of Sciences of the United States of America\n\n,\n\n(\n\n),\n\n–\n\n[\n\n] Steenbrink, J. H. M. Intersection form for quasi-homogeneous singularities. Com- positio Mathematica\n\n,\n\n(\n\n),\n\n–\n\n[\n\n] Voisin, C. Hodge Theory and Complex Algebraic Geometry I, vol.\n\nof Cambridge Studies in Advanced Mathematics . Cambridge University Press,\n\n[\n\n] Wang, Z. Z., and Zaffran, D. A remark on the Hard Lefschetz theorem for K¨ahler orbifolds. Proceedings of the American Mathematical Society\n\n,\n\n(Aug\n\n).\n\n[2] Batyrev, V. V., and Cox, D. A. On the Hodge structure of projective hypersur- faces in toric varieties. Duke Mathematical Journal 75, 2 (Aug 1994).\n\n[\n\n] Bruzzo, U., and Montoya, W. On the Hodge conjecture for quasi-smooth in- tersections in toric varieties. S˜ao Paulo J. Math. Sci. Special Section: Geometry in Algebra and Algebra in Geometry (\n\n).\n\n[3] Bruzzo, U., and Montoya, W. On the Hodge conjecture for quasi-smooth in- tersections in toric varieties. S˜ao Paulo J. Math. Sci. Special Section: Geometry in Algebra and Algebra in Geometry (2021).\n\nA. R. Cohomology of complete intersections in toric varieties. Pub-', lookup\_str='', metadata={'source': '/var/folders/ph/hhm7\_zyx4l13k3v8z02dwp1w0000gn/T/tmpgq0ckaja/online\_file.pdf'}, lookup\_index=0)]  

```
Using PyPDFium2[​](#using-pypdfium2 ""Direct link to Using PyPDFium2"")
---------------------------------------------------------------------


```
from langchain.document\_loaders import PyPDFium2Loader  

```

```
loader = PyPDFium2Loader(""example\_data/layout-parser-paper.pdf"")  

```

```
data = loader.load()  

```
Using PDFMiner[​](#using-pdfminer ""Direct link to Using PDFMiner"")
------------------------------------------------------------------


```
from langchain.document\_loaders import PDFMinerLoader  

```

```
loader = PDFMinerLoader(""example\_data/layout-parser-paper.pdf"")  

```

```
data = loader.load()  

```
### Using PDFMiner to generate HTML text[​](#using-pdfminer-to-generate-html-text ""Direct link to Using PDFMiner to generate HTML text"")

This can be helpful for chunking texts semantically into sections as the output html content can be parsed via `BeautifulSoup` to get more structured and rich information about font size, page numbers, pdf headers/footers, etc.


```
from langchain.document\_loaders import PDFMinerPDFasHTMLLoader  

```

```
loader = PDFMinerPDFasHTMLLoader(""example\_data/layout-parser-paper.pdf"")  

```

```
data = loader.load()[0] # entire pdf is loaded as a single Document  

```

```
from bs4 import BeautifulSoup  
soup = BeautifulSoup(data.page\_content,'html.parser')  
content = soup.find\_all('div')  

```

```
import re  
cur\_fs = None  
cur\_text = ''  
snippets = [] # first collect all snippets that have the same font size  
for c in content:  
 sp = c.find('span')  
 if not sp:  
 continue  
 st = sp.get('style')  
 if not st:  
 continue  
 fs = re.findall('font-size:(\d+)px',st)  
 if not fs:  
 continue  
 fs = int(fs[0])  
 if not cur\_fs:  
 cur\_fs = fs  
 if fs == cur\_fs:  
 cur\_text += c.text  
 else:  
 snippets.append((cur\_text,cur\_fs))  
 cur\_fs = fs  
 cur\_text = c.text  
snippets.append((cur\_text,cur\_fs))  
# Note: The above logic is very straightforward. One can also add more strategies such as removing duplicate snippets (as  
# headers/footers in a PDF appear on multiple pages so if we find duplicatess safe to assume that it is redundant info)  

```

```
from langchain.docstore.document import Document  
cur\_idx = -1  
semantic\_snippets = []  
# Assumption: headings have higher font size than their respective content  
for s in snippets:  
 # if current snippet's font size > previous section's heading => it is a new heading  
 if not semantic\_snippets or s[1] > semantic\_snippets[cur\_idx].metadata['heading\_font']:  
 metadata={'heading':s[0], 'content\_font': 0, 'heading\_font': s[1]}  
 metadata.update(data.metadata)  
 semantic\_snippets.append(Document(page\_content='',metadata=metadata))  
 cur\_idx += 1  
 continue  
   
 # if current snippet's font size <= previous section's content => content belongs to the same section (one can also create  
 # a tree like structure for sub sections if needed but that may require some more thinking and may be data specific)  
 if not semantic\_snippets[cur\_idx].metadata['content\_font'] or s[1] <= semantic\_snippets[cur\_idx].metadata['content\_font']:  
 semantic\_snippets[cur\_idx].page\_content += s[0]  
 semantic\_snippets[cur\_idx].metadata['content\_font'] = max(s[1], semantic\_snippets[cur\_idx].metadata['content\_font'])  
 continue  
   
 # if current snippet's font size > previous section's content but less than previous section's heading than also make a new   
 # section (e.g. title of a pdf will have the highest font size but we don't want it to subsume all sections)  
 metadata={'heading':s[0], 'content\_font': 0, 'heading\_font': s[1]}  
 metadata.update(data.metadata)  
 semantic\_snippets.append(Document(page\_content='',metadata=metadata))  
 cur\_idx += 1  

```

```
semantic\_snippets[4]  

```

```
 Document(page\_content='Recently, various DL models and datasets have been developed for layout analysis\ntasks. The dhSegment [22] utilizes fully convolutional networks [20] for segmen-\ntation tasks on historical documents. Object detection-based methods like Faster\nR-CNN [28] and Mask R-CNN [12] are used for identifying document elements [38]\nand detecting tables [30, 26]. Most recently, Graph Neural Networks [29] have also\nbeen used in table detection [27]. However, these models are usually implemented\nindividually and there is no uniﬁed framework to load and use such models.\nThere has been a surge of interest in creating open-source tools for document\nimage processing: a search of document image analysis in Github leads to 5M\nrelevant code pieces 6; yet most of them rely on traditional rule-based methods\nor provide limited functionalities. The closest prior research to our work is the\nOCR-D project7, which also tries to build a complete toolkit for DIA. However,\nsimilar to the platform developed by Neudecker et al. [21], it is designed for\nanalyzing historical documents, and provides no supports for recent DL models.\nThe DocumentLayoutAnalysis project8 focuses on processing born-digital PDF\ndocuments via analyzing the stored PDF data. Repositories like DeepLayout9\nand Detectron2-PubLayNet10 are individual deep learning models trained on\nlayout analysis datasets without support for the full DIA pipeline. The Document\nAnalysis and Exploitation (DAE) platform [15] and the DeepDIVA project [2]\naim to improve the reproducibility of DIA methods (or DL models), yet they\nare not actively maintained. OCR engines like Tesseract [14], easyOCR11 and\npaddleOCR12 usually do not come with comprehensive functionalities for other\nDIA tasks like layout analysis.\nRecent years have also seen numerous eﬀorts to create libraries for promoting\nreproducibility and reusability in the ﬁeld of DL. Libraries like Dectectron2 [35],\n6 The number shown is obtained by specifying the search type as ‘code’.\n7 https://ocr-d.de/en/about\n8 https://github.com/BobLd/DocumentLayoutAnalysis\n9 https://github.com/leonlulu/DeepLayout\n10 https://github.com/hpanwar08/detectron2\n11 https://github.com/JaidedAI/EasyOCR\n12 https://github.com/PaddlePaddle/PaddleOCR\n4\nZ. Shen et al.\nFig. 1: The overall architecture of LayoutParser. For an input document image,\nthe core LayoutParser library provides a set of oﬀ-the-shelf tools for layout\ndetection, OCR, visualization, and storage, backed by a carefully designed layout\ndata structure. LayoutParser also supports high level customization via eﬃcient\nlayout annotation and model training functions. These improve model accuracy\non the target samples. The community platform enables the easy sharing of DIA\nmodels and whole digitization pipelines to promote reusability and reproducibility.\nA collection of detailed documentation, tutorials and exemplar projects make\nLayoutParser easy to learn and use.\nAllenNLP [8] and transformers [34] have provided the community with complete\nDL-based support for developing and deploying models for general computer\nvision and natural language processing problems. LayoutParser, on the other\nhand, specializes speciﬁcally in DIA tasks. LayoutParser is also equipped with a\ncommunity platform inspired by established model hubs such as Torch Hub [23]\nand TensorFlow Hub [1]. It enables the sharing of pretrained models as well as\nfull document processing pipelines that are unique to DIA tasks.\nThere have been a variety of document data collections to facilitate the\ndevelopment of DL models. Some examples include PRImA [3](magazine layouts),\nPubLayNet [38](academic paper layouts), Table Bank [18](tables in academic\npapers), Newspaper Navigator Dataset [16, 17](newspaper ﬁgure layouts) and\nHJDataset [31](historical Japanese document layouts). A spectrum of models\ntrained on these datasets are currently available in the LayoutParser model zoo\nto support diﬀerent use cases.\n', metadata={'heading': '2 Related Work\n', 'content\_font': 9, 'heading\_font': 11, 'source': 'example\_data/layout-parser-paper.pdf'})  

```
Using PyMuPDF[​](#using-pymupdf ""Direct link to Using PyMuPDF"")
---------------------------------------------------------------

This is the fastest of the PDF parsing options, and contains detailed metadata about the PDF and its pages, as well as returns one document per page.


```
from langchain.document\_loaders import PyMuPDFLoader  

```

```
loader = PyMuPDFLoader(""example\_data/layout-parser-paper.pdf"")  

```

```
data = loader.load()  

```

```
data[0]  

```

```
 Document(page\_content='LayoutParser: A Uniﬁed Toolkit for Deep\nLearning Based Document Image Analysis\nZejiang Shen1 (�), Ruochen Zhang2, Melissa Dell3, Benjamin Charles Germain\nLee4, Jacob Carlson3, and Weining Li5\n1 Allen Institute for AI\nshannons@allenai.org\n2 Brown University\nruochen zhang@brown.edu\n3 Harvard University\n{melissadell,jacob carlson}@fas.harvard.edu\n4 University of Washington\nbcgl@cs.washington.edu\n5 University of Waterloo\nw422li@uwaterloo.ca\nAbstract. Recent advances in document image analysis (DIA) have been\nprimarily driven by the application of neural networks. Ideally, research\noutcomes could be easily deployed in production and extended for further\ninvestigation. However, various factors like loosely organized codebases\nand sophisticated model conﬁgurations complicate the easy reuse of im-\nportant innovations by a wide audience. Though there have been on-going\neﬀorts to improve reusability and simplify deep learning (DL) model\ndevelopment in disciplines like natural language processing and computer\nvision, none of them are optimized for challenges in the domain of DIA.\nThis represents a major gap in the existing toolkit, as DIA is central to\nacademic research across a wide range of disciplines in the social sciences\nand humanities. This paper introduces LayoutParser, an open-source\nlibrary for streamlining the usage of DL in DIA research and applica-\ntions. The core LayoutParser library comes with a set of simple and\nintuitive interfaces for applying and customizing DL models for layout de-\ntection, character recognition, and many other document processing tasks.\nTo promote extensibility, LayoutParser also incorporates a community\nplatform for sharing both pre-trained models and full document digiti-\nzation pipelines. We demonstrate that LayoutParser is helpful for both\nlightweight and large-scale digitization pipelines in real-word use cases.\nThe library is publicly available at https://layout-parser.github.io.\nKeywords: Document Image Analysis · Deep Learning · Layout Analysis\n· Character Recognition · Open Source library · Toolkit.\n1\nIntroduction\nDeep Learning(DL)-based approaches are the state-of-the-art for a wide range of\ndocument image analysis (DIA) tasks including document image classiﬁcation [11,\narXiv:2103.15348v2 [cs.CV] 21 Jun 2021\n', lookup\_str='', metadata={'file\_path': 'example\_data/layout-parser-paper.pdf', 'page\_number': 1, 'total\_pages': 16, 'format': 'PDF 1.5', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'LaTeX with hyperref', 'producer': 'pdfTeX-1.40.21', 'creationDate': 'D:20210622012710Z', 'modDate': 'D:20210622012710Z', 'trapped': '', 'encryption': None}, lookup\_index=0)  

```
Additionally, you can pass along any of the options from the [PyMuPDF documentation](https://pymupdf.readthedocs.io/en/latest/app1.html#plain-text/) as keyword arguments in the `load` call, and it will be pass along to the `get_text()` call.

PyPDF Directory[​](#pypdf-directory ""Direct link to PyPDF Directory"")
---------------------------------------------------------------------

Load PDFs from directory


```
from langchain.document\_loaders import PyPDFDirectoryLoader  

```

```
loader = PyPDFDirectoryLoader(""example\_data/"")  

```

```
docs = loader.load()  

```
Using pdfplumber[​](#using-pdfplumber ""Direct link to Using pdfplumber"")
------------------------------------------------------------------------

Like PyMuPDF, the output Documents contain detailed metadata about the PDF and its pages, and returns one document per page.


```
from langchain.document\_loaders import PDFPlumberLoader  

```

```
loader = PDFPlumberLoader(""example\_data/layout-parser-paper.pdf"")  

```

```
data = loader.load()  

```

```
data[0]  

```

```
 Document(page\_content='LayoutParser: A Unified Toolkit for Deep\nLearning Based Document Image Analysis\nZejiang Shen1 ((cid:0)), Ruochen Zhang2, Melissa Dell3, Benjamin Charles Germain\nLee4, Jacob Carlson3, and Weining Li5\n1 Allen Institute for AI\n1202 shannons@allenai.org\n2 Brown University\nruochen zhang@brown.edu\n3 Harvard University\nnuJ {melissadell,jacob carlson}@fas.harvard.edu\n4 University of Washington\nbcgl@cs.washington.edu\n12 5 University of Waterloo\nw422li@uwaterloo.ca\n]VC.sc[\nAbstract. Recentadvancesindocumentimageanalysis(DIA)havebeen\nprimarily driven by the application of neural networks. Ideally, research\noutcomescouldbeeasilydeployedinproductionandextendedforfurther\ninvestigation. However, various factors like loosely organized codebases\nand sophisticated model configurations complicate the easy reuse of im-\n2v84351.3012:viXra portantinnovationsbyawideaudience.Thoughtherehavebeenon-going\nefforts to improve reusability and simplify deep learning (DL) model\ndevelopmentindisciplineslikenaturallanguageprocessingandcomputer\nvision, none of them are optimized for challenges in the domain of DIA.\nThis represents a major gap in the existing toolkit, as DIA is central to\nacademicresearchacross awiderangeof disciplinesinthesocialsciences\nand humanities. This paper introduces LayoutParser, an open-source\nlibrary for streamlining the usage of DL in DIA research and applica-\ntions. The core LayoutParser library comes with a set of simple and\nintuitiveinterfacesforapplyingandcustomizingDLmodelsforlayoutde-\ntection,characterrecognition,andmanyotherdocumentprocessingtasks.\nTo promote extensibility, LayoutParser also incorporates a community\nplatform for sharing both pre-trained models and full document digiti-\nzation pipelines. We demonstrate that LayoutParser is helpful for both\nlightweight and large-scale digitization pipelines in real-word use cases.\nThe library is publicly available at https://layout-parser.github.io.\nKeywords: DocumentImageAnalysis·DeepLearning·LayoutAnalysis\n· Character Recognition · Open Source library · Toolkit.\n1 Introduction\nDeep Learning(DL)-based approaches are the state-of-the-art for a wide range of\ndocumentimageanalysis(DIA)tasksincludingdocumentimageclassification[11,', metadata={'source': 'example\_data/layout-parser-paper.pdf', 'file\_path': 'example\_data/layout-parser-paper.pdf', 'page': 1, 'total\_pages': 16, 'Author': '', 'CreationDate': 'D:20210622012710Z', 'Creator': 'LaTeX with hyperref', 'Keywords': '', 'ModDate': 'D:20210622012710Z', 'PTEX.Fullbanner': 'This is pdfTeX, Version 3.14159265-2.6-1.40.21 (TeX Live 2020) kpathsea version 6.3.2', 'Producer': 'pdfTeX-1.40.21', 'Subject': '', 'Title': '', 'Trapped': 'False'})  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/document_transformers/,"Document transformers
=====================

infoHead to [Integrations](/docs/integrations/document_transformers/) for documentation on built-in document transformer integrations with 3rd-party tools.

Once you've loaded documents, you'll often want to transform them to better suit your application. The simplest example
is you may want to split a long document into smaller chunks that can fit into your model's context window. LangChain
has a number of built-in document transformers that make it easy to split, combine, filter, and otherwise manipulate documents.

Text splitters[​](#text-splitters ""Direct link to Text splitters"")
------------------------------------------------------------------

When you want to deal with long pieces of text, it is necessary to split up that text into chunks.
As simple as this sounds, there is a lot of potential complexity here. Ideally, you want to keep the semantically related pieces of text together. What ""semantically related"" means could depend on the type of text.
This notebook showcases several ways to do that.

At a high level, text splitters work as following:

1. Split the text up into small, semantically meaningful chunks (often sentences).
2. Start combining these small chunks into a larger chunk until you reach a certain size (as measured by some function).
3. Once you reach that size, make that chunk its own piece of text and then start creating a new chunk of text with some overlap (to keep context between chunks).

That means there are two different axes along which you can customize your text splitter:

1. How the text is split
2. How the chunk size is measured

### Get started with text splitters[​](#get-started-with-text-splitters ""Direct link to Get started with text splitters"")

The default recommended text splitter is the RecursiveCharacterTextSplitter. This text splitter takes a list of characters. It tries to create chunks based on splitting on the first character, but if any chunks are too large it then moves onto the next character, and so forth. By default the characters it tries to split on are `[""\n\n"", ""\n"", "" "", """"]`

In addition to controlling which characters you can split on, you can also control a few other things:

* `length_function`: how the length of chunks is calculated. Defaults to just counting number of characters, but it's pretty common to pass a token counter here.
* `chunk_size`: the maximum size of your chunks (as measured by the length function).
* `chunk_overlap`: the maximum overlap between chunks. It can be nice to have some overlap to maintain some continuity between chunks (eg do a sliding window).
* `add_start_index`: whether to include the starting position of each chunk within the original document in the metadata.


```
# This is a long document we can split up.  
with open('../../state\_of\_the\_union.txt') as f:  
 state\_of\_the\_union = f.read()  

```

```
from langchain.text\_splitter import RecursiveCharacterTextSplitter  

```

```
text\_splitter = RecursiveCharacterTextSplitter(  
 # Set a really small chunk size, just to show.  
 chunk\_size = 100,  
 chunk\_overlap = 20,  
 length\_function = len,  
 add\_start\_index = True,  
)  

```

```
texts = text\_splitter.create\_documents([state\_of\_the\_union])  
print(texts[0])  
print(texts[1])  

```

```
 page\_content='Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and' metadata={'start\_index': 0}  
 page\_content='of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans.' metadata={'start\_index': 82}  

```
Other transformations:[​](#other-transformations ""Direct link to Other transformations:"")
-----------------------------------------------------------------------------------------

### Filter redundant docs, translate docs, extract metadata, and more[​](#filter-redundant-docs-translate-docs-extract-metadata-and-more ""Direct link to Filter redundant docs, translate docs, extract metadata, and more"")

We can do perform a number of transformations on docs which are not simply splitting the text. With the
`EmbeddingsRedundantFilter` we can identify similar documents and filter out redundancies. With integrations like
[doctran](https://github.com/psychic-api/doctran/tree/main) we can do things like translate documents from one language
to another, extract desired properties and add them to metadata, and convert conversational dialogue into a Q/A format
set of documents.

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/document_transformers/text_splitters/character_text_splitter,"Split by character
==================

This is the simplest method. This splits based on characters (by default ""\n\n"") and measure chunk length by number of characters.

1. How the text is split: by single character
2. How the chunk size is measured: by number of characters


```
# This is a long document we can split up.  
with open('../../../state\_of\_the\_union.txt') as f:  
 state\_of\_the\_union = f.read()  

```

```
from langchain.text\_splitter import CharacterTextSplitter  
text\_splitter = CharacterTextSplitter(   
 separator = ""\n\n"",  
 chunk\_size = 1000,  
 chunk\_overlap = 200,  
 length\_function = len,  
)  

```

```
texts = text\_splitter.create\_documents([state\_of\_the\_union])  
print(texts[0])  

```

```
 page\_content='Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans. \n\nLast year COVID-19 kept us apart. This year we are finally together again. \n\nTonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. \n\nWith a duty to one another to the American people to the Constitution. \n\nAnd with an unwavering resolve that freedom will always triumph over tyranny. \n\nSix days ago, Russia’s Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways. But he badly miscalculated. \n\nHe thought he could roll into Ukraine and the world would roll over. Instead he met a wall of strength he never imagined. \n\nHe met the Ukrainian people. \n\nFrom President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world.' lookup\_str='' metadata={} lookup\_index=0  

```
Here's an example of passing metadata along with the documents, notice that it is split along with the documents.


```
metadatas = [{""document"": 1}, {""document"": 2}]  
documents = text\_splitter.create\_documents([state\_of\_the\_union, state\_of\_the\_union], metadatas=metadatas)  
print(documents[0])  

```

```
 page\_content='Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans. \n\nLast year COVID-19 kept us apart. This year we are finally together again. \n\nTonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. \n\nWith a duty to one another to the American people to the Constitution. \n\nAnd with an unwavering resolve that freedom will always triumph over tyranny. \n\nSix days ago, Russia’s Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways. But he badly miscalculated. \n\nHe thought he could roll into Ukraine and the world would roll over. Instead he met a wall of strength he never imagined. \n\nHe met the Ukrainian people. \n\nFrom President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world.' lookup\_str='' metadata={'document': 1} lookup\_index=0  

```

```
text\_splitter.split\_text(state\_of\_the\_union)[0]  

```

```
 'Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans. \n\nLast year COVID-19 kept us apart. This year we are finally together again. \n\nTonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. \n\nWith a duty to one another to the American people to the Constitution. \n\nAnd with an unwavering resolve that freedom will always triumph over tyranny. \n\nSix days ago, Russia’s Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways. But he badly miscalculated. \n\nHe thought he could roll into Ukraine and the world would roll over. Instead he met a wall of strength he never imagined. \n\nHe met the Ukrainian people. \n\nFrom President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world.'  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/document_transformers/text_splitters/code_splitter,"Split code
==========

CodeTextSplitter allows you to split your code with multiple language support. Import enum `Language` and specify the language. 


```
from langchain.text\_splitter import (  
 RecursiveCharacterTextSplitter,  
 Language,  
)  

```

```
# Full list of support languages  
[e.value for e in Language]  

```

```
 ['cpp',  
 'go',  
 'java',  
 'js',  
 'php',  
 'proto',  
 'python',  
 'rst',  
 'ruby',  
 'rust',  
 'scala',  
 'swift',  
 'markdown',  
 'latex',  
 'html',  
 'sol',]  

```

```
# You can also see the separators used for a given language  
RecursiveCharacterTextSplitter.get\_separators\_for\_language(Language.PYTHON)  

```

```
 ['\nclass ', '\ndef ', '\n\tdef ', '\n\n', '\n', ' ', '']  

```
Python[​](#python ""Direct link to Python"")
------------------------------------------

Here's an example using the PythonTextSplitter


```
PYTHON\_CODE = """"""  
def hello\_world():  
 print(""Hello, World!"")  
  
# Call the function  
hello\_world()  
""""""  
python\_splitter = RecursiveCharacterTextSplitter.from\_language(  
 language=Language.PYTHON, chunk\_size=50, chunk\_overlap=0  
)  
python\_docs = python\_splitter.create\_documents([PYTHON\_CODE])  
python\_docs  

```

```
 [Document(page\_content='def hello\_world():\n print(""Hello, World!"")', metadata={}),  
 Document(page\_content='# Call the function\nhello\_world()', metadata={})]  

```
JS[​](#js ""Direct link to JS"")
------------------------------

Here's an example using the JS text splitter


```
JS\_CODE = """"""  
function helloWorld() {  
 console.log(""Hello, World!"");  
}  
  
// Call the function  
helloWorld();  
""""""  
  
js\_splitter = RecursiveCharacterTextSplitter.from\_language(  
 language=Language.JS, chunk\_size=60, chunk\_overlap=0  
)  
js\_docs = js\_splitter.create\_documents([JS\_CODE])  
js\_docs  

```

```
 [Document(page\_content='function helloWorld() {\n console.log(""Hello, World!"");\n}', metadata={}),  
 Document(page\_content='// Call the function\nhelloWorld();', metadata={})]  

```
Markdown[​](#markdown ""Direct link to Markdown"")
------------------------------------------------

Here's an example using the Markdown text splitter.


```
markdown\_text = """"""  
# 🦜️🔗 LangChain  
  
⚡ Building applications with LLMs through composability ⚡  
  
## Quick Install  
  
```bash  
# Hopefully this code block isn't split  
pip install langchain  
```  
  
As an open source project in a rapidly developing field, we are extremely open to contributions.  
""""""  

```

```
md\_splitter = RecursiveCharacterTextSplitter.from\_language(  
 language=Language.MARKDOWN, chunk\_size=60, chunk\_overlap=0  
)  
md\_docs = md\_splitter.create\_documents([markdown\_text])  
md\_docs  

```

```
 [Document(page\_content='# 🦜️🔗 LangChain', metadata={}),  
 Document(page\_content='⚡ Building applications with LLMs through composability ⚡', metadata={}),  
 Document(page\_content='## Quick Install', metadata={}),  
 Document(page\_content=""```bash\n# Hopefully this code block isn't split"", metadata={}),  
 Document(page\_content='pip install langchain', metadata={}),  
 Document(page\_content='```', metadata={}),  
 Document(page\_content='As an open source project in a rapidly developing field, we', metadata={}),  
 Document(page\_content='are extremely open to contributions.', metadata={})]  

```
Latex[​](#latex ""Direct link to Latex"")
---------------------------------------

Here's an example on Latex text


```
latex\_text = """"""  
\documentclass{article}  
  
\begin{document}  
  
\maketitle  
  
\section{Introduction}  
Large language models (LLMs) are a type of machine learning model that can be trained on vast amounts of text data to generate human-like language. In recent years, LLMs have made significant advances in a variety of natural language processing tasks, including language translation, text generation, and sentiment analysis.  
  
\subsection{History of LLMs}  
The earliest LLMs were developed in the 1980s and 1990s, but they were limited by the amount of data that could be processed and the computational power available at the time. In the past decade, however, advances in hardware and software have made it possible to train LLMs on massive datasets, leading to significant improvements in performance.  
  
\subsection{Applications of LLMs}  
LLMs have many applications in industry, including chatbots, content creation, and virtual assistants. They can also be used in academia for research in linguistics, psychology, and computational linguistics.  
  
\end{document}  
""""""  

```

```
latex\_splitter = RecursiveCharacterTextSplitter.from\_language(  
 language=Language.MARKDOWN, chunk\_size=60, chunk\_overlap=0  
)  
latex\_docs = latex\_splitter.create\_documents([latex\_text])  
latex\_docs  

```

```
 [Document(page\_content='\\documentclass{article}\n\n\x08egin{document}\n\n\\maketitle', metadata={}),  
 Document(page\_content='\\section{Introduction}', metadata={}),  
 Document(page\_content='Large language models (LLMs) are a type of machine learning', metadata={}),  
 Document(page\_content='model that can be trained on vast amounts of text data to', metadata={}),  
 Document(page\_content='generate human-like language. In recent years, LLMs have', metadata={}),  
 Document(page\_content='made significant advances in a variety of natural language', metadata={}),  
 Document(page\_content='processing tasks, including language translation, text', metadata={}),  
 Document(page\_content='generation, and sentiment analysis.', metadata={}),  
 Document(page\_content='\\subsection{History of LLMs}', metadata={}),  
 Document(page\_content='The earliest LLMs were developed in the 1980s and 1990s,', metadata={}),  
 Document(page\_content='but they were limited by the amount of data that could be', metadata={}),  
 Document(page\_content='processed and the computational power available at the', metadata={}),  
 Document(page\_content='time. In the past decade, however, advances in hardware and', metadata={}),  
 Document(page\_content='software have made it possible to train LLMs on massive', metadata={}),  
 Document(page\_content='datasets, leading to significant improvements in', metadata={}),  
 Document(page\_content='performance.', metadata={}),  
 Document(page\_content='\\subsection{Applications of LLMs}', metadata={}),  
 Document(page\_content='LLMs have many applications in industry, including', metadata={}),  
 Document(page\_content='chatbots, content creation, and virtual assistants. They', metadata={}),  
 Document(page\_content='can also be used in academia for research in linguistics,', metadata={}),  
 Document(page\_content='psychology, and computational linguistics.', metadata={}),  
 Document(page\_content='\\end{document}', metadata={})]  

```
HTML[​](#html ""Direct link to HTML"")
------------------------------------

Here's an example using an HTML text splitter


```
html\_text = """"""  
<!DOCTYPE html>  
<html>  
 <head>  
 <title>🦜️🔗 LangChain</title>  
 <style>  
 body {  
 font-family: Arial, sans-serif;  
 }  
 h1 {  
 color: darkblue;  
 }  
 </style>  
 </head>  
 <body>  
 <div>  
 <h1>🦜️🔗 LangChain</h1>  
 <p>⚡ Building applications with LLMs through composability ⚡</p>  
 </div>  
 <div>  
 As an open source project in a rapidly developing field, we are extremely open to contributions.  
 </div>  
 </body>  
</html>  
""""""  

```

```
html\_splitter = RecursiveCharacterTextSplitter.from\_language(  
 language=Language.HTML, chunk\_size=60, chunk\_overlap=0  
)  
html\_docs = html\_splitter.create\_documents([html\_text])  
html\_docs  

```

```
 [Document(page\_content='<!DOCTYPE html>\n<html>', metadata={}),  
 Document(page\_content='<head>\n <title>🦜️🔗 LangChain</title>', metadata={}),  
 Document(page\_content='<style>\n body {\n font-family: Aria', metadata={}),  
 Document(page\_content='l, sans-serif;\n }\n h1 {', metadata={}),  
 Document(page\_content='color: darkblue;\n }\n </style>\n </head', metadata={}),  
 Document(page\_content='>', metadata={}),  
 Document(page\_content='<body>', metadata={}),  
 Document(page\_content='<div>\n <h1>🦜️🔗 LangChain</h1>', metadata={}),  
 Document(page\_content='<p>⚡ Building applications with LLMs through composability ⚡', metadata={}),  
 Document(page\_content='</p>\n </div>', metadata={}),  
 Document(page\_content='<div>\n As an open source project in a rapidly dev', metadata={}),  
 Document(page\_content='eloping field, we are extremely open to contributions.', metadata={}),  
 Document(page\_content='</div>\n </body>\n</html>', metadata={})]  

```
Solidity[​](#solidity ""Direct link to Solidity"")
------------------------------------------------

Here's an example using the Solidity text splitter


```
SOL\_CODE = """"""  
pragma solidity ^0.8.20;  
contract HelloWorld {  
 function add(uint a, uint b) pure public returns(uint) {  
 return a + b;  
 }  
}  
""""""  
  
sol\_splitter = RecursiveCharacterTextSplitter.from\_language(  
 language=Language.SOL, chunk\_size=128, chunk\_overlap=0  
)  
sol\_docs = sol\_splitter.create\_documents([SOL\_CODE])  
sol\_docs  

```

```
[  
 Document(page\_content='pragma solidity ^0.8.20;', metadata={}),  
 Document(page\_content='contract HelloWorld {\n function add(uint a, uint b) pure public returns(uint) {\n return a + b;\n }\n}', metadata={})  
]  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/document_transformers/text_splitters/recursive_text_splitter,"Recursively split by character
==============================

This text splitter is the recommended one for generic text. It is parameterized by a list of characters. It tries to split on them in order until the chunks are small enough. The default list is `[""\n\n"", ""\n"", "" "", """"]`. This has the effect of trying to keep all paragraphs (and then sentences, and then words) together as long as possible, as those would generically seem to be the strongest semantically related pieces of text.

1. How the text is split: by list of characters
2. How the chunk size is measured: by number of characters


```
# This is a long document we can split up.  
with open('../../../state\_of\_the\_union.txt') as f:  
 state\_of\_the\_union = f.read()  

```

```
from langchain.text\_splitter import RecursiveCharacterTextSplitter  

```

```
text\_splitter = RecursiveCharacterTextSplitter(  
 # Set a really small chunk size, just to show.  
 chunk\_size = 100,  
 chunk\_overlap = 20,  
 length\_function = len,  
)  

```

```
texts = text\_splitter.create\_documents([state\_of\_the\_union])  
print(texts[0])  
print(texts[1])  

```

```
 page\_content='Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and' lookup\_str='' metadata={} lookup\_index=0  
 page\_content='of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans.' lookup\_str='' metadata={} lookup\_index=0  

```

```
text\_splitter.split\_text(state\_of\_the\_union)[:2]  

```

```
 ['Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and',  
 'of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans.']  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/,"Data connection
===============

Many LLM applications require user-specific data that is not part of the model's training set. LangChain gives you the
building blocks to load, transform, store and query your data via:

* [Document loaders](/docs/modules/data_connection/document_loaders/): Load documents from many different sources
* [Document transformers](/docs/modules/data_connection/document_transformers/): Split documents, convert documents into Q&A format, drop redundant documents, and more
* [Text embedding models](/docs/modules/data_connection/text_embedding/): Take unstructured text and turn it into a list of floating point numbers
* [Vector stores](/docs/modules/data_connection/vectorstores/): Store and search over embedded data
* [Retrievers](/docs/modules/data_connection/retrievers/): Query your data

![data_connection_diagram](/assets/images/data_connection-c42d68c3d092b85f50d08d4cc171fc25.jpg)

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/retrievers/contextual_compression/,"Contextual compression
======================

One challenge with retrieval is that usually you don't know the specific queries your document storage system will face when you ingest data into the system. This means that the information most relevant to a query may be buried in a document with a lot of irrelevant text. Passing that full document through your application can lead to more expensive LLM calls and poorer responses.

Contextual compression is meant to fix this. The idea is simple: instead of immediately returning retrieved documents as-is, you can compress them using the context of the given query, so that only the relevant information is returned. “Compressing” here refers to both compressing the contents of an individual document and filtering out documents wholesale.

To use the Contextual Compression Retriever, you'll need:

* a base Retriever
* a Document Compressor

The Contextual Compression Retriever passes queries to the base Retriever, takes the initial documents and passes them through the Document Compressor. The Document Compressor takes a list of Documents and shortens it by reducing the contents of Documents or dropping Documents altogether.

![](https://drive.google.com/uc?id=1CtNgWODXZudxAWSRiWgSGEoTNrUFT98v)

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------


```
# Helper function for printing docs  
  
def pretty\_print\_docs(docs):  
 print(f""\n{'-' \* 100}\n"".join([f""Document {i+1}:\n\n"" + d.page\_content for i, d in enumerate(docs)]))  

```
Using a vanilla vector store retriever[​](#using-a-vanilla-vector-store-retriever ""Direct link to Using a vanilla vector store retriever"")
------------------------------------------------------------------------------------------------------------------------------------------

Let's start by initializing a simple vector store retriever and storing the 2023 State of the Union speech (in chunks). We can see that given an example question our retriever returns one or two relevant docs and a few irrelevant docs. And even the relevant docs have a lot of irrelevant information in them.


```
from langchain.text\_splitter import CharacterTextSplitter  
from langchain.embeddings import OpenAIEmbeddings  
from langchain.document\_loaders import TextLoader  
from langchain.vectorstores import FAISS  
  
documents = TextLoader('../../../state\_of\_the\_union.txt').load()  
text\_splitter = CharacterTextSplitter(chunk\_size=1000, chunk\_overlap=0)  
texts = text\_splitter.split\_documents(documents)  
retriever = FAISS.from\_documents(texts, OpenAIEmbeddings()).as\_retriever()  
  
docs = retriever.get\_relevant\_documents(""What did the president say about Ketanji Brown Jackson"")  
pretty\_print\_docs(docs)  

```

```
 Document 1:  
   
 Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections.   
   
 Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service.   
   
 One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.   
   
 And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.  
 ----------------------------------------------------------------------------------------------------  
 Document 2:  
   
 A former top litigator in private practice. A former federal public defender. And from a family of public school educators and police officers. A consensus builder. Since she’s been nominated, she’s received a broad range of support—from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.   
   
 And if we are to advance liberty and justice, we need to secure the Border and fix the immigration system.   
   
 We can do both. At our border, we’ve installed new technology like cutting-edge scanners to better detect drug smuggling.   
   
 We’ve set up joint patrols with Mexico and Guatemala to catch more human traffickers.   
   
 We’re putting in place dedicated immigration judges so families fleeing persecution and violence can have their cases heard faster.   
   
 We’re securing commitments and supporting partners in South and Central America to host more refugees and secure their own borders.  
 ----------------------------------------------------------------------------------------------------  
 Document 3:  
   
 And for our LGBTQ+ Americans, let’s finally get the bipartisan Equality Act to my desk. The onslaught of state laws targeting transgender Americans and their families is wrong.   
   
 As I said last year, especially to our younger transgender Americans, I will always have your back as your President, so you can be yourself and reach your God-given potential.   
   
 While it often appears that we never agree, that isn’t true. I signed 80 bipartisan bills into law last year. From preventing government shutdowns to protecting Asian-Americans from still-too-common hate crimes to reforming military justice.   
   
 And soon, we’ll strengthen the Violence Against Women Act that I first wrote three decades ago. It is important for us to show the nation that we can come together and do big things.   
   
 So tonight I’m offering a Unity Agenda for the Nation. Four big things we can do together.   
   
 First, beat the opioid epidemic.  
 ----------------------------------------------------------------------------------------------------  
 Document 4:  
   
 Tonight, I’m announcing a crackdown on these companies overcharging American businesses and consumers.   
   
 And as Wall Street firms take over more nursing homes, quality in those homes has gone down and costs have gone up.   
   
 That ends on my watch.   
   
 Medicare is going to set higher standards for nursing homes and make sure your loved ones get the care they deserve and expect.   
   
 We’ll also cut costs and keep the economy going strong by giving workers a fair shot, provide more training and apprenticeships, hire them based on their skills not degrees.   
   
 Let’s pass the Paycheck Fairness Act and paid leave.   
   
 Raise the minimum wage to $15 an hour and extend the Child Tax Credit, so no one has to raise a family in poverty.   
   
 Let’s increase Pell Grants and increase our historic support of HBCUs, and invest in what Jill—our First Lady who teaches full-time—calls America’s best-kept secret: community colleges.  

```
Adding contextual compression with an `LLMChainExtractor`[​](#adding-contextual-compression-with-an-llmchainextractor ""Direct link to adding-contextual-compression-with-an-llmchainextractor"")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Now let's wrap our base retriever with a `ContextualCompressionRetriever`. We'll add an `LLMChainExtractor`, which will iterate over the initially returned documents and extract from each only the content that is relevant to the query.


```
from langchain.llms import OpenAI  
from langchain.retrievers import ContextualCompressionRetriever  
from langchain.retrievers.document\_compressors import LLMChainExtractor  
  
llm = OpenAI(temperature=0)  
compressor = LLMChainExtractor.from\_llm(llm)  
compression\_retriever = ContextualCompressionRetriever(base\_compressor=compressor, base\_retriever=retriever)  
  
compressed\_docs = compression\_retriever.get\_relevant\_documents(""What did the president say about Ketanji Jackson Brown"")  
pretty\_print\_docs(compressed\_docs)  

```

```
 Document 1:  
   
 ""One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.   
   
 And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.""  
 ----------------------------------------------------------------------------------------------------  
 Document 2:  
   
 ""A former top litigator in private practice. A former federal public defender. And from a family of public school educators and police officers. A consensus builder. Since she’s been nominated, she’s received a broad range of support—from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.""  

```
More built-in compressors: filters[​](#more-built-in-compressors-filters ""Direct link to More built-in compressors: filters"")
-----------------------------------------------------------------------------------------------------------------------------

### `LLMChainFilter`[​](#llmchainfilter ""Direct link to llmchainfilter"")

The `LLMChainFilter` is slightly simpler but more robust compressor that uses an LLM chain to decide which of the initially retrieved documents to filter out and which ones to return, without manipulating the document contents.


```
from langchain.retrievers.document\_compressors import LLMChainFilter  
  
\_filter = LLMChainFilter.from\_llm(llm)  
compression\_retriever = ContextualCompressionRetriever(base\_compressor=\_filter, base\_retriever=retriever)  
  
compressed\_docs = compression\_retriever.get\_relevant\_documents(""What did the president say about Ketanji Jackson Brown"")  
pretty\_print\_docs(compressed\_docs)  

```

```
 Document 1:  
   
 Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections.   
   
 Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service.   
   
 One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.   
   
 And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.  

```
### `EmbeddingsFilter`[​](#embeddingsfilter ""Direct link to embeddingsfilter"")

Making an extra LLM call over each retrieved document is expensive and slow. The `EmbeddingsFilter` provides a cheaper and faster option by embedding the documents and query and only returning those documents which have sufficiently similar embeddings to the query.


```
from langchain.embeddings import OpenAIEmbeddings  
from langchain.retrievers.document\_compressors import EmbeddingsFilter  
  
embeddings = OpenAIEmbeddings()  
embeddings\_filter = EmbeddingsFilter(embeddings=embeddings, similarity\_threshold=0.76)  
compression\_retriever = ContextualCompressionRetriever(base\_compressor=embeddings\_filter, base\_retriever=retriever)  
  
compressed\_docs = compression\_retriever.get\_relevant\_documents(""What did the president say about Ketanji Jackson Brown"")  
pretty\_print\_docs(compressed\_docs)  

```

```
 Document 1:  
   
 Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections.   
   
 Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service.   
   
 One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.   
   
 And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.  
 ----------------------------------------------------------------------------------------------------  
 Document 2:  
   
 A former top litigator in private practice. A former federal public defender. And from a family of public school educators and police officers. A consensus builder. Since she’s been nominated, she’s received a broad range of support—from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.   
   
 And if we are to advance liberty and justice, we need to secure the Border and fix the immigration system.   
   
 We can do both. At our border, we’ve installed new technology like cutting-edge scanners to better detect drug smuggling.   
   
 We’ve set up joint patrols with Mexico and Guatemala to catch more human traffickers.   
   
 We’re putting in place dedicated immigration judges so families fleeing persecution and violence can have their cases heard faster.   
   
 We’re securing commitments and supporting partners in South and Central America to host more refugees and secure their own borders.  
 ----------------------------------------------------------------------------------------------------  
 Document 3:  
   
 And for our LGBTQ+ Americans, let’s finally get the bipartisan Equality Act to my desk. The onslaught of state laws targeting transgender Americans and their families is wrong.   
   
 As I said last year, especially to our younger transgender Americans, I will always have your back as your President, so you can be yourself and reach your God-given potential.   
   
 While it often appears that we never agree, that isn’t true. I signed 80 bipartisan bills into law last year. From preventing government shutdowns to protecting Asian-Americans from still-too-common hate crimes to reforming military justice.   
   
 And soon, we’ll strengthen the Violence Against Women Act that I first wrote three decades ago. It is important for us to show the nation that we can come together and do big things.   
   
 So tonight I’m offering a Unity Agenda for the Nation. Four big things we can do together.   
   
 First, beat the opioid epidemic.  

```
Stringing compressors and document transformers together
========================================================

Using the `DocumentCompressorPipeline` we can also easily combine multiple compressors in sequence. Along with compressors we can add `BaseDocumentTransformer`s to our pipeline, which don't perform any contextual compression but simply perform some transformation on a set of documents. For example `TextSplitter`s can be used as document transformers to split documents into smaller pieces, and the `EmbeddingsRedundantFilter` can be used to filter out redundant documents based on embedding similarity between documents.

Below we create a compressor pipeline by first splitting our docs into smaller chunks, then removing redundant documents, and then filtering based on relevance to the query.


```
from langchain.document\_transformers import EmbeddingsRedundantFilter  
from langchain.retrievers.document\_compressors import DocumentCompressorPipeline  
from langchain.text\_splitter import CharacterTextSplitter  
  
splitter = CharacterTextSplitter(chunk\_size=300, chunk\_overlap=0, separator="". "")  
redundant\_filter = EmbeddingsRedundantFilter(embeddings=embeddings)  
relevant\_filter = EmbeddingsFilter(embeddings=embeddings, similarity\_threshold=0.76)  
pipeline\_compressor = DocumentCompressorPipeline(  
 transformers=[splitter, redundant\_filter, relevant\_filter]  
)  

```

```
compression\_retriever = ContextualCompressionRetriever(base\_compressor=pipeline\_compressor, base\_retriever=retriever)  
  
compressed\_docs = compression\_retriever.get\_relevant\_documents(""What did the president say about Ketanji Jackson Brown"")  
pretty\_print\_docs(compressed\_docs)  

```

```
 Document 1:  
   
 One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.   
   
 And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson  
 ----------------------------------------------------------------------------------------------------  
 Document 2:  
   
 As I said last year, especially to our younger transgender Americans, I will always have your back as your President, so you can be yourself and reach your God-given potential.   
   
 While it often appears that we never agree, that isn’t true. I signed 80 bipartisan bills into law last year  
 ----------------------------------------------------------------------------------------------------  
 Document 3:  
   
 A former top litigator in private practice. A former federal public defender. And from a family of public school educators and police officers. A consensus builder  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/retrievers/,"Retrievers
==========

infoHead to [Integrations](/docs/integrations/retrievers/) for documentation on built-in retriever integrations with 3rd-party tools.

A retriever is an interface that returns documents given an unstructured query. It is more general than a vector store.
A retriever does not need to be able to store documents, only to return (or retrieve) it. Vector stores can be used
as the backbone of a retriever, but there are other types of retrievers as well.

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------

The public API of the `BaseRetriever` class in LangChain is as follows:


```
from abc import ABC, abstractmethod  
from typing import Any, List  
from langchain.schema import Document  
from langchain.callbacks.manager import Callbacks  
  
class BaseRetriever(ABC):  
 ...  
 def get\_relevant\_documents(  
 self, query: str, \*, callbacks: Callbacks = None, \*\*kwargs: Any  
 ) -> List[Document]:  
 """"""Retrieve documents relevant to a query.  
 Args:  
 query: string to find relevant documents for  
 callbacks: Callback manager or list of callbacks  
 Returns:  
 List of relevant documents  
 """"""  
 ...  
  
 async def aget\_relevant\_documents(  
 self, query: str, \*, callbacks: Callbacks = None, \*\*kwargs: Any  
 ) -> List[Document]:  
 """"""Asynchronously get documents relevant to a query.  
 Args:  
 query: string to find relevant documents for  
 callbacks: Callback manager or list of callbacks  
 Returns:  
 List of relevant documents  
 """"""  
 ...  

```
It's that simple! You can call `get_relevant_documents` or the async `get_relevant_documents` methods to retrieve documents relevant to a query, where ""relevance"" is defined by
the specific retriever object you are calling.

Of course, we also help construct what we think useful Retrievers are. The main type of Retriever that we focus on is a Vectorstore retriever. We will focus on that for the rest of this guide.

In order to understand what a vectorstore retriever is, it's important to understand what a Vectorstore is. So let's look at that.

By default, LangChain uses [Chroma](/docs/ecosystem/integrations/chroma.html) as the vectorstore to index and search embeddings. To walk through this tutorial, we'll first need to install `chromadb`.


```
pip install chromadb  

```
This example showcases question answering over documents.
We have chosen this as the example for getting started because it nicely combines a lot of different elements (Text splitters, embeddings, vectorstores) and then also shows how to use them in a chain.

Question answering over documents consists of four steps:

1. Create an index
2. Create a Retriever from that index
3. Create a question answering chain
4. Ask questions!

Each of the steps has multiple sub steps and potential configurations. In this notebook we will primarily focus on (1). We will start by showing the one-liner for doing so, but then break down what is actually going on.

First, let's import some common classes we'll use no matter what.


```
from langchain.chains import RetrievalQA  
from langchain.llms import OpenAI  

```
Next in the generic setup, let's specify the document loader we want to use. You can download the `state_of_the_union.txt` file [here](https://github.com/hwchase17/langchain/blob/master/docs/extras/modules/state_of_the_union.txt)


```
from langchain.document\_loaders import TextLoader  
loader = TextLoader('../state\_of\_the\_union.txt', encoding='utf8')  

```
One Line Index Creation[​](#one-line-index-creation ""Direct link to One Line Index Creation"")
---------------------------------------------------------------------------------------------

To get started as quickly as possible, we can use the `VectorstoreIndexCreator`.


```
from langchain.indexes import VectorstoreIndexCreator  

```

```
index = VectorstoreIndexCreator().from\_loaders([loader])  

```

```
 Running Chroma using direct local API.  
 Using DuckDB in-memory for database. Data will be transient.  

```
Now that the index is created, we can use it to ask questions of the data! Note that under the hood this is actually doing a few steps as well, which we will cover later in this guide.


```
query = ""What did the president say about Ketanji Brown Jackson""  
index.query(query)  

```

```
 "" The president said that Ketanji Brown Jackson is one of the nation's top legal minds, a former top litigator in private practice, a former federal public defender, and from a family of public school educators and police officers. He also said that she is a consensus builder and has received a broad range of support from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.""  

```

```
query = ""What did the president say about Ketanji Brown Jackson""  
index.query\_with\_sources(query)  

```

```
 {'question': 'What did the president say about Ketanji Brown Jackson',  
 'answer': "" The president said that he nominated Circuit Court of Appeals Judge Ketanji Brown Jackson, one of the nation's top legal minds, to continue Justice Breyer's legacy of excellence, and that she has received a broad range of support from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.\n"",  
 'sources': '../state\_of\_the\_union.txt'}  

```
What is returned from the `VectorstoreIndexCreator` is `VectorStoreIndexWrapper`, which provides these nice `query` and `query_with_sources` functionality. If we just wanted to access the vectorstore directly, we can also do that.


```
index.vectorstore  

```

```
 <langchain.vectorstores.chroma.Chroma at 0x119aa5940>  

```
If we then want to access the VectorstoreRetriever, we can do that with:


```
index.vectorstore.as\_retriever()  

```

```
 VectorStoreRetriever(vectorstore=<langchain.vectorstores.chroma.Chroma object at 0x119aa5940>, search\_kwargs={})  

```
Walkthrough[​](#walkthrough ""Direct link to Walkthrough"")
---------------------------------------------------------

Okay, so what's actually going on? How is this index getting created?

A lot of the magic is being hid in this `VectorstoreIndexCreator`. What is this doing?

There are three main steps going on after the documents are loaded:

1. Splitting documents into chunks
2. Creating embeddings for each document
3. Storing documents and embeddings in a vectorstore

Let's walk through this in code


```
documents = loader.load()  

```
Next, we will split the documents into chunks.


```
from langchain.text\_splitter import CharacterTextSplitter  
text\_splitter = CharacterTextSplitter(chunk\_size=1000, chunk\_overlap=0)  
texts = text\_splitter.split\_documents(documents)  

```
We will then select which embeddings we want to use.


```
from langchain.embeddings import OpenAIEmbeddings  
embeddings = OpenAIEmbeddings()  

```
We now create the vectorstore to use as the index.


```
from langchain.vectorstores import Chroma  
db = Chroma.from\_documents(texts, embeddings)  

```

```
 Running Chroma using direct local API.  
 Using DuckDB in-memory for database. Data will be transient.  

```
So that's creating the index. Then, we expose this index in a retriever interface.


```
retriever = db.as\_retriever()  

```
Then, as before, we create a chain and use it to answer questions!


```
qa = RetrievalQA.from\_chain\_type(llm=OpenAI(), chain\_type=""stuff"", retriever=retriever)  

```

```
query = ""What did the president say about Ketanji Brown Jackson""  
qa.run(query)  

```

```
 "" The President said that Judge Ketanji Brown Jackson is one of the nation's top legal minds, a former top litigator in private practice, a former federal public defender, and from a family of public school educators and police officers. He said she is a consensus builder and has received a broad range of support from organizations such as the Fraternal Order of Police and former judges appointed by Democrats and Republicans.""  

```
`VectorstoreIndexCreator` is just a wrapper around all this logic. It is configurable in the text splitter it uses, the embeddings it uses, and the vectorstore it uses. For example, you can configure it as below:


```
index\_creator = VectorstoreIndexCreator(  
 vectorstore\_cls=Chroma,  
 embedding=OpenAIEmbeddings(),  
 text\_splitter=CharacterTextSplitter(chunk\_size=1000, chunk\_overlap=0)  
)  

```
Hopefully this highlights what is going on under the hood of `VectorstoreIndexCreator`. While we think it's important to have a simple way to create indexes, we also think it's important to understand what's going on under the hood.

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/retrievers/self_query/,"Self-querying
=============

A self-querying retriever is one that, as the name suggests, has the ability to query itself. Specifically, given any natural language query, the retriever uses a query-constructing LLM chain to write a structured query and then applies that structured query to it's underlying VectorStore. This allows the retriever to not only use the user-input query for semantic similarity comparison with the contents of stored documented, but to also extract filters from the user query on the metadata of stored documents and to execute those filters.

![](https://drive.google.com/uc?id=1OQUN-0MJcDUxmPXofgS7MqReEs720pqS)

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------

We'll use a Pinecone vector store in this example.

First we'll want to create a `Pinecone` VectorStore and seed it with some data. We've created a small demo set of documents that contain summaries of movies.

To use Pinecone, you to have `pinecone` package installed and you must have an API key and an Environment. Here are the [installation instructions](https://docs.pinecone.io/docs/quickstart).

NOTE: The self-query retriever requires you to have `lark` package installed.


```
# !pip install lark pinecone-client  

```

```
import os  
  
import pinecone  
  
  
pinecone.init(api\_key=os.environ[""PINECONE\_API\_KEY""], environment=os.environ[""PINECONE\_ENV""])  

```

```
from langchain.schema import Document  
from langchain.embeddings.openai import OpenAIEmbeddings  
from langchain.vectorstores import Pinecone  
  
embeddings = OpenAIEmbeddings()  
# create new index  
pinecone.create\_index(""langchain-self-retriever-demo"", dimension=1536)  

```

```
docs = [  
 Document(page\_content=""A bunch of scientists bring back dinosaurs and mayhem breaks loose"", metadata={""year"": 1993, ""rating"": 7.7, ""genre"": [""action"", ""science fiction""]}),  
 Document(page\_content=""Leo DiCaprio gets lost in a dream within a dream within a dream within a ..."", metadata={""year"": 2010, ""director"": ""Christopher Nolan"", ""rating"": 8.2}),  
 Document(page\_content=""A psychologist / detective gets lost in a series of dreams within dreams within dreams and Inception reused the idea"", metadata={""year"": 2006, ""director"": ""Satoshi Kon"", ""rating"": 8.6}),  
 Document(page\_content=""A bunch of normal-sized women are supremely wholesome and some men pine after them"", metadata={""year"": 2019, ""director"": ""Greta Gerwig"", ""rating"": 8.3}),  
 Document(page\_content=""Toys come alive and have a blast doing so"", metadata={""year"": 1995, ""genre"": ""animated""}),  
 Document(page\_content=""Three men walk into the Zone, three men walk out of the Zone"", metadata={""year"": 1979, ""rating"": 9.9, ""director"": ""Andrei Tarkovsky"", ""genre"": [""science fiction"", ""thriller""], ""rating"": 9.9})  
]  
vectorstore = Pinecone.from\_documents(  
 docs, embeddings, index\_name=""langchain-self-retriever-demo""  
)  

```
Creating our self-querying retriever[​](#creating-our-self-querying-retriever ""Direct link to Creating our self-querying retriever"")
------------------------------------------------------------------------------------------------------------------------------------

Now we can instantiate our retriever. To do this we'll need to provide some information upfront about the metadata fields that our documents support and a short description of the document contents.


```
from langchain.llms import OpenAI  
from langchain.retrievers.self\_query.base import SelfQueryRetriever  
from langchain.chains.query\_constructor.base import AttributeInfo  
  
metadata\_field\_info=[  
 AttributeInfo(  
 name=""genre"",  
 description=""The genre of the movie"",   
 type=""string or list[string]"",   
 ),  
 AttributeInfo(  
 name=""year"",  
 description=""The year the movie was released"",   
 type=""integer"",   
 ),  
 AttributeInfo(  
 name=""director"",  
 description=""The name of the movie director"",   
 type=""string"",   
 ),  
 AttributeInfo(  
 name=""rating"",  
 description=""A 1-10 rating for the movie"",  
 type=""float""  
 ),  
]  
document\_content\_description = ""Brief summary of a movie""  
llm = OpenAI(temperature=0)  
retriever = SelfQueryRetriever.from\_llm(llm, vectorstore, document\_content\_description, metadata\_field\_info, verbose=True)  

```
Testing it out[​](#testing-it-out ""Direct link to Testing it out"")
------------------------------------------------------------------

And now we can try actually using our retriever!


```
# This example only specifies a relevant query  
retriever.get\_relevant\_documents(""What are some movies about dinosaurs"")  

```

```
 query='dinosaur' filter=None  
  
  
 [Document(page\_content='A bunch of scientists bring back dinosaurs and mayhem breaks loose', metadata={'genre': ['action', 'science fiction'], 'rating': 7.7, 'year': 1993.0}),  
 Document(page\_content='Toys come alive and have a blast doing so', metadata={'genre': 'animated', 'year': 1995.0}),  
 Document(page\_content='A psychologist / detective gets lost in a series of dreams within dreams within dreams and Inception reused the idea', metadata={'director': 'Satoshi Kon', 'rating': 8.6, 'year': 2006.0}),  
 Document(page\_content='Leo DiCaprio gets lost in a dream within a dream within a dream within a ...', metadata={'director': 'Christopher Nolan', 'rating': 8.2, 'year': 2010.0})]  

```

```
# This example only specifies a filter  
retriever.get\_relevant\_documents(""I want to watch a movie rated higher than 8.5"")  

```

```
 query=' ' filter=Comparison(comparator=<Comparator.GT: 'gt'>, attribute='rating', value=8.5)  
  
  
 [Document(page\_content='A psychologist / detective gets lost in a series of dreams within dreams within dreams and Inception reused the idea', metadata={'director': 'Satoshi Kon', 'rating': 8.6, 'year': 2006.0}),  
 Document(page\_content='Three men walk into the Zone, three men walk out of the Zone', metadata={'director': 'Andrei Tarkovsky', 'genre': ['science fiction', 'thriller'], 'rating': 9.9, 'year': 1979.0})]  

```

```
# This example specifies a query and a filter  
retriever.get\_relevant\_documents(""Has Greta Gerwig directed any movies about women"")  

```

```
 query='women' filter=Comparison(comparator=<Comparator.EQ: 'eq'>, attribute='director', value='Greta Gerwig')  
  
  
 [Document(page\_content='A bunch of normal-sized women are supremely wholesome and some men pine after them', metadata={'director': 'Greta Gerwig', 'rating': 8.3, 'year': 2019.0})]  

```

```
# This example specifies a composite filter  
retriever.get\_relevant\_documents(""What's a highly rated (above 8.5) science fiction film?"")  

```

```
 query=' ' filter=Operation(operator=<Operator.AND: 'and'>, arguments=[Comparison(comparator=<Comparator.EQ: 'eq'>, attribute='genre', value='science fiction'), Comparison(comparator=<Comparator.GT: 'gt'>, attribute='rating', value=8.5)])  
  
  
 [Document(page\_content='Three men walk into the Zone, three men walk out of the Zone', metadata={'director': 'Andrei Tarkovsky', 'genre': ['science fiction', 'thriller'], 'rating': 9.9, 'year': 1979.0})]  

```

```
# This example specifies a query and composite filter  
retriever.get\_relevant\_documents(""What's a movie after 1990 but before 2005 that's all about toys, and preferably is animated"")  

```

```
 query='toys' filter=Operation(operator=<Operator.AND: 'and'>, arguments=[Comparison(comparator=<Comparator.GT: 'gt'>, attribute='year', value=1990.0), Comparison(comparator=<Comparator.LT: 'lt'>, attribute='year', value=2005.0), Comparison(comparator=<Comparator.EQ: 'eq'>, attribute='genre', value='animated')])  
  
  
 [Document(page\_content='Toys come alive and have a blast doing so', metadata={'genre': 'animated', 'year': 1995.0})]  

```
Filter k[​](#filter-k ""Direct link to Filter k"")
------------------------------------------------

We can also use the self query retriever to specify `k`: the number of documents to fetch.

We can do this by passing `enable_limit=True` to the constructor.


```
retriever = SelfQueryRetriever.from\_llm(  
 llm,   
 vectorstore,   
 document\_content\_description,   
 metadata\_field\_info,   
 enable\_limit=True,  
 verbose=True  
)  

```

```
# This example only specifies a relevant query  
retriever.get\_relevant\_documents(""What are two movies about dinosaurs"")  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/retrievers/time_weighted_vectorstore,"Time-weighted vector store retriever
====================================

This retriever uses a combination of semantic similarity and a time decay.

The algorithm for scoring them is:


```
semantic\_similarity + (1.0 - decay\_rate) ^ hours\_passed  

```
Notably, `hours_passed` refers to the hours passed since the object in the retriever **was last accessed**, not since it was created. This means that frequently accessed objects remain ""fresh.""


```
import faiss  
  
from datetime import datetime, timedelta  
from langchain.docstore import InMemoryDocstore  
from langchain.embeddings import OpenAIEmbeddings  
from langchain.retrievers import TimeWeightedVectorStoreRetriever  
from langchain.schema import Document  
from langchain.vectorstores import FAISS  

```
Low Decay Rate[​](#low-decay-rate ""Direct link to Low Decay Rate"")
------------------------------------------------------------------

A low `decay rate` (in this, to be extreme, we will set close to 0) means memories will be ""remembered"" for longer. A `decay rate` of 0 means memories never be forgotten, making this retriever equivalent to the vector lookup.


```
# Define your embedding model  
embeddings\_model = OpenAIEmbeddings()  
# Initialize the vectorstore as empty  
embedding\_size = 1536  
index = faiss.IndexFlatL2(embedding\_size)  
vectorstore = FAISS(embeddings\_model.embed\_query, index, InMemoryDocstore({}), {})  
retriever = TimeWeightedVectorStoreRetriever(vectorstore=vectorstore, decay\_rate=.0000000000000000000000001, k=1)  

```

```
yesterday = datetime.now() - timedelta(days=1)  
retriever.add\_documents([Document(page\_content=""hello world"", metadata={""last\_accessed\_at"": yesterday})])  
retriever.add\_documents([Document(page\_content=""hello foo"")])  

```

```
 ['d7f85756-2371-4bdf-9140-052780a0f9b3']  

```

```
# ""Hello World"" is returned first because it is most salient, and the decay rate is close to 0., meaning it's still recent enough  
retriever.get\_relevant\_documents(""hello world"")  

```

```
 [Document(page\_content='hello world', metadata={'last\_accessed\_at': datetime.datetime(2023, 5, 13, 21, 0, 27, 678341), 'created\_at': datetime.datetime(2023, 5, 13, 21, 0, 27, 279596), 'buffer\_idx': 0})]  

```
High Decay Rate[​](#high-decay-rate ""Direct link to High Decay Rate"")
---------------------------------------------------------------------

With a high `decay rate` (e.g., several 9's), the `recency score` quickly goes to 0! If you set this all the way to 1, `recency` is 0 for all objects, once again making this equivalent to a vector lookup.


```
# Define your embedding model  
embeddings\_model = OpenAIEmbeddings()  
# Initialize the vectorstore as empty  
embedding\_size = 1536  
index = faiss.IndexFlatL2(embedding\_size)  
vectorstore = FAISS(embeddings\_model.embed\_query, index, InMemoryDocstore({}), {})  
retriever = TimeWeightedVectorStoreRetriever(vectorstore=vectorstore, decay\_rate=.999, k=1)  

```

```
yesterday = datetime.now() - timedelta(days=1)  
retriever.add\_documents([Document(page\_content=""hello world"", metadata={""last\_accessed\_at"": yesterday})])  
retriever.add\_documents([Document(page\_content=""hello foo"")])  

```

```
 ['40011466-5bbe-4101-bfd1-e22e7f505de2']  

```

```
# ""Hello Foo"" is returned first because ""hello world"" is mostly forgotten  
retriever.get\_relevant\_documents(""hello world"")  

```

```
 [Document(page\_content='hello foo', metadata={'last\_accessed\_at': datetime.datetime(2023, 4, 16, 22, 9, 2, 494798), 'created\_at': datetime.datetime(2023, 4, 16, 22, 9, 2, 178722), 'buffer\_idx': 1})]  

```
Virtual Time[​](#virtual-time ""Direct link to Virtual Time"")
------------------------------------------------------------

Using some utils in LangChain, you can mock out the time component


```
from langchain.utils import mock\_now  
import datetime  

```

```
# Notice the last access time is that date time  
with mock\_now(datetime.datetime(2011, 2, 3, 10, 11)):  
 print(retriever.get\_relevant\_documents(""hello world""))  

```

```
 [Document(page\_content='hello world', metadata={'last\_accessed\_at': MockDateTime(2011, 2, 3, 10, 11), 'created\_at': datetime.datetime(2023, 5, 13, 21, 0, 27, 279596), 'buffer\_idx': 0})]  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/retrievers/vectorstore,"Vector store-backed retriever
=============================

A vector store retriever is a retriever that uses a vector store to retrieve documents. It is a lightweight wrapper around the Vector Store class to make it conform to the Retriever interface.
It uses the search methods implemented by a vector store, like similarity search and MMR, to query the texts in the vector store.

Once you construct a Vector store, it's very easy to construct a retriever. Let's walk through an example.


```
from langchain.document\_loaders import TextLoader  
loader = TextLoader('../../../state\_of\_the\_union.txt')  

```

```
from langchain.text\_splitter import CharacterTextSplitter  
from langchain.vectorstores import FAISS  
from langchain.embeddings import OpenAIEmbeddings  
  
documents = loader.load()  
text\_splitter = CharacterTextSplitter(chunk\_size=1000, chunk\_overlap=0)  
texts = text\_splitter.split\_documents(documents)  
embeddings = OpenAIEmbeddings()  
db = FAISS.from\_documents(texts, embeddings)  

```

```
 Exiting: Cleaning up .chroma directory  

```

```
retriever = db.as\_retriever()  

```

```
docs = retriever.get\_relevant\_documents(""what did he say about ketanji brown jackson"")  

```
Maximum Marginal Relevance Retrieval[​](#maximum-marginal-relevance-retrieval ""Direct link to Maximum Marginal Relevance Retrieval"")
------------------------------------------------------------------------------------------------------------------------------------

By default, the vectorstore retriever uses similarity search. If the underlying vectorstore support maximum marginal relevance search, you can specify that as the search type.


```
retriever = db.as\_retriever(search\_type=""mmr"")  

```

```
docs = retriever.get\_relevant\_documents(""what did he say about ketanji brown jackson"")  

```
Similarity Score Threshold Retrieval[​](#similarity-score-threshold-retrieval ""Direct link to Similarity Score Threshold Retrieval"")
------------------------------------------------------------------------------------------------------------------------------------

You can also a retrieval method that sets a similarity score threshold and only returns documents with a score above that threshold


```
retriever = db.as\_retriever(search\_type=""similarity\_score\_threshold"", search\_kwargs={""score\_threshold"": .5})  

```

```
docs = retriever.get\_relevant\_documents(""what did he say about ketanji brown jackson"")  

```
Specifying top k[​](#specifying-top-k ""Direct link to Specifying top k"")
------------------------------------------------------------------------

You can also specify search kwargs like `k` to use when doing retrieval.


```
retriever = db.as\_retriever(search\_kwargs={""k"": 1})  

```

```
docs = retriever.get\_relevant\_documents(""what did he say about ketanji brown jackson"")  

```

```
len(docs)  

```

```
 1  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/text_embedding/,"Text embedding models
=====================

infoHead to [Integrations](/docs/integrations/text_embedding/) for documentation on built-in integrations with text embedding model providers.

The Embeddings class is a class designed for interfacing with text embedding models. There are lots of embedding model providers (OpenAI, Cohere, Hugging Face, etc) - this class is designed to provide a standard interface for all of them.

Embeddings create a vector representation of a piece of text. This is useful because it means we can think about text in the vector space, and do things like semantic search where we look for pieces of text that are most similar in the vector space.

The base Embeddings class in LangChain exposes two methods: one for embedding documents and one for embedding a query. The former takes as input multiple texts, while the latter takes a single text. The reason for having these as two separate methods is that some embedding providers have different embedding methods for documents (to be searched over) vs queries (the search query itself).

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------

### Setup[​](#setup ""Direct link to Setup"")

To start we'll need to install the OpenAI Python package:


```
pip install openai  

```
Accessing the API requires an API key, which you can get by creating an account and heading [here](https://platform.openai.com/account/api-keys). Once we have a key we'll want to set it as an environment variable by running:


```
export OPENAI\_API\_KEY=""...""  

```
If you'd prefer not to set an environment variable you can pass the key in directly via the `openai_api_key` named parameter when initiating the OpenAI LLM class:


```
from langchain.embeddings import OpenAIEmbeddings  
  
embeddings\_model = OpenAIEmbeddings(openai\_api\_key=""..."")  

```
otherwise you can initialize without any params:


```
from langchain.embeddings import OpenAIEmbeddings  
  
embeddings\_model = OpenAIEmbeddings()  

```
### `embed_documents`[​](#embed_documents ""Direct link to embed_documents"")

#### Embed list of texts[​](#embed-list-of-texts ""Direct link to Embed list of texts"")


```
embeddings = embeddings\_model.embed\_documents(  
 [  
 ""Hi there!"",  
 ""Oh, hello!"",  
 ""What's your name?"",  
 ""My friends call me World"",  
 ""Hello World!""  
 ]  
)  
len(embeddings), len(embeddings[0])  

```

```
(5, 1536)  

```
### `embed_query`[​](#embed_query ""Direct link to embed_query"")

#### Embed single query[​](#embed-single-query ""Direct link to Embed single query"")

Embed a single piece of text for the purpose of comparing to other embedded pieces of texts.


```
embedded\_query = embeddings\_model.embed\_query(""What was the name mentioned in the conversation?"")  
embedded\_query[:5]  

```

```
[0.0053587136790156364,  
 -0.0004999046213924885,  
 0.038883671164512634,  
 -0.003001077566295862,  
 -0.00900818221271038]  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/data_connection/vectorstores/,"Vector stores
=============

infoHead to [Integrations](/docs/integrations/vectorstores/) for documentation on built-in integrations with 3rd-party vector stores.

One of the most common ways to store and search over unstructured data is to embed it and store the resulting embedding
vectors, and then at query time to embed the unstructured query and retrieve the embedding vectors that are
'most similar' to the embedded query. A vector store takes care of storing embedded data and performing vector search
for you.

![vector store diagram](/assets/images/vector_stores-9dc1ecb68c4cb446df110764c9cc07e0.jpg)

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------

This walkthrough showcases basic functionality related to VectorStores. A key part of working with vector stores is creating the vector to put in them, which is usually created via embeddings. Therefore, it is recommended that you familiarize yourself with the [text embedding model](/docs/modules/data_connection/text_embedding/) interfaces before diving into this.

There are many great vector store options, here are a few that are free, open-source, and run entirely on your local machine. Review all integrations for many great hosted offerings.

* Chroma
* FAISS
* Lance

This walkthrough uses the `chroma` vector database, which runs on your local machine as a library.


```
pip install chromadb  

```
We want to use OpenAIEmbeddings so we have to get the OpenAI API Key.


```
import os  
import getpass  
  
os.environ['OPENAI\_API\_KEY'] = getpass.getpass('OpenAI API Key:')  

```

```
from langchain.document\_loaders import TextLoader  
from langchain.embeddings.openai import OpenAIEmbeddings  
from langchain.text\_splitter import CharacterTextSplitter  
from langchain.vectorstores import Chroma  
  
# Load the document, split it into chunks, embed each chunk and load it into the vector store.  
raw\_documents = TextLoader('../../../state\_of\_the\_union.txt').load()  
text\_splitter = CharacterTextSplitter(chunk\_size=1000, chunk\_overlap=0)  
documents = text\_splitter.split\_documents(raw\_documents)  
db = Chroma.from\_documents(documents, OpenAIEmbeddings())  

```
This walkthrough uses the `FAISS` vector database, which makes use of the Facebook AI Similarity Search (FAISS) library.


```
pip install faiss-cpu  

```
We want to use OpenAIEmbeddings so we have to get the OpenAI API Key.


```
import os  
import getpass  
  
os.environ['OPENAI\_API\_KEY'] = getpass.getpass('OpenAI API Key:')  

```

```
from langchain.document\_loaders import TextLoader  
from langchain.embeddings.openai import OpenAIEmbeddings  
from langchain.text\_splitter import CharacterTextSplitter  
from langchain.vectorstores import FAISS  
  
# Load the document, split it into chunks, embed each chunk and load it into the vector store.  
raw\_documents = TextLoader('../../../state\_of\_the\_union.txt').load()  
text\_splitter = CharacterTextSplitter(chunk\_size=1000, chunk\_overlap=0)  
documents = text\_splitter.split\_documents(raw\_documents)  
db = FAISS.from\_documents(documents, OpenAIEmbeddings())  

```
This notebook shows how to use functionality related to the LanceDB vector database based on the Lance data format.


```
pip install lancedb  

```
We want to use OpenAIEmbeddings so we have to get the OpenAI API Key.


```
import os  
import getpass  
  
os.environ['OPENAI\_API\_KEY'] = getpass.getpass('OpenAI API Key:')  

```

```
from langchain.document\_loaders import TextLoader  
from langchain.embeddings.openai import OpenAIEmbeddings  
from langchain.text\_splitter import CharacterTextSplitter  
from langchain.vectorstores import LanceDB  
  
import lancedb  
  
db = lancedb.connect(""/tmp/lancedb"")  
table = db.create\_table(  
 ""my\_table"",  
 data=[  
 {  
 ""vector"": embeddings.embed\_query(""Hello World""),  
 ""text"": ""Hello World"",  
 ""id"": ""1"",  
 }  
 ],  
 mode=""overwrite"",  
)  
  
# Load the document, split it into chunks, embed each chunk and load it into the vector store.  
raw\_documents = TextLoader('../../../state\_of\_the\_union.txt').load()  
text\_splitter = CharacterTextSplitter(chunk\_size=1000, chunk\_overlap=0)  
documents = text\_splitter.split\_documents(raw\_documents)  
db = LanceDB.from\_documents(documents, OpenAIEmbeddings(), connection=table)  

```
### Similarity search[​](#similarity-search ""Direct link to Similarity search"")


```
query = ""What did the president say about Ketanji Brown Jackson""  
docs = db.similarity\_search(query)  
print(docs[0].page\_content)  

```

```
 Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections.  
  
 Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service.  
  
 One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.  
  
 And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.  

```
### Similarity search by vector[​](#similarity-search-by-vector ""Direct link to Similarity search by vector"")

It is also possible to do a search for documents similar to a given embedding vector using `similarity_search_by_vector` which accepts an embedding vector as a parameter instead of a string.


```
embedding\_vector = OpenAIEmbeddings().embed\_query(query)  
docs = db.similarity\_search\_by\_vector(embedding\_vector)  
print(docs[0].page\_content)  

```
The query is the same, and so the result is also the same.


```
 Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections.  
  
 Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service.  
  
 One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.  
  
 And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.  

```
Asynchronous operations[​](#asynchronous-operations ""Direct link to Asynchronous operations"")
---------------------------------------------------------------------------------------------

Vector stores are usually run as a separate service that requires some IO operations, and therefore they might be called asynchronously. That gives performance benefits as you don't waste time waiting for responses from external services. That might also be important if you work with an asynchronous framework, such as [FastAPI](https://fastapi.tiangolo.com/).

Langchain supports async operation on vector stores. All the methods might be called using their async counterparts, with the prefix `a`, meaning `async`.

`Qdrant` is a vector store, which supports all the async operations, thus it will be used in this walkthrough.


```
pip install qdrant-client  

```

```
from langchain.vectorstores import Qdrant  

```
### Create a vector store asynchronously[​](#create-a-vector-store-asynchronously ""Direct link to Create a vector store asynchronously"")


```
db = await Qdrant.afrom\_documents(documents, embeddings, ""http://localhost:6333"")  

```
### Similarity search[​](#similarity-search ""Direct link to Similarity search"")


```
query = ""What did the president say about Ketanji Brown Jackson""  
docs = await db.asimilarity\_search(query)  
print(docs[0].page\_content)  

```

```
 Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections.  
  
 Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service.  
  
 One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.  
  
 And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.  

```
### Similarity search by vector[​](#similarity-search-by-vector ""Direct link to Similarity search by vector"")


```
embedding\_vector = embeddings.embed\_query(query)  
docs = await db.asimilarity\_search\_by\_vector(embedding\_vector)  

```
Maximum marginal relevance search (MMR)[​](#maximum-marginal-relevance-search-mmr ""Direct link to Maximum marginal relevance search (MMR)"")
-------------------------------------------------------------------------------------------------------------------------------------------

Maximal marginal relevance optimizes for similarity to query AND diversity among selected documents. It is also supported in async API.


```
query = ""What did the president say about Ketanji Brown Jackson""  
found\_docs = await qdrant.amax\_marginal\_relevance\_search(query, k=2, fetch\_k=10)  
for i, doc in enumerate(found\_docs):  
 print(f""{i + 1}."", doc.page\_content, ""\n"")  

```

```
1. Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections.  
  
Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service.  
  
One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.  
  
And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.  
  
2. We can’t change how divided we’ve been. But we can change how we move forward—on COVID-19 and other issues we must face together.  
  
I recently visited the New York City Police Department days after the funerals of Officer Wilbert Mora and his partner, Officer Jason Rivera.  
  
They were responding to a 9-1-1 call when a man shot and killed them with a stolen gun.  
  
Officer Mora was 27 years old.  
  
Officer Rivera was 22.  
  
Both Dominican Americans who’d grown up on the same streets they later chose to patrol as police officers.  
  
I spoke with their families and told them that we are forever in debt for their sacrifice, and we will carry on their mission to restore the trust and safety every community deserves.  
  
I’ve worked on these issues a long time.  
  
I know what works: Investing in crime preventionand community police officers who’ll walk the beat, who’ll know the neighborhood, and who can restore trust and safety.  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/,"Modules
=======

LangChain provides standard, extendable interfaces and external integrations for the following modules, listed from least to most complex:

#### [Model I/O](/docs/modules/model_io/)[​](#model-io ""Direct link to model-io"")

Interface with language models

#### [Data connection](/docs/modules/data_connection/)[​](#data-connection ""Direct link to data-connection"")

Interface with application-specific data

#### [Chains](/docs/modules/chains/)[​](#chains ""Direct link to chains"")

Construct sequences of calls

#### [Agents](/docs/modules/agents/)[​](#agents ""Direct link to agents"")

Let chains choose which tools to use given high-level directives

#### [Memory](/docs/modules/memory/)[​](#memory ""Direct link to memory"")

Persist application state between runs of a chain

#### [Callbacks](/docs/modules/callbacks/)[​](#callbacks ""Direct link to callbacks"")

Log and stream intermediate steps of any chain

#### [Evaluation](/docs/modules/evaluation/)[​](#evaluation ""Direct link to evaluation"")

Evaluate the performance of a chain.

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/memory/chat_messages/,"Chat Messages
=============

infoHead to [Integrations](/docs/integrations/memory/) for documentation on built-in memory integrations with 3rd-party databases and tools.

One of the core utility classes underpinning most (if not all) memory modules is the `ChatMessageHistory` class.
This is a super lightweight wrapper which exposes convenience methods for saving Human messages, AI messages, and then fetching them all.

You may want to use this class directly if you are managing memory outside of a chain.


```
from langchain.memory import ChatMessageHistory  
  
history = ChatMessageHistory()  
  
history.add\_user\_message(""hi!"")  
  
history.add\_ai\_message(""whats up?"")  

```

```
history.messages  

```

```
 [HumanMessage(content='hi!', additional\_kwargs={}),  
 AIMessage(content='whats up?', additional\_kwargs={})]  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/memory/,"Memory
======

Most LLM applications have a conversational interface. An essential component of a conversation is being able to refer to information introduced earlier in the conversation.
At bare minimum, a conversational system should be able to access some window of past messages directly.
A more complex system will need to have a world model that it is constantly updating, which allows it to do things like maintain information about entities and their relationships.

We call this ability to store information about past interactions ""memory"".
LangChain provides a lot of utilities for adding memory to a system.
These utilities can be used by themselves or incorporated seamlessly into a chain.

A memory system needs to support two basic actions: reading and writing.
Recall that every chain defines some core execution logic that expects certain inputs.
Some of these inputs come directly from the user, but some of these inputs can come from memory.
A chain will interact with its memory system twice in a given run.

1. AFTER receiving the initial user inputs but BEFORE executing the core logic, a chain will READ from its memory system and augment the user inputs.
2. AFTER executing the core logic but BEFORE returning the answer, a chain will WRITE the inputs and outputs of the current run to memory, so that they can be referred to in future runs.

![memory-diagram](/assets/images/memory_diagram-0627c68230aa438f9b5419064d63cbbc.png)

Building memory into a system[​](#building-memory-into-a-system ""Direct link to Building memory into a system"")
---------------------------------------------------------------------------------------------------------------

The two core design decisions in any memory system are:

* How state is stored
* How state is queried

### Storing: List of chat messages[​](#storing-list-of-chat-messages ""Direct link to Storing: List of chat messages"")

Underlying any memory is a history of all chat interactions.
Even if these are not all used directly, they need to be stored in some form.
One of the key parts of the LangChain memory module is a series of integrations for storing these chat messages,
from in-memory lists to persistent databases.

* [Chat message storage](/docs/modules/memory/chat_messages/): How to work with Chat Messages, and the various integrations offered

### Querying: Data structures and algorithms on top of chat messages[​](#querying-data-structures-and-algorithms-on-top-of-chat-messages ""Direct link to Querying: Data structures and algorithms on top of chat messages"")

Keeping a list of chat messages is fairly straight-forward.
What is less straight-forward are the data structures and algorithms built on top of chat messages that serve a view of those messages that is most useful.

A very simply memory system might just return the most recent messages each run. A slightly more complex memory system might return a succinct summary of the past K messages.
An even more sophisticated system might extract entities from stored messages and only return information about entities referenced in the current run.

Each application can have different requirements for how memory is queried. The memory module should make it easy to both get started with simple memory systems and write your own custom systems if needed.

* [Memory types](/docs/modules/memory/types/): The various data structures and algorithms that make up the memory types LangChain supports

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------

Let's take a look at what Memory actually looks like in LangChain.
Here we'll cover the basics of interacting with an arbitrary memory class.

Let's take a look at how to use ConversationBufferMemory in chains.
ConversationBufferMemory is an extremely simple form of memory that just keeps a list of chat messages in a buffer
and passes those into the prompt template.


```
from langchain.memory import ConversationBufferMemory  
  
memory = ConversationBufferMemory()  
memory.chat\_memory.add\_user\_message(""hi!"")  
memory.chat\_memory.add\_ai\_message(""whats up?"")  

```
When using memory in a chain, there are a few key concepts to understand.
Note that here we cover general concepts that are useful for most types of memory.
Each individual memory type may very well have its own parameters and concepts that are necessary to understand.

### What variables get returned from memory[​](#what-variables-get-returned-from-memory ""Direct link to What variables get returned from memory"")

Before going into the chain, various variables are read from memory.
This have specific names which need to align with the variables the chain expects.
You can see what these variables are by calling `memory.load_memory_variables({})`.
Note that the empty dictionary that we pass in is just a placeholder for real variables.
If the memory type you are using is dependent upon the input variables, you may need to pass some in.


```
memory.load\_memory\_variables({})  

```

```
 {'history': ""Human: hi!\nAI: whats up?""}  

```
In this case, you can see that `load_memory_variables` returns a single key, `history`.
This means that your chain (and likely your prompt) should expect and input named `history`.
You can usually control this variable through parameters on the memory class.
For example, if you want the memory variables to be returned in the key `chat_history` you can do:


```
memory = ConversationBufferMemory(memory\_key=""chat\_history"")  
memory.chat\_memory.add\_user\_message(""hi!"")  
memory.chat\_memory.add\_ai\_message(""whats up?"")  

```

```
 {'chat\_history': ""Human: hi!\nAI: whats up?""}  

```
The parameter name to control these keys may vary per memory type, but it's important to understand that (1) this is controllable, (2) how to control it.

### Whether memory is a string or a list of messages[​](#whether-memory-is-a-string-or-a-list-of-messages ""Direct link to Whether memory is a string or a list of messages"")

One of the most common types of memory involves returning a list of chat messages.
These can either be returned as a single string, all concatenated together (useful when they will be passed in LLMs)
or a list of ChatMessages (useful when passed into ChatModels).

By default, they are returned as a single string.
In order to return as a list of messages, you can set `return_messages=True`


```
memory = ConversationBufferMemory(return\_messages=True)  
memory.chat\_memory.add\_user\_message(""hi!"")  
memory.chat\_memory.add\_ai\_message(""whats up?"")  

```

```
 {'history': [HumanMessage(content='hi!', additional\_kwargs={}, example=False),  
 AIMessage(content='whats up?', additional\_kwargs={}, example=False)]}  

```
### What keys are saved to memory[​](#what-keys-are-saved-to-memory ""Direct link to What keys are saved to memory"")

Often times chains take in or return multiple input/output keys.
In these cases, how can we know which keys we want to save to the chat message history?
This is generally controllable by `input_key` and `output_key` parameters on the memory types.
These default to None - and if there is only one input/output key it is known to just use that.
However, if there are multiple input/output keys then you MUST specify the name of which one to use

### End to end example[​](#end-to-end-example ""Direct link to End to end example"")

Finally, let's take a look at using this in a chain.
We'll use an LLMChain, and show working with both an LLM and a ChatModel.

#### Using an LLM[​](#using-an-llm ""Direct link to Using an LLM"")


```
from langchain.llms import OpenAI  
from langchain.prompts import PromptTemplate  
from langchain.chains import LLMChain  
from langchain.memory import ConversationBufferMemory  
  
  
llm = OpenAI(temperature=0)  
# Notice that ""chat\_history"" is present in the prompt template  
template = """"""You are a nice chatbot having a conversation with a human.  
  
Previous conversation:  
{chat\_history}  
  
New human question: {question}  
Response:""""""  
prompt = PromptTemplate.from\_template(template)  
# Notice that we need to align the `memory\_key`  
memory = ConversationBufferMemory(memory\_key=""chat\_history"")  
conversation = LLMChain(  
 llm=llm,  
 prompt=prompt,  
 verbose=True,  
 memory=memory  
)  

```

```
# Notice that we just pass in the `question` variables - `chat\_history` gets populated by memory  
conversation({""question"": ""hi""})  

```
#### Using a ChatModel[​](#using-a-chatmodel ""Direct link to Using a ChatModel"")


```
from langchain.chat\_models import ChatOpenAI  
from langchain.prompts import (  
 ChatPromptTemplate,  
 MessagesPlaceholder,  
 SystemMessagePromptTemplate,  
 HumanMessagePromptTemplate,  
)  
from langchain.chains import LLMChain  
from langchain.memory import ConversationBufferMemory  
  
  
llm = ChatOpenAI()  
prompt = ChatPromptTemplate(  
 messages=[  
 SystemMessagePromptTemplate.from\_template(  
 ""You are a nice chatbot having a conversation with a human.""  
 ),  
 # The `variable\_name` here is what must align with memory  
 MessagesPlaceholder(variable\_name=""chat\_history""),  
 HumanMessagePromptTemplate.from\_template(""{question}"")  
 ]  
)  
# Notice that we `return\_messages=True` to fit into the MessagesPlaceholder  
# Notice that `""chat\_history""` aligns with the MessagesPlaceholder name.  
memory = ConversationBufferMemory(memory\_key=""chat\_history"", return\_messages=True)  
conversation = LLMChain(  
 llm=llm,  
 prompt=prompt,  
 verbose=True,  
 memory=memory  
)  

```

```
# Notice that we just pass in the `question` variables - `chat\_history` gets populated by memory  
conversation({""question"": ""hi""})  

```
Next steps[​](#next-steps ""Direct link to Next steps"")
------------------------------------------------------

And that's it for getting started!
Please see the other sections for walkthroughs of more advanced topics,
like custom memory, multiple memories, and more.

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/memory/types/buffer,"Conversation buffer memory
==========================

This notebook shows how to use `ConversationBufferMemory`. This memory allows for storing of messages and then extracts the messages in a variable.

We can first extract it as a string.


```
from langchain.memory import ConversationBufferMemory  

```

```
memory = ConversationBufferMemory()  
memory.save\_context({""input"": ""hi""}, {""output"": ""whats up""})  

```

```
memory.load\_memory\_variables({})  

```

```
 {'history': 'Human: hi\nAI: whats up'}  

```
We can also get the history as a list of messages (this is useful if you are using this with a chat model).


```
memory = ConversationBufferMemory(return\_messages=True)  
memory.save\_context({""input"": ""hi""}, {""output"": ""whats up""})  

```

```
memory.load\_memory\_variables({})  

```

```
 {'history': [HumanMessage(content='hi', additional\_kwargs={}),  
 AIMessage(content='whats up', additional\_kwargs={})]}  

```
Using in a chain[​](#using-in-a-chain ""Direct link to Using in a chain"")
------------------------------------------------------------------------

Finally, let's take a look at using this in a chain (setting `verbose=True` so we can see the prompt).


```
from langchain.llms import OpenAI  
from langchain.chains import ConversationChain  
  
  
llm = OpenAI(temperature=0)  
conversation = ConversationChain(  
 llm=llm,   
 verbose=True,   
 memory=ConversationBufferMemory()  
)  

```

```
conversation.predict(input=""Hi there!"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
   
 Current conversation:  
   
 Human: Hi there!  
 AI:  
   
 > Finished chain.  
  
  
  
  
  
 "" Hi there! It's nice to meet you. How can I help you today?""  

```

```
conversation.predict(input=""I'm doing well! Just having a conversation with an AI."")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
   
 Current conversation:  
 Human: Hi there!  
 AI: Hi there! It's nice to meet you. How can I help you today?  
 Human: I'm doing well! Just having a conversation with an AI.  
 AI:  
   
 > Finished chain.  
  
  
  
  
  
 "" That's great! It's always nice to have a conversation with someone new. What would you like to talk about?""  

```

```
conversation.predict(input=""Tell me about yourself."")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
   
 Current conversation:  
 Human: Hi there!  
 AI: Hi there! It's nice to meet you. How can I help you today?  
 Human: I'm doing well! Just having a conversation with an AI.  
 AI: That's great! It's always nice to have a conversation with someone new. What would you like to talk about?  
 Human: Tell me about yourself.  
 AI:  
   
 > Finished chain.  
  
  
  
  
  
 "" Sure! I'm an AI created to help people with their everyday tasks. I'm programmed to understand natural language and provide helpful information. I'm also constantly learning and updating my knowledge base so I can provide more accurate and helpful answers.""  

```
And that's it for the getting started! There are plenty of different types of memory, check out our examples to see them all

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/memory/types/buffer_window,"Conversation buffer window memory
=================================

`ConversationBufferWindowMemory` keeps a list of the interactions of the conversation over time. It only uses the last K interactions. This can be useful for keeping a sliding window of the most recent interactions, so the buffer does not get too large

Let's first explore the basic functionality of this type of memory.


```
from langchain.memory import ConversationBufferWindowMemory  

```

```
memory = ConversationBufferWindowMemory( k=1)  
memory.save\_context({""input"": ""hi""}, {""output"": ""whats up""})  
memory.save\_context({""input"": ""not much you""}, {""output"": ""not much""})  

```

```
memory.load\_memory\_variables({})  

```

```
 {'history': 'Human: not much you\nAI: not much'}  

```
We can also get the history as a list of messages (this is useful if you are using this with a chat model).


```
memory = ConversationBufferWindowMemory( k=1, return\_messages=True)  
memory.save\_context({""input"": ""hi""}, {""output"": ""whats up""})  
memory.save\_context({""input"": ""not much you""}, {""output"": ""not much""})  

```

```
memory.load\_memory\_variables({})  

```

```
 {'history': [HumanMessage(content='not much you', additional\_kwargs={}),  
 AIMessage(content='not much', additional\_kwargs={})]}  

```
Using in a chain[​](#using-in-a-chain ""Direct link to Using in a chain"")
------------------------------------------------------------------------

Let's walk through an example, again setting `verbose=True` so we can see the prompt.


```
from langchain.llms import OpenAI  
from langchain.chains import ConversationChain  
conversation\_with\_summary = ConversationChain(  
 llm=OpenAI(temperature=0),   
 # We set a low k=2, to only keep the last 2 interactions in memory  
 memory=ConversationBufferWindowMemory(k=2),   
 verbose=True  
)  
conversation\_with\_summary.predict(input=""Hi, what's up?"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
   
 Current conversation:  
   
 Human: Hi, what's up?  
 AI:  
   
 > Finished chain.  
  
  
  
  
  
 "" Hi there! I'm doing great. I'm currently helping a customer with a technical issue. How about you?""  

```

```
conversation\_with\_summary.predict(input=""What's their issues?"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
   
 Current conversation:  
 Human: Hi, what's up?  
 AI: Hi there! I'm doing great. I'm currently helping a customer with a technical issue. How about you?  
 Human: What's their issues?  
 AI:  
   
 > Finished chain.  
  
  
  
  
  
 "" The customer is having trouble connecting to their Wi-Fi network. I'm helping them troubleshoot the issue and get them connected.""  

```

```
conversation\_with\_summary.predict(input=""Is it going well?"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
   
 Current conversation:  
 Human: Hi, what's up?  
 AI: Hi there! I'm doing great. I'm currently helping a customer with a technical issue. How about you?  
 Human: What's their issues?  
 AI: The customer is having trouble connecting to their Wi-Fi network. I'm helping them troubleshoot the issue and get them connected.  
 Human: Is it going well?  
 AI:  
   
 > Finished chain.  
  
  
  
  
  
 "" Yes, it's going well so far. We've already identified the problem and are now working on a solution.""  

```

```
# Notice here that the first interaction does not appear.  
conversation\_with\_summary.predict(input=""What's the solution?"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
   
 Current conversation:  
 Human: What's their issues?  
 AI: The customer is having trouble connecting to their Wi-Fi network. I'm helping them troubleshoot the issue and get them connected.  
 Human: Is it going well?  
 AI: Yes, it's going well so far. We've already identified the problem and are now working on a solution.  
 Human: What's the solution?  
 AI:  
   
 > Finished chain.  
  
  
  
  
  
 "" The solution is to reset the router and reconfigure the settings. We're currently in the process of doing that.""  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/memory/types/entity_summary_memory,"Entity memory
=============

Entity Memory remembers given facts about specific entities in a conversation. It extracts information on entities (using an LLM) and builds up its knowledge about that entity over time (also using an LLM).

Let's first walk through using this functionality.


```
from langchain.llms import OpenAI  
from langchain.memory import ConversationEntityMemory  
llm = OpenAI(temperature=0)  

```

```
memory = ConversationEntityMemory(llm=llm)  
\_input = {""input"": ""Deven & Sam are working on a hackathon project""}  
memory.load\_memory\_variables(\_input)  
memory.save\_context(  
 \_input,  
 {""output"": "" That sounds like a great project! What kind of project are they working on?""}  
)  

```

```
memory.load\_memory\_variables({""input"": 'who is Sam'})  

```

```
 {'history': 'Human: Deven & Sam are working on a hackathon project\nAI: That sounds like a great project! What kind of project are they working on?',  
 'entities': {'Sam': 'Sam is working on a hackathon project with Deven.'}}  

```

```
memory = ConversationEntityMemory(llm=llm, return\_messages=True)  
\_input = {""input"": ""Deven & Sam are working on a hackathon project""}  
memory.load\_memory\_variables(\_input)  
memory.save\_context(  
 \_input,  
 {""output"": "" That sounds like a great project! What kind of project are they working on?""}  
)  

```

```
memory.load\_memory\_variables({""input"": 'who is Sam'})  

```

```
 {'history': [HumanMessage(content='Deven & Sam are working on a hackathon project', additional\_kwargs={}),  
 AIMessage(content=' That sounds like a great project! What kind of project are they working on?', additional\_kwargs={})],  
 'entities': {'Sam': 'Sam is working on a hackathon project with Deven.'}}  

```
Using in a chain[​](#using-in-a-chain ""Direct link to Using in a chain"")
------------------------------------------------------------------------

Let's now use it in a chain!


```
from langchain.chains import ConversationChain  
from langchain.memory import ConversationEntityMemory  
from langchain.memory.prompt import ENTITY\_MEMORY\_CONVERSATION\_TEMPLATE  
from pydantic import BaseModel  
from typing import List, Dict, Any  

```

```
conversation = ConversationChain(  
 llm=llm,   
 verbose=True,  
 prompt=ENTITY\_MEMORY\_CONVERSATION\_TEMPLATE,  
 memory=ConversationEntityMemory(llm=llm)  
)  

```

```
conversation.predict(input=""Deven & Sam are working on a hackathon project"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 You are an assistant to a human, powered by a large language model trained by OpenAI.  
   
 You are designed to be able to assist with a wide range of tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. As a language model, you are able to generate human-like text based on the input you receive, allowing you to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.  
   
 You are constantly learning and improving, and your capabilities are constantly evolving. You are able to process and understand large amounts of text, and can use this knowledge to provide accurate and informative responses to a wide range of questions. You have access to some personalized information provided by the human in the Context section below. Additionally, you are able to generate your own text based on the input you receive, allowing you to engage in discussions and provide explanations and descriptions on a wide range of topics.  
   
 Overall, you are a powerful tool that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. Whether the human needs help with a specific question or just wants to have a conversation about a particular topic, you are here to assist.  
   
 Context:  
 {'Deven': 'Deven is working on a hackathon project with Sam.', 'Sam': 'Sam is working on a hackathon project with Deven.'}  
   
 Current conversation:  
   
 Last line:  
 Human: Deven & Sam are working on a hackathon project  
 You:  
   
 > Finished chain.  
  
  
  
  
  
 ' That sounds like a great project! What kind of project are they working on?'  

```

```
conversation.memory.entity\_store.store  

```

```
 {'Deven': 'Deven is working on a hackathon project with Sam, which they are entering into a hackathon.',  
 'Sam': 'Sam is working on a hackathon project with Deven.'}  

```

```
conversation.predict(input=""They are trying to add more complex memory structures to Langchain"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 You are an assistant to a human, powered by a large language model trained by OpenAI.  
   
 You are designed to be able to assist with a wide range of tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. As a language model, you are able to generate human-like text based on the input you receive, allowing you to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.  
   
 You are constantly learning and improving, and your capabilities are constantly evolving. You are able to process and understand large amounts of text, and can use this knowledge to provide accurate and informative responses to a wide range of questions. You have access to some personalized information provided by the human in the Context section below. Additionally, you are able to generate your own text based on the input you receive, allowing you to engage in discussions and provide explanations and descriptions on a wide range of topics.  
   
 Overall, you are a powerful tool that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. Whether the human needs help with a specific question or just wants to have a conversation about a particular topic, you are here to assist.  
   
 Context:  
 {'Deven': 'Deven is working on a hackathon project with Sam, which they are entering into a hackathon.', 'Sam': 'Sam is working on a hackathon project with Deven.', 'Langchain': ''}  
   
 Current conversation:  
 Human: Deven & Sam are working on a hackathon project  
 AI: That sounds like a great project! What kind of project are they working on?  
 Last line:  
 Human: They are trying to add more complex memory structures to Langchain  
 You:  
   
 > Finished chain.  
  
  
  
  
  
 ' That sounds like an interesting project! What kind of memory structures are they trying to add?'  

```

```
conversation.predict(input=""They are adding in a key-value store for entities mentioned so far in the conversation."")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 You are an assistant to a human, powered by a large language model trained by OpenAI.  
   
 You are designed to be able to assist with a wide range of tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. As a language model, you are able to generate human-like text based on the input you receive, allowing you to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.  
   
 You are constantly learning and improving, and your capabilities are constantly evolving. You are able to process and understand large amounts of text, and can use this knowledge to provide accurate and informative responses to a wide range of questions. You have access to some personalized information provided by the human in the Context section below. Additionally, you are able to generate your own text based on the input you receive, allowing you to engage in discussions and provide explanations and descriptions on a wide range of topics.  
   
 Overall, you are a powerful tool that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. Whether the human needs help with a specific question or just wants to have a conversation about a particular topic, you are here to assist.  
   
 Context:  
 {'Deven': 'Deven is working on a hackathon project with Sam, which they are entering into a hackathon. They are trying to add more complex memory structures to Langchain.', 'Sam': 'Sam is working on a hackathon project with Deven, trying to add more complex memory structures to Langchain.', 'Langchain': 'Langchain is a project that is trying to add more complex memory structures.', 'Key-Value Store': ''}  
   
 Current conversation:  
 Human: Deven & Sam are working on a hackathon project  
 AI: That sounds like a great project! What kind of project are they working on?  
 Human: They are trying to add more complex memory structures to Langchain  
 AI: That sounds like an interesting project! What kind of memory structures are they trying to add?  
 Last line:  
 Human: They are adding in a key-value store for entities mentioned so far in the conversation.  
 You:  
   
 > Finished chain.  
  
  
  
  
  
 ' That sounds like a great idea! How will the key-value store help with the project?'  

```

```
conversation.predict(input=""What do you know about Deven & Sam?"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 You are an assistant to a human, powered by a large language model trained by OpenAI.  
   
 You are designed to be able to assist with a wide range of tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. As a language model, you are able to generate human-like text based on the input you receive, allowing you to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.  
   
 You are constantly learning and improving, and your capabilities are constantly evolving. You are able to process and understand large amounts of text, and can use this knowledge to provide accurate and informative responses to a wide range of questions. You have access to some personalized information provided by the human in the Context section below. Additionally, you are able to generate your own text based on the input you receive, allowing you to engage in discussions and provide explanations and descriptions on a wide range of topics.  
   
 Overall, you are a powerful tool that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. Whether the human needs help with a specific question or just wants to have a conversation about a particular topic, you are here to assist.  
   
 Context:  
 {'Deven': 'Deven is working on a hackathon project with Sam, which they are entering into a hackathon. They are trying to add more complex memory structures to Langchain, including a key-value store for entities mentioned so far in the conversation.', 'Sam': 'Sam is working on a hackathon project with Deven, trying to add more complex memory structures to Langchain, including a key-value store for entities mentioned so far in the conversation.'}  
   
 Current conversation:  
 Human: Deven & Sam are working on a hackathon project  
 AI: That sounds like a great project! What kind of project are they working on?  
 Human: They are trying to add more complex memory structures to Langchain  
 AI: That sounds like an interesting project! What kind of memory structures are they trying to add?  
 Human: They are adding in a key-value store for entities mentioned so far in the conversation.  
 AI: That sounds like a great idea! How will the key-value store help with the project?  
 Last line:  
 Human: What do you know about Deven & Sam?  
 You:  
   
 > Finished chain.  
  
  
  
  
  
 ' Deven and Sam are working on a hackathon project together, trying to add more complex memory structures to Langchain, including a key-value store for entities mentioned so far in the conversation. They seem to be working hard on this project and have a great idea for how the key-value store can help.'  

```
Inspecting the memory store[​](#inspecting-the-memory-store ""Direct link to Inspecting the memory store"")
---------------------------------------------------------------------------------------------------------

We can also inspect the memory store directly. In the following examples, we look at it directly, and then go through some examples of adding information and watch how it changes.


```
from pprint import pprint  
pprint(conversation.memory.entity\_store.store)  

```

```
 {'Daimon': 'Daimon is a company founded by Sam, a successful entrepreneur.',  
 'Deven': 'Deven is working on a hackathon project with Sam, which they are '  
 'entering into a hackathon. They are trying to add more complex '  
 'memory structures to Langchain, including a key-value store for '  
 'entities mentioned so far in the conversation, and seem to be '  
 'working hard on this project with a great idea for how the '  
 'key-value store can help.',  
 'Key-Value Store': 'A key-value store is being added to the project to store '  
 'entities mentioned in the conversation.',  
 'Langchain': 'Langchain is a project that is trying to add more complex '  
 'memory structures, including a key-value store for entities '  
 'mentioned so far in the conversation.',  
 'Sam': 'Sam is working on a hackathon project with Deven, trying to add more '  
 'complex memory structures to Langchain, including a key-value store '  
 'for entities mentioned so far in the conversation. They seem to have '  
 'a great idea for how the key-value store can help, and Sam is also '  
 'the founder of a company called Daimon.'}  

```

```
conversation.predict(input=""Sam is the founder of a company called Daimon."")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 You are an assistant to a human, powered by a large language model trained by OpenAI.  
   
 You are designed to be able to assist with a wide range of tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. As a language model, you are able to generate human-like text based on the input you receive, allowing you to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.  
   
 You are constantly learning and improving, and your capabilities are constantly evolving. You are able to process and understand large amounts of text, and can use this knowledge to provide accurate and informative responses to a wide range of questions. You have access to some personalized information provided by the human in the Context section below. Additionally, you are able to generate your own text based on the input you receive, allowing you to engage in discussions and provide explanations and descriptions on a wide range of topics.  
   
 Overall, you are a powerful tool that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. Whether the human needs help with a specific question or just wants to have a conversation about a particular topic, you are here to assist.  
   
 Context:  
 {'Daimon': 'Daimon is a company founded by Sam, a successful entrepreneur.', 'Sam': 'Sam is working on a hackathon project with Deven, trying to add more complex memory structures to Langchain, including a key-value store for entities mentioned so far in the conversation. They seem to have a great idea for how the key-value store can help, and Sam is also the founder of a company called Daimon.'}  
   
 Current conversation:  
 Human: They are adding in a key-value store for entities mentioned so far in the conversation.  
 AI: That sounds like a great idea! How will the key-value store help with the project?  
 Human: What do you know about Deven & Sam?  
 AI: Deven and Sam are working on a hackathon project together, trying to add more complex memory structures to Langchain, including a key-value store for entities mentioned so far in the conversation. They seem to be working hard on this project and have a great idea for how the key-value store can help.  
 Human: Sam is the founder of a company called Daimon.  
 AI:   
 That's impressive! It sounds like Sam is a very successful entrepreneur. What kind of company is Daimon?  
 Last line:  
 Human: Sam is the founder of a company called Daimon.  
 You:  
   
 > Finished chain.  
  
  
  
  
  
 "" That's impressive! It sounds like Sam is a very successful entrepreneur. What kind of company is Daimon?""  

```

```
from pprint import pprint  
pprint(conversation.memory.entity\_store.store)  

```

```
 {'Daimon': 'Daimon is a company founded by Sam, a successful entrepreneur, who '  
 'is working on a hackathon project with Deven to add more complex '  
 'memory structures to Langchain.',  
 'Deven': 'Deven is working on a hackathon project with Sam, which they are '  
 'entering into a hackathon. They are trying to add more complex '  
 'memory structures to Langchain, including a key-value store for '  
 'entities mentioned so far in the conversation, and seem to be '  
 'working hard on this project with a great idea for how the '  
 'key-value store can help.',  
 'Key-Value Store': 'A key-value store is being added to the project to store '  
 'entities mentioned in the conversation.',  
 'Langchain': 'Langchain is a project that is trying to add more complex '  
 'memory structures, including a key-value store for entities '  
 'mentioned so far in the conversation.',  
 'Sam': 'Sam is working on a hackathon project with Deven, trying to add more '  
 'complex memory structures to Langchain, including a key-value store '  
 'for entities mentioned so far in the conversation. They seem to have '  
 'a great idea for how the key-value store can help, and Sam is also '  
 'the founder of a successful company called Daimon.'}  

```

```
conversation.predict(input=""What do you know about Sam?"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 You are an assistant to a human, powered by a large language model trained by OpenAI.  
   
 You are designed to be able to assist with a wide range of tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. As a language model, you are able to generate human-like text based on the input you receive, allowing you to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.  
   
 You are constantly learning and improving, and your capabilities are constantly evolving. You are able to process and understand large amounts of text, and can use this knowledge to provide accurate and informative responses to a wide range of questions. You have access to some personalized information provided by the human in the Context section below. Additionally, you are able to generate your own text based on the input you receive, allowing you to engage in discussions and provide explanations and descriptions on a wide range of topics.  
   
 Overall, you are a powerful tool that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. Whether the human needs help with a specific question or just wants to have a conversation about a particular topic, you are here to assist.  
   
 Context:  
 {'Deven': 'Deven is working on a hackathon project with Sam, which they are entering into a hackathon. They are trying to add more complex memory structures to Langchain, including a key-value store for entities mentioned so far in the conversation, and seem to be working hard on this project with a great idea for how the key-value store can help.', 'Sam': 'Sam is working on a hackathon project with Deven, trying to add more complex memory structures to Langchain, including a key-value store for entities mentioned so far in the conversation. They seem to have a great idea for how the key-value store can help, and Sam is also the founder of a successful company called Daimon.', 'Langchain': 'Langchain is a project that is trying to add more complex memory structures, including a key-value store for entities mentioned so far in the conversation.', 'Daimon': 'Daimon is a company founded by Sam, a successful entrepreneur, who is working on a hackathon project with Deven to add more complex memory structures to Langchain.'}  
   
 Current conversation:  
 Human: What do you know about Deven & Sam?  
 AI: Deven and Sam are working on a hackathon project together, trying to add more complex memory structures to Langchain, including a key-value store for entities mentioned so far in the conversation. They seem to be working hard on this project and have a great idea for how the key-value store can help.  
 Human: Sam is the founder of a company called Daimon.  
 AI:   
 That's impressive! It sounds like Sam is a very successful entrepreneur. What kind of company is Daimon?  
 Human: Sam is the founder of a company called Daimon.  
 AI: That's impressive! It sounds like Sam is a very successful entrepreneur. What kind of company is Daimon?  
 Last line:  
 Human: What do you know about Sam?  
 You:  
   
 > Finished chain.  
  
  
  
  
  
 ' Sam is the founder of a successful company called Daimon. He is also working on a hackathon project with Deven to add more complex memory structures to Langchain. They seem to have a great idea for how the key-value store can help.'  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/memory/types/,"Memory Types
============

There are many different types of memory.
Each have their own parameters, their own return types, and are useful in different scenarios.
Please see their individual page for more detail on each one.

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/memory/types/summary,"Conversation summary memory
===========================

Now let's take a look at using a slightly more complex type of memory - `ConversationSummaryMemory`. This type of memory creates a summary of the conversation over time. This can be useful for condensing information from the conversation over time.
Conversation summary memory summarizes the conversation as it happens and stores the current summary in memory. This memory can then be used to inject the summary of the conversation so far into a prompt/chain. This memory is most useful for longer conversations, where keeping the past message history in the prompt verbatim would take up too many tokens.

Let's first explore the basic functionality of this type of memory.


```
from langchain.memory import ConversationSummaryMemory, ChatMessageHistory  
from langchain.llms import OpenAI  

```

```
memory = ConversationSummaryMemory(llm=OpenAI(temperature=0))  
memory.save\_context({""input"": ""hi""}, {""output"": ""whats up""})  

```

```
memory.load\_memory\_variables({})  

```

```
 {'history': '\nThe human greets the AI, to which the AI responds.'}  

```
We can also get the history as a list of messages (this is useful if you are using this with a chat model).


```
memory = ConversationSummaryMemory(llm=OpenAI(temperature=0), return\_messages=True)  
memory.save\_context({""input"": ""hi""}, {""output"": ""whats up""})  

```

```
memory.load\_memory\_variables({})  

```

```
 {'history': [SystemMessage(content='\nThe human greets the AI, to which the AI responds.', additional\_kwargs={})]}  

```
We can also utilize the `predict_new_summary` method directly.


```
messages = memory.chat\_memory.messages  
previous\_summary = """"  
memory.predict\_new\_summary(messages, previous\_summary)  

```

```
 '\nThe human greets the AI, to which the AI responds.'  

```
Initializing with messages[​](#initializing-with-messages ""Direct link to Initializing with messages"")
------------------------------------------------------------------------------------------------------

If you have messages outside this class, you can easily initialize the class with ChatMessageHistory. During loading, a summary will be calculated.


```
history = ChatMessageHistory()  
history.add\_user\_message(""hi"")  
history.add\_ai\_message(""hi there!"")  

```

```
memory = ConversationSummaryMemory.from\_messages(llm=OpenAI(temperature=0), chat\_memory=history, return\_messages=True)  

```

```
memory.buffer  

```

```
 '\nThe human greets the AI, to which the AI responds with a friendly greeting.'  

```
Using in a chain[​](#using-in-a-chain ""Direct link to Using in a chain"")
------------------------------------------------------------------------

Let's walk through an example of using this in a chain, again setting `verbose=True` so we can see the prompt.


```
from langchain.llms import OpenAI  
from langchain.chains import ConversationChain  
llm = OpenAI(temperature=0)  
conversation\_with\_summary = ConversationChain(  
 llm=llm,   
 memory=ConversationSummaryMemory(llm=OpenAI()),  
 verbose=True  
)  
conversation\_with\_summary.predict(input=""Hi, what's up?"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
   
 Current conversation:  
   
 Human: Hi, what's up?  
 AI:  
   
 > Finished chain.  
  
  
  
  
  
 "" Hi there! I'm doing great. I'm currently helping a customer with a technical issue. How about you?""  

```

```
conversation\_with\_summary.predict(input=""Tell me more about it!"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
   
 Current conversation:  
   
 The human greeted the AI and asked how it was doing. The AI replied that it was doing great and was currently helping a customer with a technical issue.  
 Human: Tell me more about it!  
 AI:  
   
 > Finished chain.  
  
  
  
  
  
 "" Sure! The customer is having trouble with their computer not connecting to the internet. I'm helping them troubleshoot the issue and figure out what the problem is. So far, we've tried resetting the router and checking the network settings, but the issue still persists. We're currently looking into other possible solutions.""  

```

```
conversation\_with\_summary.predict(input=""Very cool -- what is the scope of the project?"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
   
 Current conversation:  
   
 The human greeted the AI and asked how it was doing. The AI replied that it was doing great and was currently helping a customer with a technical issue where their computer was not connecting to the internet. The AI was troubleshooting the issue and had already tried resetting the router and checking the network settings, but the issue still persisted and they were looking into other possible solutions.  
 Human: Very cool -- what is the scope of the project?  
 AI:  
   
 > Finished chain.  
  
  
  
  
  
 "" The scope of the project is to troubleshoot the customer's computer issue and find a solution that will allow them to connect to the internet. We are currently exploring different possibilities and have already tried resetting the router and checking the network settings, but the issue still persists.""  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/memory/types/vectorstore_retriever_memory,"Vector store-backed memory
==========================

`VectorStoreRetrieverMemory` stores memories in a VectorDB and queries the top-K most ""salient"" docs every time it is called.

This differs from most of the other Memory classes in that it doesn't explicitly track the order of interactions.

In this case, the ""docs"" are previous conversation snippets. This can be useful to refer to relevant pieces of information that the AI was told earlier in the conversation.


```
from datetime import datetime  
from langchain.embeddings.openai import OpenAIEmbeddings  
from langchain.llms import OpenAI  
from langchain.memory import VectorStoreRetrieverMemory  
from langchain.chains import ConversationChain  
from langchain.prompts import PromptTemplate  

```
### Initialize your VectorStore[​](#initialize-your-vectorstore ""Direct link to Initialize your VectorStore"")

Depending on the store you choose, this step may look different. Consult the relevant VectorStore documentation for more details.


```
import faiss  
  
from langchain.docstore import InMemoryDocstore  
from langchain.vectorstores import FAISS  
  
  
embedding\_size = 1536 # Dimensions of the OpenAIEmbeddings  
index = faiss.IndexFlatL2(embedding\_size)  
embedding\_fn = OpenAIEmbeddings().embed\_query  
vectorstore = FAISS(embedding\_fn, index, InMemoryDocstore({}), {})  

```
### Create your the VectorStoreRetrieverMemory[​](#create-your-the-vectorstoreretrievermemory ""Direct link to Create your the VectorStoreRetrieverMemory"")

The memory object is instantiated from any VectorStoreRetriever.


```
# In actual usage, you would set `k` to be a higher value, but we use k=1 to show that  
# the vector lookup still returns the semantically relevant information  
retriever = vectorstore.as\_retriever(search\_kwargs=dict(k=1))  
memory = VectorStoreRetrieverMemory(retriever=retriever)  
  
# When added to an agent, the memory object can save pertinent information from conversations or used tools  
memory.save\_context({""input"": ""My favorite food is pizza""}, {""output"": ""that's good to know""})  
memory.save\_context({""input"": ""My favorite sport is soccer""}, {""output"": ""...""})  
memory.save\_context({""input"": ""I don't the Celtics""}, {""output"": ""ok""}) #  

```

```
# Notice the first result returned is the memory pertaining to tax help, which the language model deems more semantically relevant  
# to a 1099 than the other documents, despite them both containing numbers.  
print(memory.load\_memory\_variables({""prompt"": ""what sport should i watch?""})[""history""])  

```

```
 input: My favorite sport is soccer  
 output: ...  

```
Using in a chain[​](#using-in-a-chain ""Direct link to Using in a chain"")
------------------------------------------------------------------------

Let's walk through an example, again setting `verbose=True` so we can see the prompt.


```
llm = OpenAI(temperature=0) # Can be any valid LLM  
\_DEFAULT\_TEMPLATE = """"""The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
  
Relevant pieces of previous conversation:  
{history}  
  
(You do not need to use these pieces of information if not relevant)  
  
Current conversation:  
Human: {input}  
AI:""""""  
PROMPT = PromptTemplate(  
 input\_variables=[""history"", ""input""], template=\_DEFAULT\_TEMPLATE  
)  
conversation\_with\_summary = ConversationChain(  
 llm=llm,   
 prompt=PROMPT,  
 # We set a very low max\_token\_limit for the purposes of testing.  
 memory=memory,  
 verbose=True  
)  
conversation\_with\_summary.predict(input=""Hi, my name is Perry, what's up?"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
   
 Relevant pieces of previous conversation:  
 input: My favorite food is pizza  
 output: that's good to know  
   
 (You do not need to use these pieces of information if not relevant)  
   
 Current conversation:  
 Human: Hi, my name is Perry, what's up?  
 AI:  
   
 > Finished chain.  
  
  
  
  
  
 "" Hi Perry, I'm doing well. How about you?""  

```

```
# Here, the basketball related content is surfaced  
conversation\_with\_summary.predict(input=""what's my favorite sport?"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
   
 Relevant pieces of previous conversation:  
 input: My favorite sport is soccer  
 output: ...  
   
 (You do not need to use these pieces of information if not relevant)  
   
 Current conversation:  
 Human: what's my favorite sport?  
 AI:  
   
 > Finished chain.  
  
  
  
  
  
 ' You told me earlier that your favorite sport is soccer.'  

```

```
# Even though the language model is stateless, since relevant memory is fetched, it can ""reason"" about the time.  
# Timestamping memories and data is useful in general to let the agent determine temporal relevance  
conversation\_with\_summary.predict(input=""Whats my favorite food"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
   
 Relevant pieces of previous conversation:  
 input: My favorite food is pizza  
 output: that's good to know  
   
 (You do not need to use these pieces of information if not relevant)  
   
 Current conversation:  
 Human: Whats my favorite food  
 AI:  
   
 > Finished chain.  
  
  
  
  
  
 ' You said your favorite food is pizza.'  

```

```
# The memories from the conversation are automatically stored,  
# since this query best matches the introduction chat above,  
# the agent is able to 'remember' the user's name.  
conversation\_with\_summary.predict(input=""What's my name?"")  

```

```
   
   
 > Entering new ConversationChain chain...  
 Prompt after formatting:  
 The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.  
   
 Relevant pieces of previous conversation:  
 input: Hi, my name is Perry, what's up?  
 response: Hi Perry, I'm doing well. How about you?  
   
 (You do not need to use these pieces of information if not relevant)  
   
 Current conversation:  
 Human: What's my name?  
 AI:  
   
 > Finished chain.  
  
  
  
  
  
 ' Your name is Perry.'  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/,"Model I/O
=========

The core element of any language model application is...the model. LangChain gives you the building blocks to interface with any language model.

* [Prompts](/docs/modules/model_io/prompts/): Templatize, dynamically select, and manage model inputs
* [Language models](/docs/modules/model_io/models/): Make calls to language models through common interfaces
* [Output parsers](/docs/modules/model_io/output_parsers/): Extract information from model outputs

![model_io_diagram](/assets/images/model_io-1f23a36233d7731e93576d6885da2750.jpg)

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/models/chat/chat_model_caching,"Caching
=======

LangChain provides an optional caching layer for Chat Models. This is useful for two reasons:

It can save you money by reducing the number of API calls you make to the LLM provider, if you're often requesting the same completion multiple times.
It can speed up your application by reducing the number of API calls you make to the LLM provider.


```
import langchain  
from langchain.chat\_models import ChatOpenAI  
  
llm = ChatOpenAI()  

```
In Memory Cache[​](#in-memory-cache ""Direct link to In Memory Cache"")
---------------------------------------------------------------------


```
from langchain.cache import InMemoryCache  
langchain.llm\_cache = InMemoryCache()  
  
# The first time, it is not yet in cache, so it should take longer  
llm.predict(""Tell me a joke"")  

```

```
 CPU times: user 35.9 ms, sys: 28.6 ms, total: 64.6 ms  
 Wall time: 4.83 s  
   
  
 ""\n\nWhy couldn't the bicycle stand up by itself? It was...two tired!""  

```

```
# The second time it is, so it goes faster  
llm.predict(""Tell me a joke"")  

```

```
 CPU times: user 238 µs, sys: 143 µs, total: 381 µs  
 Wall time: 1.76 ms  
  
  
 '\n\nWhy did the chicken cross the road?\n\nTo get to the other side.'  

```
SQLite Cache[​](#sqlite-cache ""Direct link to SQLite Cache"")
------------------------------------------------------------


```
rm .langchain.db  

```

```
# We can do the same thing with a SQLite cache  
from langchain.cache import SQLiteCache  
langchain.llm\_cache = SQLiteCache(database\_path="".langchain.db"")  

```

```
# The first time, it is not yet in cache, so it should take longer  
llm.predict(""Tell me a joke"")  

```

```
 CPU times: user 17 ms, sys: 9.76 ms, total: 26.7 ms  
 Wall time: 825 ms  
  
  
 '\n\nWhy did the chicken cross the road?\n\nTo get to the other side.'  

```

```
# The second time it is, so it goes faster  
llm.predict(""Tell me a joke"")  

```

```
 CPU times: user 2.46 ms, sys: 1.23 ms, total: 3.7 ms  
 Wall time: 2.67 ms  
  
  
 '\n\nWhy did the chicken cross the road?\n\nTo get to the other side.'  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/models/chat/,"Chat models
===========

infoHead to [Integrations](/docs/integrations/chat/) for documentation on built-in integrations with chat model providers.

Chat models are a variation on language models.
While chat models use language models under the hood, the interface they expose is a bit different.
Rather than expose a ""text in, text out"" API, they expose an interface where ""chat messages"" are the inputs and outputs.

Chat model APIs are fairly new, so we are still figuring out the correct abstractions.

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------

### Setup[​](#setup ""Direct link to Setup"")

To start we'll need to install the OpenAI Python package:


```
pip install openai  

```
Accessing the API requires an API key, which you can get by creating an account and heading [here](https://platform.openai.com/account/api-keys). Once we have a key we'll want to set it as an environment variable by running:


```
export OPENAI\_API\_KEY=""...""  

```
If you'd prefer not to set an environment variable you can pass the key in directly via the `openai_api_key` named parameter when initiating the OpenAI LLM class:


```
from langchain.chat\_models import ChatOpenAI  
  
chat = ChatOpenAI(openai\_api\_key=""..."")  

```
otherwise you can initialize without any params:


```
from langchain.chat\_models import ChatOpenAI  
  
chat = ChatOpenAI()  

```
### Messages[​](#messages ""Direct link to Messages"")

The chat model interface is based around messages rather than raw text.
The types of messages currently supported in LangChain are `AIMessage`, `HumanMessage`, `SystemMessage`, and `ChatMessage` -- `ChatMessage` takes in an arbitrary role parameter. Most of the time, you'll just be dealing with `HumanMessage`, `AIMessage`, and `SystemMessage`

### `__call__`[​](#__call__ ""Direct link to __call__"")

#### Messages in -> message out[​](#messages-in---message-out ""Direct link to Messages in -> message out"")

You can get chat completions by passing one or more messages to the chat model. The response will be a message.


```
from langchain.schema import (  
 AIMessage,  
 HumanMessage,  
 SystemMessage  
)  
  
chat([HumanMessage(content=""Translate this sentence from English to French: I love programming."")])  

```

```
 AIMessage(content=""J'aime programmer."", additional\_kwargs={})  

```
OpenAI's chat model supports multiple messages as input. See [here](https://platform.openai.com/docs/guides/chat/chat-vs-completions) for more information. Here is an example of sending a system and user message to the chat model:


```
messages = [  
 SystemMessage(content=""You are a helpful assistant that translates English to French.""),  
 HumanMessage(content=""I love programming."")  
]  
chat(messages)  

```

```
 AIMessage(content=""J'aime programmer."", additional\_kwargs={})  

```
### `generate`[​](#generate ""Direct link to generate"")

#### Batch calls, richer outputs[​](#batch-calls-richer-outputs ""Direct link to Batch calls, richer outputs"")

You can go one step further and generate completions for multiple sets of messages using `generate`. This returns an `LLMResult` with an additional `message` parameter.


```
batch\_messages = [  
 [  
 SystemMessage(content=""You are a helpful assistant that translates English to French.""),  
 HumanMessage(content=""I love programming."")  
 ],  
 [  
 SystemMessage(content=""You are a helpful assistant that translates English to French.""),  
 HumanMessage(content=""I love artificial intelligence."")  
 ],  
]  
result = chat.generate(batch\_messages)  
result  

```

```
 LLMResult(generations=[[ChatGeneration(text=""J'aime programmer."", generation\_info=None, message=AIMessage(content=""J'aime programmer."", additional\_kwargs={}))], [ChatGeneration(text=""J'aime l'intelligence artificielle."", generation\_info=None, message=AIMessage(content=""J'aime l'intelligence artificielle."", additional\_kwargs={}))]], llm\_output={'token\_usage': {'prompt\_tokens': 57, 'completion\_tokens': 20, 'total\_tokens': 77}})  

```
You can recover things like token usage from this LLMResult


```
result.llm\_output  

```

```
 {'token\_usage': {'prompt\_tokens': 57,  
 'completion\_tokens': 20,  
 'total\_tokens': 77}}  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/models/chat/llm_chain,"LLMChain
========

You can use the existing LLMChain in a very similar way to before - provide a prompt and a model.


```
chain = LLMChain(llm=chat, prompt=chat\_prompt)  

```

```
chain.run(input\_language=""English"", output\_language=""French"", text=""I love programming."")  

```

```
 ""J'adore la programmation.""  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/models/chat/prompts,"Prompts
=======

Prompts for Chat models are built around messages, instead of just plain text.

You can make use of templating by using a `MessagePromptTemplate`. You can build a `ChatPromptTemplate` from one or more `MessagePromptTemplates`. You can use `ChatPromptTemplate`'s `format_prompt` -- this returns a `PromptValue`, which you can convert to a string or Message object, depending on whether you want to use the formatted value as input to an llm or chat model.

For convenience, there is a `from_template` method exposed on the template. If you were to use this template, this is what it would look like:


```
from langchain import PromptTemplate  
from langchain.prompts.chat import (  
 ChatPromptTemplate,  
 SystemMessagePromptTemplate,  
 AIMessagePromptTemplate,  
 HumanMessagePromptTemplate,  
)  
  
template=""You are a helpful assistant that translates {input\_language} to {output\_language}.""  
system\_message\_prompt = SystemMessagePromptTemplate.from\_template(template)  
human\_template=""{text}""  
human\_message\_prompt = HumanMessagePromptTemplate.from\_template(human\_template)  

```

```
chat\_prompt = ChatPromptTemplate.from\_messages([system\_message\_prompt, human\_message\_prompt])  
  
# get a chat completion from the formatted messages  
chat(chat\_prompt.format\_prompt(input\_language=""English"", output\_language=""French"", text=""I love programming."").to\_messages())  

```

```
 AIMessage(content=""J'adore la programmation."", additional\_kwargs={})  

```
If you wanted to construct the MessagePromptTemplate more directly, you could create a PromptTemplate outside and then pass it in, eg:


```
prompt=PromptTemplate(  
 template=""You are a helpful assistant that translates {input\_language} to {output\_language}."",  
 input\_variables=[""input\_language"", ""output\_language""],  
)  
system\_message\_prompt = SystemMessagePromptTemplate(prompt=prompt)  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/models/chat/streaming,"Streaming
=========

Some Chat models provide a streaming response. This means that instead of waiting for the entire response to be returned, you can start processing it as soon as it's available. This is useful if you want to display the response to the user as it's being generated, or if you want to process the response as it's being generated.


```
from langchain.chat\_models import ChatOpenAI  
from langchain.schema import (  
 HumanMessage,  
)  
  
  
from langchain.callbacks.streaming\_stdout import StreamingStdOutCallbackHandler  
chat = ChatOpenAI(streaming=True, callbacks=[StreamingStdOutCallbackHandler()], temperature=0)  
resp = chat([HumanMessage(content=""Write me a song about sparkling water."")])  

```

```
 Verse 1:  
 Bubbles rising to the top  
 A refreshing drink that never stops  
 Clear and crisp, it's pure delight  
 A taste that's sure to excite  
   
 Chorus:  
 Sparkling water, oh so fine  
 A drink that's always on my mind  
 With every sip, I feel alive  
 Sparkling water, you're my vibe  
   
 Verse 2:  
 No sugar, no calories, just pure bliss  
 A drink that's hard to resist  
 It's the perfect way to quench my thirst  
 A drink that always comes first  
   
 Chorus:  
 Sparkling water, oh so fine  
 A drink that's always on my mind  
 With every sip, I feel alive  
 Sparkling water, you're my vibe  
   
 Bridge:  
 From the mountains to the sea  
 Sparkling water, you're the key  
 To a healthy life, a happy soul  
 A drink that makes me feel whole  
   
 Chorus:  
 Sparkling water, oh so fine  
 A drink that's always on my mind  
 With every sip, I feel alive  
 Sparkling water, you're my vibe  
   
 Outro:  
 Sparkling water, you're the one  
 A drink that's always so much fun  
 I'll never let you go, my friend  
 Sparkling  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/models/,"Language models
===============

LangChain provides interfaces and integrations for two types of models:

* [LLMs](/docs/modules/model_io/models/llms/): Models that take a text string as input and return a text string
* [Chat models](/docs/modules/model_io/models/chat/): Models that are backed by a language model but take a list of Chat Messages as input and return a Chat Message

LLMs vs Chat Models[​](#llms-vs-chat-models ""Direct link to LLMs vs Chat Models"")
---------------------------------------------------------------------------------

LLMs and Chat Models are subtly but importantly different. LLMs in LangChain refer to pure text completion models.
The APIs they wrap take a string prompt as input and output a string completion. OpenAI's GPT-3 is implemented as an LLM.
Chat models are often backed by LLMs but tuned specifically for having conversations.
And, crucially, their provider APIs expose a different interface than pure text completion models. Instead of a single string,
they take a list of chat messages as input. Usually these messages are labeled with the speaker (usually one of ""System"",
""AI"", and ""Human""). And they return a (""AI"") chat message as output. GPT-4 and Anthropic's Claude are both implemented as Chat Models.

To make it possible to swap LLMs and Chat Models, both implement the Base Language Model interface. This exposes common
methods ""predict"", which takes a string and returns a string, and ""predict messages"", which takes messages and returns a message.
If you are using a specific model it's recommended you use the methods specific to that model class (i.e., ""predict"" for LLMs and ""predict messages"" for Chat Models),
but if you're creating an application that should work with different types of models the shared interface can be helpful.

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/models/llms/,"LLMs
====

infoHead to [Integrations](/docs/integrations/llms/) for documentation on built-in integrations with LLM providers.

Large Language Models (LLMs) are a core component of LangChain.
LangChain does not serve its own LLMs, but rather provides a standard interface for interacting with many different LLMs.

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------

There are lots of LLM providers (OpenAI, Cohere, Hugging Face, etc) - the `LLM` class is designed to provide a standard interface for all of them.

In this walkthrough we'll work with an OpenAI LLM wrapper, although the functionalities highlighted are generic for all LLM types.

### Setup[​](#setup ""Direct link to Setup"")

To start we'll need to install the OpenAI Python package:


```
pip install openai  

```
Accessing the API requires an API key, which you can get by creating an account and heading [here](https://platform.openai.com/account/api-keys). Once we have a key we'll want to set it as an environment variable by running:


```
export OPENAI\_API\_KEY=""...""  

```
If you'd prefer not to set an environment variable you can pass the key in directly via the `openai_api_key` named parameter when initiating the OpenAI LLM class:


```
from langchain.llms import OpenAI  
  
llm = OpenAI(openai\_api\_key=""..."")  

```
otherwise you can initialize without any params:


```
from langchain.llms import OpenAI  
  
llm = OpenAI()  

```
### `__call__`: string in -> string out[​](#__call__-string-in---string-out ""Direct link to __call__-string-in---string-out"")

The simplest way to use an LLM is a callable: pass in a string, get a string completion.


```
llm(""Tell me a joke"")  

```

```
 'Why did the chicken cross the road?\n\nTo get to the other side.'  

```
### `generate`: batch calls, richer outputs[​](#generate-batch-calls-richer-outputs ""Direct link to generate-batch-calls-richer-outputs"")

`generate` lets you can call the model with a list of strings, getting back a more complete response than just the text. This complete response can includes things like multiple top responses and other LLM provider-specific information:


```
llm\_result = llm.generate([""Tell me a joke"", ""Tell me a poem""]\*15)  

```

```
len(llm\_result.generations)  

```

```
 30  

```

```
llm\_result.generations[0]  

```

```
 [Generation(text='\n\nWhy did the chicken cross the road?\n\nTo get to the other side!'),  
 Generation(text='\n\nWhy did the chicken cross the road?\n\nTo get to the other side.')]  

```

```
llm\_result.generations[-1]  

```

```
 [Generation(text=""\n\nWhat if love neverspeech\n\nWhat if love never ended\n\nWhat if love was only a feeling\n\nI'll never know this love\n\nIt's not a feeling\n\nBut it's what we have for each other\n\nWe just know that love is something strong\n\nAnd we can't help but be happy\n\nWe just feel what love is for us\n\nAnd we love each other with all our heart\n\nWe just don't know how\n\nHow it will go\n\nBut we know that love is something strong\n\nAnd we'll always have each other\n\nIn our lives.""),  
 Generation(text='\n\nOnce upon a time\n\nThere was a love so pure and true\n\nIt lasted for centuries\n\nAnd never became stale or dry\n\nIt was moving and alive\n\nAnd the heart of the love-ick\n\nIs still beating strong and true.')]  

```
You can also access provider specific information that is returned. This information is NOT standardized across providers.


```
llm\_result.llm\_output  

```

```
 {'token\_usage': {'completion\_tokens': 3903,  
 'total\_tokens': 4023,  
 'prompt\_tokens': 120}}  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/models/llms/llm_caching,"Caching
=======

LangChain provides an optional caching layer for LLMs. This is useful for two reasons:

It can save you money by reducing the number of API calls you make to the LLM provider, if you're often requesting the same completion multiple times.
It can speed up your application by reducing the number of API calls you make to the LLM provider.


```
import langchain  
from langchain.llms import OpenAI  
  
# To make the caching really obvious, lets use a slower model.  
llm = OpenAI(model\_name=""text-davinci-002"", n=2, best\_of=2)  

```
In Memory Cache[​](#in-memory-cache ""Direct link to In Memory Cache"")
---------------------------------------------------------------------


```
from langchain.cache import InMemoryCache  
langchain.llm\_cache = InMemoryCache()  
  
# The first time, it is not yet in cache, so it should take longer  
llm.predict(""Tell me a joke"")  

```

```
 CPU times: user 35.9 ms, sys: 28.6 ms, total: 64.6 ms  
 Wall time: 4.83 s  
   
  
 ""\n\nWhy couldn't the bicycle stand up by itself? It was...two tired!""  

```

```
# The second time it is, so it goes faster  
llm.predict(""Tell me a joke"")  

```

```
 CPU times: user 238 µs, sys: 143 µs, total: 381 µs  
 Wall time: 1.76 ms  
  
  
 '\n\nWhy did the chicken cross the road?\n\nTo get to the other side.'  

```
SQLite Cache[​](#sqlite-cache ""Direct link to SQLite Cache"")
------------------------------------------------------------


```
rm .langchain.db  

```

```
# We can do the same thing with a SQLite cache  
from langchain.cache import SQLiteCache  
langchain.llm\_cache = SQLiteCache(database\_path="".langchain.db"")  

```

```
# The first time, it is not yet in cache, so it should take longer  
llm.predict(""Tell me a joke"")  

```

```
 CPU times: user 17 ms, sys: 9.76 ms, total: 26.7 ms  
 Wall time: 825 ms  
  
  
 '\n\nWhy did the chicken cross the road?\n\nTo get to the other side.'  

```

```
# The second time it is, so it goes faster  
llm.predict(""Tell me a joke"")  

```

```
 CPU times: user 2.46 ms, sys: 1.23 ms, total: 3.7 ms  
 Wall time: 2.67 ms  
  
  
 '\n\nWhy did the chicken cross the road?\n\nTo get to the other side.'  

```
Optional Caching in Chains[​](#optional-caching-in-chains ""Direct link to Optional Caching in Chains"")
------------------------------------------------------------------------------------------------------

You can also turn off caching for particular nodes in chains. Note that because of certain interfaces, its often easier to construct the chain first, and then edit the LLM afterwards.

As an example, we will load a summarizer map-reduce chain. We will cache results for the map-step, but then not freeze it for the combine step.


```
llm = OpenAI(model\_name=""text-davinci-002"")  
no\_cache\_llm = OpenAI(model\_name=""text-davinci-002"", cache=False)  

```

```
from langchain.text\_splitter import CharacterTextSplitter  
from langchain.chains.mapreduce import MapReduceChain  
  
text\_splitter = CharacterTextSplitter()  

```

```
with open('../../../state\_of\_the\_union.txt') as f:  
 state\_of\_the\_union = f.read()  
texts = text\_splitter.split\_text(state\_of\_the\_union)  

```

```
from langchain.docstore.document import Document  
docs = [Document(page\_content=t) for t in texts[:3]]  
from langchain.chains.summarize import load\_summarize\_chain  

```

```
chain = load\_summarize\_chain(llm, chain\_type=""map\_reduce"", reduce\_llm=no\_cache\_llm)  

```

```
chain.run(docs)  

```

```
 CPU times: user 452 ms, sys: 60.3 ms, total: 512 ms  
 Wall time: 5.09 s  
  
  
 '\n\nPresident Biden is discussing the American Rescue Plan and the Bipartisan Infrastructure Law, which will create jobs and help Americans. He also talks about his vision for America, which includes investing in education and infrastructure. In response to Russian aggression in Ukraine, the United States is joining with European allies to impose sanctions and isolate Russia. American forces are being mobilized to protect NATO countries in the event that Putin decides to keep moving west. The Ukrainians are bravely fighting back, but the next few weeks will be hard for them. Putin will pay a high price for his actions in the long run. Americans should not be alarmed, as the United States is taking action to protect its interests and allies.'  

```
When we run it again, we see that it runs substantially faster but the final answer is different. This is due to caching at the map steps, but not at the reduce step.


```
chain.run(docs)  

```

```
 CPU times: user 11.5 ms, sys: 4.33 ms, total: 15.8 ms  
 Wall time: 1.04 s  
  
  
 '\n\nPresident Biden is discussing the American Rescue Plan and the Bipartisan Infrastructure Law, which will create jobs and help Americans. He also talks about his vision for America, which includes investing in education and infrastructure.'  

```

```
rm .langchain.db sqlite.db  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/models/llms/streaming_llm,"Streaming
=========

Some LLMs provide a streaming response. This means that instead of waiting for the entire response to be returned, you can start processing it as soon as it's available. This is useful if you want to display the response to the user as it's being generated, or if you want to process the response as it's being generated.

Currently, we support streaming for a broad range of LLM implementations, including but not limited to `OpenAI`, `ChatOpenAI`, `ChatAnthropic`, `Hugging Face Text Generation Inference`, and `Replicate`. This feature has been expanded to accommodate most of the models. To utilize streaming, use a [`CallbackHandler`](https://github.com/hwchase17/langchain/blob/master/langchain/callbacks/base.py) that implements `on_llm_new_token`. In this example, we are using `StreamingStdOutCallbackHandler`.


```
from langchain.llms import OpenAI  
from langchain.callbacks.streaming\_stdout import StreamingStdOutCallbackHandler  
  
  
llm = OpenAI(streaming=True, callbacks=[StreamingStdOutCallbackHandler()], temperature=0)  
resp = llm(""Write me a song about sparkling water."")  

```

```
 Verse 1  
 I'm sippin' on sparkling water,  
 It's so refreshing and light,  
 It's the perfect way to quench my thirst  
 On a hot summer night.  
   
 Chorus  
 Sparkling water, sparkling water,  
 It's the best way to stay hydrated,  
 It's so crisp and so clean,  
 It's the perfect way to stay refreshed.  
   
 Verse 2  
 I'm sippin' on sparkling water,  
 It's so bubbly and bright,  
 It's the perfect way to cool me down  
 On a hot summer night.  
   
 Chorus  
 Sparkling water, sparkling water,  
 It's the best way to stay hydrated,  
 It's so crisp and so clean,  
 It's the perfect way to stay refreshed.  
   
 Verse 3  
 I'm sippin' on sparkling water,  
 It's so light and so clear,  
 It's the perfect way to keep me cool  
 On a hot summer night.  
   
 Chorus  
 Sparkling water, sparkling water,  
 It's the best way to stay hydrated,  
 It's so crisp and so clean,  
 It's the perfect way to stay refreshed.  

```
We still have access to the end `LLMResult` if using `generate`. However, `token_usage` is not currently supported for streaming.


```
llm.generate([""Tell me a joke.""])  

```

```
 Q: What did the fish say when it hit the wall?  
 A: Dam!  
  
  
 LLMResult(generations=[[Generation(text='\n\nQ: What did the fish say when it hit the wall?\nA: Dam!', generation\_info={'finish\_reason': 'stop', 'logprobs': None})]], llm\_output={'token\_usage': {}, 'model\_name': 'text-davinci-003'})  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/output_parsers/comma_separated,"List parser
===========

This output parser can be used when you want to return a list of comma-separated items.


```
from langchain.output\_parsers import CommaSeparatedListOutputParser  
from langchain.prompts import PromptTemplate, ChatPromptTemplate, HumanMessagePromptTemplate  
from langchain.llms import OpenAI  
from langchain.chat\_models import ChatOpenAI  
  
output\_parser = CommaSeparatedListOutputParser()  

```

```
format\_instructions = output\_parser.get\_format\_instructions()  
prompt = PromptTemplate(  
 template=""List five {subject}.\n{format\_instructions}"",  
 input\_variables=[""subject""],  
 partial\_variables={""format\_instructions"": format\_instructions}  
)  

```

```
model = OpenAI(temperature=0)  

```

```
\_input = prompt.format(subject=""ice cream flavors"")  
output = model(\_input)  

```

```
output\_parser.parse(output)  

```

```
 ['Vanilla',  
 'Chocolate',  
 'Strawberry',  
 'Mint Chocolate Chip',  
 'Cookies and Cream']  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/output_parsers/,"Output parsers
==============

Language models output text. But many times you may want to get more structured information than just text back. This is where output parsers come in.

Output parsers are classes that help structure language model responses. There are two main methods an output parser must implement:

* ""Get format instructions"": A method which returns a string containing instructions for how the output of a language model should be formatted.
* ""Parse"": A method which takes in a string (assumed to be the response from a language model) and parses it into some structure.

And then one optional one:

* ""Parse with prompt"": A method which takes in a string (assumed to be the response from a language model) and a prompt (assumed to the prompt that generated such a response) and parses it into some structure. The prompt is largely provided in the event the OutputParser wants to retry or fix the output in some way, and needs information from the prompt to do so.

Get started[​](#get-started ""Direct link to Get started"")
---------------------------------------------------------

Below we go over the main type of output parser, the `PydanticOutputParser`.


```
from langchain.prompts import PromptTemplate, ChatPromptTemplate, HumanMessagePromptTemplate  
from langchain.llms import OpenAI  
from langchain.chat\_models import ChatOpenAI  
  
from langchain.output\_parsers import PydanticOutputParser  
from pydantic import BaseModel, Field, validator  
from typing import List  

```

```
model\_name = 'text-davinci-003'  
temperature = 0.0  
model = OpenAI(model\_name=model\_name, temperature=temperature)  

```

```
# Define your desired data structure.  
class Joke(BaseModel):  
 setup: str = Field(description=""question to set up a joke"")  
 punchline: str = Field(description=""answer to resolve the joke"")  
   
 # You can add custom validation logic easily with Pydantic.  
 @validator('setup')  
 def question\_ends\_with\_question\_mark(cls, field):  
 if field[-1] != '?':  
 raise ValueError(""Badly formed question!"")  
 return field  

```

```
# Set up a parser + inject instructions into the prompt template.  
parser = PydanticOutputParser(pydantic\_object=Joke)  

```

```
prompt = PromptTemplate(  
 template=""Answer the user query.\n{format\_instructions}\n{query}\n"",  
 input\_variables=[""query""],  
 partial\_variables={""format\_instructions"": parser.get\_format\_instructions()}  
)  

```

```
# And a query intended to prompt a language model to populate the data structure.  
joke\_query = ""Tell me a joke.""  
\_input = prompt.format\_prompt(query=joke\_query)  

```

```
output = model(\_input.to\_string())  

```

```
parser.parse(output)  

```

```
 Joke(setup='Why did the chicken cross the road?', punchline='To get to the other side!')  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/output_parsers/output_fixing_parser,"Auto-fixing parser
==================

This output parser wraps another output parser, and in the event that the first one fails it calls out to another LLM to fix any errors.

But we can do other things besides throw errors. Specifically, we can pass the misformatted output, along with the formatted instructions, to the model and ask it to fix it.

For this example, we'll use the above Pydantic output parser. Here's what happens if we pass it a result that does not comply with the schema:


```
from langchain.prompts import PromptTemplate, ChatPromptTemplate, HumanMessagePromptTemplate  
from langchain.llms import OpenAI  
from langchain.chat\_models import ChatOpenAI  
from langchain.output\_parsers import PydanticOutputParser  
from pydantic import BaseModel, Field, validator  
from typing import List  

```

```
class Actor(BaseModel):  
 name: str = Field(description=""name of an actor"")  
 film\_names: List[str] = Field(description=""list of names of films they starred in"")  
   
actor\_query = ""Generate the filmography for a random actor.""  
  
parser = PydanticOutputParser(pydantic\_object=Actor)  

```

```
misformatted = ""{'name': 'Tom Hanks', 'film\_names': ['Forrest Gump']}""  

```

```
parser.parse(misformatted)  

```

```
 ---------------------------------------------------------------------------  
  
 JSONDecodeError Traceback (most recent call last)  
  
 File ~/workplace/langchain/langchain/output\_parsers/pydantic.py:23, in PydanticOutputParser.parse(self, text)  
 22 json\_str = match.group()  
 ---> 23 json\_object = json.loads(json\_str)  
 24 return self.pydantic\_object.parse\_obj(json\_object)  
  
  
 File ~/.pyenv/versions/3.9.1/lib/python3.9/json/\_\_init\_\_.py:346, in loads(s, cls, object\_hook, parse\_float, parse\_int, parse\_constant, object\_pairs\_hook, \*\*kw)  
 343 if (cls is None and object\_hook is None and  
 344 parse\_int is None and parse\_float is None and  
 345 parse\_constant is None and object\_pairs\_hook is None and not kw):  
 --> 346 return \_default\_decoder.decode(s)  
 347 if cls is None:  
  
  
 File ~/.pyenv/versions/3.9.1/lib/python3.9/json/decoder.py:337, in JSONDecoder.decode(self, s, \_w)  
 333 """"""Return the Python representation of ``s`` (a ``str`` instance  
 334 containing a JSON document).  
 335   
 336 """"""  
 --> 337 obj, end = self.raw\_decode(s, idx=\_w(s, 0).end())  
 338 end = \_w(s, end).end()  
  
  
 File ~/.pyenv/versions/3.9.1/lib/python3.9/json/decoder.py:353, in JSONDecoder.raw\_decode(self, s, idx)  
 352 try:  
 --> 353 obj, end = self.scan\_once(s, idx)  
 354 except StopIteration as err:  
  
  
 JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)  
  
   
 During handling of the above exception, another exception occurred:  
  
  
 OutputParserException Traceback (most recent call last)  
  
 Cell In[6], line 1  
 ----> 1 parser.parse(misformatted)  
  
  
 File ~/workplace/langchain/langchain/output\_parsers/pydantic.py:29, in PydanticOutputParser.parse(self, text)  
 27 name = self.pydantic\_object.\_\_name\_\_  
 28 msg = f""Failed to parse {name} from completion {text}. Got: {e}""  
 ---> 29 raise OutputParserException(msg)  
  
  
 OutputParserException: Failed to parse Actor from completion {'name': 'Tom Hanks', 'film\_names': ['Forrest Gump']}. Got: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)  

```
Now we can construct and use a `OutputFixingParser`. This output parser takes as an argument another output parser but also an LLM with which to try to correct any formatting mistakes.


```
from langchain.output\_parsers import OutputFixingParser  
  
new\_parser = OutputFixingParser.from\_llm(parser=parser, llm=ChatOpenAI())  

```

```
new\_parser.parse(misformatted)  

```

```
 Actor(name='Tom Hanks', film\_names=['Forrest Gump'])  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/output_parsers/structured,"Structured output parser
========================

This output parser can be used when you want to return multiple fields. While the Pydantic/JSON parser is more powerful, we initially experimented with data structures having text fields only.


```
from langchain.output\_parsers import StructuredOutputParser, ResponseSchema  
from langchain.prompts import PromptTemplate, ChatPromptTemplate, HumanMessagePromptTemplate  
from langchain.llms import OpenAI  
from langchain.chat\_models import ChatOpenAI  

```
Here we define the response schema we want to receive.


```
response\_schemas = [  
 ResponseSchema(name=""answer"", description=""answer to the user's question""),  
 ResponseSchema(name=""source"", description=""source used to answer the user's question, should be a website."")  
]  
output\_parser = StructuredOutputParser.from\_response\_schemas(response\_schemas)  

```
We now get a string that contains instructions for how the response should be formatted, and we then insert that into our prompt.


```
format\_instructions = output\_parser.get\_format\_instructions()  
prompt = PromptTemplate(  
 template=""answer the users question as best as possible.\n{format\_instructions}\n{question}"",  
 input\_variables=[""question""],  
 partial\_variables={""format\_instructions"": format\_instructions}  
)  

```
We can now use this to format a prompt to send to the language model, and then parse the returned result.


```
model = OpenAI(temperature=0)  

```

```
\_input = prompt.format\_prompt(question=""what's the capital of france?"")  
output = model(\_input.to\_string())  

```

```
output\_parser.parse(output)  

```

```
 {'answer': 'Paris',  
 'source': 'https://www.worldatlas.com/articles/what-is-the-capital-of-france.html'}  

```
And here's an example of using this in a chat model


```
chat\_model = ChatOpenAI(temperature=0)  

```

```
prompt = ChatPromptTemplate(  
 messages=[  
 HumanMessagePromptTemplate.from\_template(""answer the users question as best as possible.\n{format\_instructions}\n{question}"")   
 ],  
 input\_variables=[""question""],  
 partial\_variables={""format\_instructions"": format\_instructions}  
)  

```

```
\_input = prompt.format\_prompt(question=""what's the capital of france?"")  
output = chat\_model(\_input.to\_messages())  

```

```
output\_parser.parse(output.content)  

```

```
 {'answer': 'Paris', 'source': 'https://en.wikipedia.org/wiki/Paris'}  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/prompts/example_selectors/,"Example selectors
=================

If you have a large number of examples, you may need to select which ones to include in the prompt. The Example Selector is the class responsible for doing so.

The base interface is defined as below:


```
class BaseExampleSelector(ABC):  
 """"""Interface for selecting examples to include in prompts.""""""  
  
 @abstractmethod  
 def select\_examples(self, input\_variables: Dict[str, str]) -> List[dict]:  
 """"""Select which examples to use based on the inputs.""""""  

```
The only method it needs to expose is a `select_examples` method. This takes in the input variables and then returns a list of examples. It is up to each specific implementation as to how those examples are selected. Let's take a look at some below.

",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/prompts/example_selectors/length_based,"Select by length
================

This example selector selects which examples to use based on length. This is useful when you are worried about constructing a prompt that will go over the length of the context window. For longer inputs, it will select fewer examples to include, while for shorter inputs it will select more.


```
from langchain.prompts import PromptTemplate  
from langchain.prompts import FewShotPromptTemplate  
from langchain.prompts.example\_selector import LengthBasedExampleSelector  
  
  
# These are a lot of examples of a pretend task of creating antonyms.  
examples = [  
 {""input"": ""happy"", ""output"": ""sad""},  
 {""input"": ""tall"", ""output"": ""short""},  
 {""input"": ""energetic"", ""output"": ""lethargic""},  
 {""input"": ""sunny"", ""output"": ""gloomy""},  
 {""input"": ""windy"", ""output"": ""calm""},  
  
example\_prompt = PromptTemplate(  
 input\_variables=[""input"", ""output""],  
 template=""Input: {input}\nOutput: {output}"",  
)  
example\_selector = LengthBasedExampleSelector(  
 # These are the examples it has available to choose from.  
 examples=examples,   
 # This is the PromptTemplate being used to format the examples.  
 example\_prompt=example\_prompt,   
 # This is the maximum length that the formatted examples should be.  
 # Length is measured by the get\_text\_length function below.  
 max\_length=25,  
 # This is the function used to get the length of a string, which is used  
 # to determine which examples to include. It is commented out because  
 # it is provided as a default value if none is specified.  
 # get\_text\_length: Callable[[str], int] = lambda x: len(re.split(""\n| "", x))  
)  
dynamic\_prompt = FewShotPromptTemplate(  
 # We provide an ExampleSelector instead of examples.  
 example\_selector=example\_selector,  
 example\_prompt=example\_prompt,  
 prefix=""Give the antonym of every input"",  
 suffix=""Input: {adjective}\nOutput:"",   
 input\_variables=[""adjective""],  
)  

```

```
# An example with small input, so it selects all examples.  
print(dynamic\_prompt.format(adjective=""big""))  

```

```
 Give the antonym of every input  
   
 Input: happy  
 Output: sad  
   
 Input: tall  
 Output: short  
   
 Input: energetic  
 Output: lethargic  
   
 Input: sunny  
 Output: gloomy  
   
 Input: windy  
 Output: calm  
   
 Input: big  
 Output:  

```

```
# An example with long input, so it selects only one example.  
long\_string = ""big and huge and massive and large and gigantic and tall and much much much much much bigger than everything else""  
print(dynamic\_prompt.format(adjective=long\_string))  

```

```
 Give the antonym of every input  
   
 Input: happy  
 Output: sad  
   
 Input: big and huge and massive and large and gigantic and tall and much much much much much bigger than everything else  
 Output:  

```

```
# You can add an example to an example selector as well.  
new\_example = {""input"": ""big"", ""output"": ""small""}  
dynamic\_prompt.example\_selector.add\_example(new\_example)  
print(dynamic\_prompt.format(adjective=""enthusiastic""))  

```

```
 Give the antonym of every input  
   
 Input: happy  
 Output: sad  
   
 Input: tall  
 Output: short  
   
 Input: energetic  
 Output: lethargic  
   
 Input: sunny  
 Output: gloomy  
   
 Input: windy  
 Output: calm  
   
 Input: big  
 Output: small  
   
 Input: enthusiastic  
 Output:  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/prompts/example_selectors/similarity,"Select by similarity
====================

This object selects examples based on similarity to the inputs. It does this by finding the examples with the embeddings that have the greatest cosine similarity with the inputs.


```
from langchain.prompts.example\_selector import SemanticSimilarityExampleSelector  
from langchain.vectorstores import Chroma  
from langchain.embeddings import OpenAIEmbeddings  
from langchain.prompts import FewShotPromptTemplate, PromptTemplate  
  
example\_prompt = PromptTemplate(  
 input\_variables=[""input"", ""output""],  
 template=""Input: {input}\nOutput: {output}"",  
)  
  
# These are a lot of examples of a pretend task of creating antonyms.  
examples = [  
 {""input"": ""happy"", ""output"": ""sad""},  
 {""input"": ""tall"", ""output"": ""short""},  
 {""input"": ""energetic"", ""output"": ""lethargic""},  
 {""input"": ""sunny"", ""output"": ""gloomy""},  
 {""input"": ""windy"", ""output"": ""calm""},  
]  

```

```
example\_selector = SemanticSimilarityExampleSelector.from\_examples(  
 # This is the list of examples available to select from.  
 examples,   
 # This is the embedding class used to produce embeddings which are used to measure semantic similarity.  
 OpenAIEmbeddings(),   
 # This is the VectorStore class that is used to store the embeddings and do a similarity search over.  
 Chroma,   
 # This is the number of examples to produce.  
 k=1  
)  
similar\_prompt = FewShotPromptTemplate(  
 # We provide an ExampleSelector instead of examples.  
 example\_selector=example\_selector,  
 example\_prompt=example\_prompt,  
 prefix=""Give the antonym of every input"",  
 suffix=""Input: {adjective}\nOutput:"",   
 input\_variables=[""adjective""],  
)  

```

```
 Running Chroma using direct local API.  
 Using DuckDB in-memory for database. Data will be transient.  

```

```
# Input is a feeling, so should select the happy/sad example  
print(similar\_prompt.format(adjective=""worried""))  

```

```
 Give the antonym of every input  
   
 Input: happy  
 Output: sad  
   
 Input: worried  
 Output:  

```

```
# Input is a measurement, so should select the tall/short example  
print(similar\_prompt.format(adjective=""fat""))  

```

```
 Give the antonym of every input  
   
 Input: happy  
 Output: sad  
   
 Input: fat  
 Output:  

```

```
# You can add new examples to the SemanticSimilarityExampleSelector as well  
similar\_prompt.example\_selector.add\_example({""input"": ""enthusiastic"", ""output"": ""apathetic""})  
print(similar\_prompt.format(adjective=""joyful""))  

```

```
 Give the antonym of every input  
   
 Input: happy  
 Output: sad  
   
 Input: joyful  
 Output:  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/prompts/,"Prompts
=======

The new way of programming models is through prompts.
A **prompt** refers to the input to the model.
This input is often constructed from multiple components.
LangChain provides several classes and functions to make constructing and working with prompts easy.

* [Prompt templates](/docs/modules/model_io/prompts/prompt_templates/): Parametrize model inputs
* [Example selectors](/docs/modules/model_io/prompts/example_selectors/): Dynamically select examples to include in prompts
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/prompts/prompt_templates/few_shot_examples,"Few-shot prompt templates
=========================

In this tutorial, we'll learn how to create a prompt template that uses few shot examples. A few shot prompt template can be constructed from either a set of examples, or from an Example Selector object.

### Use Case[​](#use-case ""Direct link to Use Case"")

In this tutorial, we'll configure few shot examples for self-ask with search.

Using an example set[​](#using-an-example-set ""Direct link to Using an example set"")
------------------------------------------------------------------------------------

### Create the example set[​](#create-the-example-set ""Direct link to Create the example set"")

To get started, create a list of few shot examples. Each example should be a dictionary with the keys being the input variables and the values being the values for those input variables.


```
from langchain.prompts.few\_shot import FewShotPromptTemplate  
from langchain.prompts.prompt import PromptTemplate  
  
examples = [  
 {  
 ""question"": ""Who lived longer, Muhammad Ali or Alan Turing?"",  
 ""answer"":   
""""""  
Are follow up questions needed here: Yes.  
Follow up: How old was Muhammad Ali when he died?  
Intermediate answer: Muhammad Ali was 74 years old when he died.  
Follow up: How old was Alan Turing when he died?  
Intermediate answer: Alan Turing was 41 years old when he died.  
So the final answer is: Muhammad Ali  
""""""  
 },  
 {  
 ""question"": ""When was the founder of craigslist born?"",  
 ""answer"":   
""""""  
Are follow up questions needed here: Yes.  
Follow up: Who was the founder of craigslist?  
Intermediate answer: Craigslist was founded by Craig Newmark.  
Follow up: When was Craig Newmark born?  
Intermediate answer: Craig Newmark was born on December 6, 1952.  
So the final answer is: December 6, 1952  
""""""  
 },  
 {  
 ""question"": ""Who was the maternal grandfather of George Washington?"",  
 ""answer"":  
""""""  
Are follow up questions needed here: Yes.  
Follow up: Who was the mother of George Washington?  
Intermediate answer: The mother of George Washington was Mary Ball Washington.  
Follow up: Who was the father of Mary Ball Washington?  
Intermediate answer: The father of Mary Ball Washington was Joseph Ball.  
So the final answer is: Joseph Ball  
""""""  
 },  
 {  
 ""question"": ""Are both the directors of Jaws and Casino Royale from the same country?"",  
 ""answer"":  
""""""  
Are follow up questions needed here: Yes.  
Follow up: Who is the director of Jaws?  
Intermediate Answer: The director of Jaws is Steven Spielberg.  
Follow up: Where is Steven Spielberg from?  
Intermediate Answer: The United States.  
Follow up: Who is the director of Casino Royale?  
Intermediate Answer: The director of Casino Royale is Martin Campbell.  
Follow up: Where is Martin Campbell from?  
Intermediate Answer: New Zealand.  
So the final answer is: No  
""""""  
 }  
]  

```
### Create a formatter for the few shot examples[​](#create-a-formatter-for-the-few-shot-examples ""Direct link to Create a formatter for the few shot examples"")

Configure a formatter that will format the few shot examples into a string. This formatter should be a `PromptTemplate` object.


```
example\_prompt = PromptTemplate(input\_variables=[""question"", ""answer""], template=""Question: {question}\n{answer}"")  
  
print(example\_prompt.format(\*\*examples[0]))  

```

```
 Question: Who lived longer, Muhammad Ali or Alan Turing?  
   
 Are follow up questions needed here: Yes.  
 Follow up: How old was Muhammad Ali when he died?  
 Intermediate answer: Muhammad Ali was 74 years old when he died.  
 Follow up: How old was Alan Turing when he died?  
 Intermediate answer: Alan Turing was 41 years old when he died.  
 So the final answer is: Muhammad Ali  
   

```
### Feed examples and formatter to `FewShotPromptTemplate`[​](#feed-examples-and-formatter-to-fewshotprompttemplate ""Direct link to feed-examples-and-formatter-to-fewshotprompttemplate"")

Finally, create a `FewShotPromptTemplate` object. This object takes in the few shot examples and the formatter for the few shot examples.


```
prompt = FewShotPromptTemplate(  
 examples=examples,   
 example\_prompt=example\_prompt,   
 suffix=""Question: {input}"",   
 input\_variables=[""input""]  
)  
  
print(prompt.format(input=""Who was the father of Mary Ball Washington?""))  

```

```
 Question: Who lived longer, Muhammad Ali or Alan Turing?  
   
 Are follow up questions needed here: Yes.  
 Follow up: How old was Muhammad Ali when he died?  
 Intermediate answer: Muhammad Ali was 74 years old when he died.  
 Follow up: How old was Alan Turing when he died?  
 Intermediate answer: Alan Turing was 41 years old when he died.  
 So the final answer is: Muhammad Ali  
   
   
 Question: When was the founder of craigslist born?  
   
 Are follow up questions needed here: Yes.  
 Follow up: Who was the founder of craigslist?  
 Intermediate answer: Craigslist was founded by Craig Newmark.  
 Follow up: When was Craig Newmark born?  
 Intermediate answer: Craig Newmark was born on December 6, 1952.  
 So the final answer is: December 6, 1952  
   
   
 Question: Who was the maternal grandfather of George Washington?  
   
 Are follow up questions needed here: Yes.  
 Follow up: Who was the mother of George Washington?  
 Intermediate answer: The mother of George Washington was Mary Ball Washington.  
 Follow up: Who was the father of Mary Ball Washington?  
 Intermediate answer: The father of Mary Ball Washington was Joseph Ball.  
 So the final answer is: Joseph Ball  
   
   
 Question: Are both the directors of Jaws and Casino Royale from the same country?  
   
 Are follow up questions needed here: Yes.  
 Follow up: Who is the director of Jaws?  
 Intermediate Answer: The director of Jaws is Steven Spielberg.  
 Follow up: Where is Steven Spielberg from?  
 Intermediate Answer: The United States.  
 Follow up: Who is the director of Casino Royale?  
 Intermediate Answer: The director of Casino Royale is Martin Campbell.  
 Follow up: Where is Martin Campbell from?  
 Intermediate Answer: New Zealand.  
 So the final answer is: No  
   
   
 Question: Who was the father of Mary Ball Washington?  

```
Using an example selector[​](#using-an-example-selector ""Direct link to Using an example selector"")
---------------------------------------------------------------------------------------------------

### Feed examples into `ExampleSelector`[​](#feed-examples-into-exampleselector ""Direct link to feed-examples-into-exampleselector"")

We will reuse the example set and the formatter from the previous section. However, instead of feeding the examples directly into the `FewShotPromptTemplate` object, we will feed them into an `ExampleSelector` object.

In this tutorial, we will use the `SemanticSimilarityExampleSelector` class. This class selects few shot examples based on their similarity to the input. It uses an embedding model to compute the similarity between the input and the few shot examples, as well as a vector store to perform the nearest neighbor search.


```
from langchain.prompts.example\_selector import SemanticSimilarityExampleSelector  
from langchain.vectorstores import Chroma  
from langchain.embeddings import OpenAIEmbeddings  
  
  
example\_selector = SemanticSimilarityExampleSelector.from\_examples(  
 # This is the list of examples available to select from.  
 examples,  
 # This is the embedding class used to produce embeddings which are used to measure semantic similarity.  
 OpenAIEmbeddings(),  
 # This is the VectorStore class that is used to store the embeddings and do a similarity search over.  
 Chroma,  
 # This is the number of examples to produce.  
 k=1  
)  
  
# Select the most similar example to the input.  
question = ""Who was the father of Mary Ball Washington?""  
selected\_examples = example\_selector.select\_examples({""question"": question})  
print(f""Examples most similar to the input: {question}"")  
for example in selected\_examples:  
 print(""\n"")  
 for k, v in example.items():  
 print(f""{k}: {v}"")  

```

```
 Running Chroma using direct local API.  
 Using DuckDB in-memory for database. Data will be transient.  
 Examples most similar to the input: Who was the father of Mary Ball Washington?  
   
   
 question: Who was the maternal grandfather of George Washington?  
 answer:   
 Are follow up questions needed here: Yes.  
 Follow up: Who was the mother of George Washington?  
 Intermediate answer: The mother of George Washington was Mary Ball Washington.  
 Follow up: Who was the father of Mary Ball Washington?  
 Intermediate answer: The father of Mary Ball Washington was Joseph Ball.  
 So the final answer is: Joseph Ball  
   

```
### Feed example selector into `FewShotPromptTemplate`[​](#feed-example-selector-into-fewshotprompttemplate ""Direct link to feed-example-selector-into-fewshotprompttemplate"")

Finally, create a `FewShotPromptTemplate` object. This object takes in the example selector and the formatter for the few shot examples.


```
prompt = FewShotPromptTemplate(  
 example\_selector=example\_selector,   
 example\_prompt=example\_prompt,   
 suffix=""Question: {input}"",   
 input\_variables=[""input""]  
)  
  
print(prompt.format(input=""Who was the father of Mary Ball Washington?""))  

```

```
 Question: Who was the maternal grandfather of George Washington?  
   
 Are follow up questions needed here: Yes.  
 Follow up: Who was the mother of George Washington?  
 Intermediate answer: The mother of George Washington was Mary Ball Washington.  
 Follow up: Who was the father of Mary Ball Washington?  
 Intermediate answer: The father of Mary Ball Washington was Joseph Ball.  
 So the final answer is: Joseph Ball  
   
   
 Question: Who was the father of Mary Ball Washington?  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/prompts/prompt_templates/,"Prompt templates
================

Language models take text as input - that text is commonly referred to as a prompt.
Typically this is not simply a hardcoded string but rather a combination of a template, some examples, and user input.
LangChain provides several classes and functions to make constructing and working with prompts easy.

What is a prompt template?[​](#what-is-a-prompt-template ""Direct link to What is a prompt template?"")
-----------------------------------------------------------------------------------------------------

A prompt template refers to a reproducible way to generate a prompt. It contains a text string (""the template""), that can take in a set of parameters from the end user and generates a prompt.

A prompt template can contain:

* instructions to the language model,
* a set of few shot examples to help the language model generate a better response,
* a question to the language model.

Here's the simplest example:


```
from langchain import PromptTemplate  
  
  
template = """"""\  
You are a naming consultant for new companies.  
What is a good name for a company that makes {product}?  
""""""  
  
prompt = PromptTemplate.from\_template(template)  
prompt.format(product=""colorful socks"")  

```

```
You are a naming consultant for new companies.  
What is a good name for a company that makes colorful socks?  

```
Create a prompt template[​](#create-a-prompt-template ""Direct link to Create a prompt template"")
------------------------------------------------------------------------------------------------

You can create simple hardcoded prompts using the `PromptTemplate` class. Prompt templates can take any number of input variables, and can be formatted to generate a prompt.


```
from langchain import PromptTemplate  
  
# An example prompt with no input variables  
no\_input\_prompt = PromptTemplate(input\_variables=[], template=""Tell me a joke."")  
no\_input\_prompt.format()  
# -> ""Tell me a joke.""  
  
# An example prompt with one input variable  
one\_input\_prompt = PromptTemplate(input\_variables=[""adjective""], template=""Tell me a {adjective} joke."")  
one\_input\_prompt.format(adjective=""funny"")  
# -> ""Tell me a funny joke.""  
  
# An example prompt with multiple input variables  
multiple\_input\_prompt = PromptTemplate(  
 input\_variables=[""adjective"", ""content""],   
 template=""Tell me a {adjective} joke about {content}.""  
)  
multiple\_input\_prompt.format(adjective=""funny"", content=""chickens"")  
# -> ""Tell me a funny joke about chickens.""  

```
If you do not wish to specify `input_variables` manually, you can also create a `PromptTemplate` using `from_template` class method. `langchain` will automatically infer the `input_variables` based on the `template` passed.


```
template = ""Tell me a {adjective} joke about {content}.""  
  
prompt\_template = PromptTemplate.from\_template(template)  
prompt\_template.input\_variables  
# -> ['adjective', 'content']  
prompt\_template.format(adjective=""funny"", content=""chickens"")  
# -> Tell me a funny joke about chickens.  

```
You can create custom prompt templates that format the prompt in any way you want. For more information, see [Custom Prompt Templates](/docs/modules/model_io/prompts/prompt_templates/custom_prompt_template.html).

Chat prompt template[​](#chat-prompt-template ""Direct link to Chat prompt template"")
------------------------------------------------------------------------------------

[Chat Models](/docs/modules/model_io/prompts/models/chat) take a list of chat messages as input - this list commonly referred to as a `prompt`.
These chat messages differ from raw string (which you would pass into a [LLM](/docs/modules/model_io/models/llms) model) in that every message is associated with a `role`.

For example, in OpenAI [Chat Completion API](https://platform.openai.com/docs/guides/chat/introduction), a chat message can be associated with the AI, human or system role. The model is supposed to follow instruction from system chat message more closely.

LangChain provides several prompt templates to make constructing and working with prompts easily. You are encouraged to use these chat related prompt templates instead of `PromptTemplate` when querying chat models to fully exploit the potential of underlying chat model.


```
from langchain.prompts import (  
 ChatPromptTemplate,  
 PromptTemplate,  
 SystemMessagePromptTemplate,  
 AIMessagePromptTemplate,  
 HumanMessagePromptTemplate,  
)  
from langchain.schema import (  
 AIMessage,  
 HumanMessage,  
 SystemMessage  
)  

```
To create a message template associated with a role, you use `MessagePromptTemplate`.

For convenience, there is a `from_template` method exposed on the template. If you were to use this template, this is what it would look like:


```
template=""You are a helpful assistant that translates {input\_language} to {output\_language}.""  
system\_message\_prompt = SystemMessagePromptTemplate.from\_template(template)  
human\_template=""{text}""  
human\_message\_prompt = HumanMessagePromptTemplate.from\_template(human\_template)  

```
If you wanted to construct the `MessagePromptTemplate` more directly, you could create a PromptTemplate outside and then pass it in, eg:


```
prompt=PromptTemplate(  
 template=""You are a helpful assistant that translates {input\_language} to {output\_language}."",  
 input\_variables=[""input\_language"", ""output\_language""],  
)  
system\_message\_prompt\_2 = SystemMessagePromptTemplate(prompt=prompt)  
  
assert system\_message\_prompt == system\_message\_prompt\_2  

```
After that, you can build a `ChatPromptTemplate` from one or more `MessagePromptTemplates`. You can use `ChatPromptTemplate`'s `format_prompt` -- this returns a `PromptValue`, which you can convert to a string or Message object, depending on whether you want to use the formatted value as input to an llm or chat model.


```
chat\_prompt = ChatPromptTemplate.from\_messages([system\_message\_prompt, human\_message\_prompt])  
  
# get a chat completion from the formatted messages  
chat\_prompt.format\_prompt(input\_language=""English"", output\_language=""French"", text=""I love programming."").to\_messages()  

```

```
 [SystemMessage(content='You are a helpful assistant that translates English to French.', additional\_kwargs={}),  
 HumanMessage(content='I love programming.', additional\_kwargs={})]  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/prompts/prompt_templates/partial,"Partial prompt templates
========================

Like other methods, it can make sense to ""partial"" a prompt template - eg pass in a subset of the required values, as to create a new prompt template which expects only the remaining subset of values.

LangChain supports this in two ways:

1. Partial formatting with string values.
2. Partial formatting with functions that return string values.

These two different ways support different use cases. In the examples below, we go over the motivations for both use cases as well as how to do it in LangChain.

Partial With Strings[​](#partial-with-strings ""Direct link to Partial With Strings"")
------------------------------------------------------------------------------------

One common use case for wanting to partial a prompt template is if you get some of the variables before others. For example, suppose you have a prompt template that requires two variables, `foo` and `baz`. If you get the `foo` value early on in the chain, but the `baz` value later, it can be annoying to wait until you have both variables in the same place to pass them to the prompt template. Instead, you can partial the prompt template with the `foo` value, and then pass the partialed prompt template along and just use that. Below is an example of doing this:


```
from langchain.prompts import PromptTemplate  

```

```
prompt = PromptTemplate(template=""{foo}{bar}"", input\_variables=[""foo"", ""bar""])  
partial\_prompt = prompt.partial(foo=""foo"");  
print(partial\_prompt.format(bar=""baz""))  

```

```
 foobaz  

```
You can also just initialize the prompt with the partialed variables.


```
prompt = PromptTemplate(template=""{foo}{bar}"", input\_variables=[""bar""], partial\_variables={""foo"": ""foo""})  
print(prompt.format(bar=""baz""))  

```

```
 foobaz  

```
Partial With Functions[​](#partial-with-functions ""Direct link to Partial With Functions"")
------------------------------------------------------------------------------------------

The other common use is to partial with a function. The use case for this is when you have a variable you know that you always want to fetch in a common way. A prime example of this is with date or time. Imagine you have a prompt which you always want to have the current date. You can't hard code it in the prompt, and passing it along with the other input variables is a bit annoying. In this case, it's very handy to be able to partial the prompt with a function that always returns the current date.


```
from datetime import datetime  
  
def \_get\_datetime():  
 now = datetime.now()  
 return now.strftime(""%m/%d/%Y, %H:%M:%S"")  

```

```
prompt = PromptTemplate(  
 template=""Tell me a {adjective} joke about the day {date}"",   
 input\_variables=[""adjective"", ""date""]  
);  
partial\_prompt = prompt.partial(date=\_get\_datetime)  
print(partial\_prompt.format(adjective=""funny""))  

```

```
 Tell me a funny joke about the day 02/27/2023, 22:15:16  

```
You can also just initialize the prompt with the partialed variables, which often makes more sense in this workflow.


```
prompt = PromptTemplate(  
 template=""Tell me a {adjective} joke about the day {date}"",   
 input\_variables=[""adjective""],  
 partial\_variables={""date"": \_get\_datetime}  
);  
print(prompt.format(adjective=""funny""))  

```

```
 Tell me a funny joke about the day 02/27/2023, 22:15:16  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/modules/model_io/prompts/prompt_templates/prompt_composition,"Composition
===========

This notebook goes over how to compose multiple prompts together. This can be useful when you want to reuse parts of prompts. This can be done with a PipelinePrompt. A PipelinePrompt consists of two main parts:

* Final prompt: This is the final prompt that is returned
* Pipeline prompts: This is a list of tuples, consisting of a string name and a prompt template. Each prompt template will be formatted and then passed to future prompt templates as a variable with the same name.


```
from langchain.prompts.pipeline import PipelinePromptTemplate  
from langchain.prompts.prompt import PromptTemplate  

```

```
full\_template = """"""{introduction}  
  
{example}  
  
{start}""""""  
full\_prompt = PromptTemplate.from\_template(full\_template)  

```

```
introduction\_template = """"""You are impersonating {person}.""""""  
introduction\_prompt = PromptTemplate.from\_template(introduction\_template)  

```

```
example\_template = """"""Here's an example of an interaction:   
  
Q: {example\_q}  
A: {example\_a}""""""  
example\_prompt = PromptTemplate.from\_template(example\_template)  

```

```
start\_template = """"""Now, do this for real!  
  
Q: {input}  
A:""""""  
start\_prompt = PromptTemplate.from\_template(start\_template)  

```

```
input\_prompts = [  
 (""introduction"", introduction\_prompt),  
 (""example"", example\_prompt),  
 (""start"", start\_prompt)  
]  
pipeline\_prompt = PipelinePromptTemplate(final\_prompt=full\_prompt, pipeline\_prompts=input\_prompts)  

```

```
pipeline\_prompt.input\_variables  

```

```
 ['example\_a', 'person', 'example\_q', 'input']  

```

```
print(pipeline\_prompt.format(  
 person=""Elon Musk"",  
 example\_q=""What's your favorite car?"",  
 example\_a=""Tesla"",  
 input=""What's your favorite social media site?""  
))  

```

```
 You are impersonating Elon Musk.  
 Here's an example of an interaction:   
   
 Q: What's your favorite car?  
 A: Tesla  
 Now, do this for real!  
   
 Q: What's your favorite social media site?  
 A:  
   

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/use_cases/apis/api,"API chains
==========

APIChain enables using LLMs to interact with APIs to retrieve relevant information. Construct the chain by providing a question relevant to the provided API documentation.


```
from langchain.chains.api.prompt import API\_RESPONSE\_PROMPT  

```

```
from langchain.chains import APIChain  
from langchain.prompts.prompt import PromptTemplate  
  
  
from langchain.llms import OpenAI  
  
llm = OpenAI(temperature=0)  

```
OpenMeteo Example[​](#openmeteo-example ""Direct link to OpenMeteo Example"")
---------------------------------------------------------------------------


```
from langchain.chains.api import open\_meteo\_docs  
chain\_new = APIChain.from\_llm\_and\_api\_docs(llm, open\_meteo\_docs.OPEN\_METEO\_DOCS, verbose=True)  

```

```
chain\_new.run('What is the weather like right now in Munich, Germany in degrees Fahrenheit?')  

```

```
  
  
 > Entering new APIChain chain...  
 https://api.open-meteo.com/v1/forecast?latitude=48.1351&longitude=11.5820&temperature\_unit=fahrenheit&current\_weather=true  
 {""latitude"":48.14,""longitude"":11.58,""generationtime\_ms"":0.33104419708251953,""utc\_offset\_seconds"":0,""timezone"":""GMT"",""timezone\_abbreviation"":""GMT"",""elevation"":521.0,""current\_weather"":{""temperature"":33.4,""windspeed"":6.8,""winddirection"":198.0,""weathercode"":2,""time"":""2023-01-16T01:00""}}  
  
 > Finished chain.  
  
  
  
  
  
 ' The current temperature in Munich, Germany is 33.4 degrees Fahrenheit with a windspeed of 6.8 km/h and a wind direction of 198 degrees. The weathercode is 2.'  

```
TMDB Example[​](#tmdb-example ""Direct link to TMDB Example"")
------------------------------------------------------------


```
import os  
os.environ['TMDB\_BEARER\_TOKEN'] = """"  

```

```
from langchain.chains.api import tmdb\_docs  
headers = {""Authorization"": f""Bearer {os.environ['TMDB\_BEARER\_TOKEN']}""}  
chain = APIChain.from\_llm\_and\_api\_docs(llm, tmdb\_docs.TMDB\_DOCS, headers=headers, verbose=True)  

```

```
chain.run(""Search for 'Avatar'"")  

```

```
  
  
 > Entering new APIChain chain...  
 https://api.themoviedb.org/3/search/movie?query=Avatar&language=en-US  
 {""page"":1,""results"":[{""adult"":false,""backdrop\_path"":""/o0s4XsEDfDlvit5pDRKjzXR4pp2.jpg"",""genre\_ids"":[28,12,14,878],""id"":19995,""original\_language"":""en"",""original\_title"":""Avatar"",""overview"":""In the 22nd century, a paraplegic Marine is dispatched to the moon Pandora on a unique mission, but becomes torn between following orders and protecting an alien civilization."",""popularity"":2041.691,""poster\_path"":""/jRXYjXNq0Cs2TcJjLkki24MLp7u.jpg"",""release\_date"":""2009-12-15"",""title"":""Avatar"",""video"":false,""vote\_average"":7.6,""vote\_count"":27777},{""adult"":false,""backdrop\_path"":""/s16H6tpK2utvwDtzZ8Qy4qm5Emw.jpg"",""genre\_ids"":[878,12,28],""id"":76600,""original\_language"":""en"",""original\_title"":""Avatar: The Way of Water"",""overview"":""Set more than a decade after the events of the first film, learn the story of the Sully family (Jake, Neytiri, and their kids), the trouble that follows them, the lengths they go to keep each other safe, the battles they fight to stay alive, and the tragedies they endure."",""popularity"":3948.296,""poster\_path"":""/t6HIqrRAclMCA60NsSmeqe9RmNV.jpg"",""release\_date"":""2022-12-14"",""title"":""Avatar: The Way of Water"",""video"":false,""vote\_average"":7.7,""vote\_count"":4219},{""adult"":false,""backdrop\_path"":""/uEwGFGtao9YG2JolmdvtHLLVbA9.jpg"",""genre\_ids"":[99],""id"":111332,""original\_language"":""en"",""original\_title"":""Avatar: Creating the World of Pandora"",""overview"":""The Making-of James Cameron's Avatar. It shows interesting parts of the work on the set."",""popularity"":541.809,""poster\_path"":""/sjf3xjuofCtDhZghJRzXlTiEjJe.jpg"",""release\_date"":""2010-02-07"",""title"":""Avatar: Creating the World of Pandora"",""video"":false,""vote\_average"":7.3,""vote\_count"":35},{""adult"":false,""backdrop\_path"":null,""genre\_ids"":[99],""id"":287003,""original\_language"":""en"",""original\_title"":""Avatar: Scene Deconstruction"",""overview"":""The deconstruction of the Avatar scenes and sets"",""popularity"":394.941,""poster\_path"":""/uCreCQFReeF0RiIXkQypRYHwikx.jpg"",""release\_date"":""2009-12-18"",""title"":""Avatar: Scene Deconstruction"",""video"":false,""vote\_average"":7.8,""vote\_count"":12},{""adult"":false,""backdrop\_path"":null,""genre\_ids"":[28,18,878,12,14],""id"":83533,""original\_language"":""en"",""original\_title"":""Avatar 3"",""overview"":"""",""popularity"":172.488,""poster\_path"":""/4rXqTMlkEaMiJjiG0Z2BX6F6Dkm.jpg"",""release\_date"":""2024-12-18"",""title"":""Avatar 3"",""video"":false,""vote\_average"":0,""vote\_count"":0},{""adult"":false,""backdrop\_path"":null,""genre\_ids"":[28,878,12,14],""id"":216527,""original\_language"":""en"",""original\_title"":""Avatar 4"",""overview"":"""",""popularity"":162.536,""poster\_path"":""/qzMYKnT4MG1d0gnhwytr4cKhUvS.jpg"",""release\_date"":""2026-12-16"",""title"":""Avatar 4"",""video"":false,""vote\_average"":0,""vote\_count"":0},{""adult"":false,""backdrop\_path"":null,""genre\_ids"":[28,12,14,878],""id"":393209,""original\_language"":""en"",""original\_title"":""Avatar 5"",""overview"":"""",""popularity"":124.722,""poster\_path"":""/rtmmvqkIC5zDMEd638Es2woxbz8.jpg"",""release\_date"":""2028-12-20"",""title"":""Avatar 5"",""video"":false,""vote\_average"":0,""vote\_count"":0},{""adult"":false,""backdrop\_path"":""/nNceJtrrovG1MUBHMAhId0ws9Gp.jpg"",""genre\_ids"":[99],""id"":183392,""original\_language"":""en"",""original\_title"":""Capturing Avatar"",""overview"":""Capturing Avatar is a feature length behind-the-scenes documentary about the making of Avatar. It uses footage from the film's development, as well as stock footage from as far back as the production of Titanic in 1995. Also included are numerous interviews with cast, artists, and other crew members. The documentary was released as a bonus feature on the extended collector's edition of Avatar."",""popularity"":109.842,""poster\_path"":""/26SMEXJl3978dn2svWBSqHbLl5U.jpg"",""release\_date"":""2010-11-16"",""title"":""Capturing Avatar"",""video"":false,""vote\_average"":7.8,""vote\_count"":39},{""adult"":false,""backdrop\_path"":""/eoAvHxfbaPOcfiQyjqypWIXWxDr.jpg"",""genre\_ids"":[99],""id"":1059673,""original\_language"":""en"",""original\_title"":""Avatar: The Deep Dive - A Special Edition of 20/20"",""overview"":""An inside look at one of the most anticipated movie sequels ever with James Cameron and cast."",""popularity"":629.825,""poster\_path"":""/rtVeIsmeXnpjNbEKnm9Say58XjV.jpg"",""release\_date"":""2022-12-14"",""title"":""Avatar: The Deep Dive - A Special Edition of 20/20"",""video"":false,""vote\_average"":6.5,""vote\_count"":5},{""adult"":false,""backdrop\_path"":null,""genre\_ids"":[99],""id"":278698,""original\_language"":""en"",""original\_title"":""Avatar Spirits"",""overview"":""Bryan Konietzko and Michael Dante DiMartino, co-creators of the hit television series, Avatar: The Last Airbender, reflect on the creation of the masterful series."",""popularity"":51.593,""poster\_path"":""/oBWVyOdntLJd5bBpE0wkpN6B6vy.jpg"",""release\_date"":""2010-06-22"",""title"":""Avatar Spirits"",""video"":false,""vote\_average"":9,""vote\_count"":16},{""adult"":false,""backdrop\_path"":""/cACUWJKvRfhXge7NC0xxoQnkQNu.jpg"",""genre\_ids"":[10402],""id"":993545,""original\_language"":""fr"",""original\_title"":""Avatar - Au Hellfest 2022"",""overview"":"""",""popularity"":21.992,""poster\_path"":""/fw6cPIsQYKjd1YVQanG2vLc5HGo.jpg"",""release\_date"":""2022-06-26"",""title"":""Avatar - Au Hellfest 2022"",""video"":false,""vote\_average"":8,""vote\_count"":4},{""adult"":false,""backdrop\_path"":null,""genre\_ids"":[],""id"":931019,""original\_language"":""en"",""original\_title"":""Avatar: Enter The World"",""overview"":""A behind the scenes look at the new James Cameron blockbuster “Avatar”, which stars Aussie Sam Worthington. Hastily produced by Australia’s Nine Network following the film’s release."",""popularity"":30.903,""poster\_path"":""/9MHY9pYAgs91Ef7YFGWEbP4WJqC.jpg"",""release\_date"":""2009-12-05"",""title"":""Avatar: Enter The World"",""video"":false,""vote\_average"":2,""vote\_count"":1},{""adult"":false,""backdrop\_path"":null,""genre\_ids"":[],""id"":287004,""original\_language"":""en"",""original\_title"":""Avatar: Production Materials"",""overview"":""Production material overview of what was used in Avatar"",""popularity"":12.389,""poster\_path"":null,""release\_date"":""2009-12-18"",""title"":""Avatar: Production Materials"",""video"":true,""vote\_average"":6,""vote\_count"":4},{""adult"":false,""backdrop\_path"":""/x43RWEZg9tYRPgnm43GyIB4tlER.jpg"",""genre\_ids"":[],""id"":740017,""original\_language"":""es"",""original\_title"":""Avatar: Agni Kai"",""overview"":"""",""popularity"":9.462,""poster\_path"":""/y9PrKMUTA6NfIe5FE92tdwOQ2sH.jpg"",""release\_date"":""2020-01-18"",""title"":""Avatar: Agni Kai"",""video"":false,""vote\_average"":7,""vote\_count"":1},{""adult"":false,""backdrop\_path"":""/e8mmDO7fKK93T4lnxl4Z2zjxXZV.jpg"",""genre\_ids"":[],""id"":668297,""original\_language"":""en"",""original\_title"":""The Last Avatar"",""overview"":""The Last Avatar is a mystical adventure film, a story of a young man who leaves Hollywood to find himself. What he finds is beyond his wildest imagination. Based on ancient prophecy, contemporary truth seeking and the future of humanity, The Last Avatar is a film that takes transformational themes and makes them relevant for audiences of all ages. Filled with love, magic, mystery, conspiracy, psychics, underground cities, secret societies, light bodies and much more, The Last Avatar tells the story of the emergence of Kalki Avatar- the final Avatar of our current Age of Chaos. Kalki is also a metaphor for the innate power and potential that lies within humanity to awaken and create a world of truth, harmony and possibility."",""popularity"":8.786,""poster\_path"":""/XWz5SS5g5mrNEZjv3FiGhqCMOQ.jpg"",""release\_date"":""2014-12-06"",""title"":""The Last Avatar"",""video"":false,""vote\_average"":4.5,""vote\_count"":2},{""adult"":false,""backdrop\_path"":null,""genre\_ids"":[],""id"":424768,""original\_language"":""en"",""original\_title"":""Avatar:[2015] Wacken Open Air"",""overview"":""Started in the summer of 2001 by drummer John Alfredsson and vocalist Christian Rimmi under the name Lost Soul. The band offers a free mp3 download to a song called \""Bloody Knuckles\"" if one subscribes to their newsletter. In 2005 they appeared on the compilation “Listen to Your Inner Voice” together with 17 other bands released by Inner Voice Records."",""popularity"":6.634,""poster\_path"":null,""release\_date"":""2015-08-01"",""title"":""Avatar:[2015] Wacken Open Air"",""video"":false,""vote\_average"":8,""vote\_count"":1},{""adult"":false,""backdrop\_path"":null,""genre\_ids"":[],""id"":812836,""original\_language"":""en"",""original\_title"":""Avatar - Live At Graspop 2018"",""overview"":""Live At Graspop Festival Belgium 2018"",""popularity"":9.855,""poster\_path"":null,""release\_date"":"""",""title"":""Avatar - Live At Graspop 2018"",""video"":false,""vote\_average"":9,""vote\_count"":1},{""adult"":false,""backdrop\_path"":null,""genre\_ids"":[10402],""id"":874770,""original\_language"":""en"",""original\_title"":""Avatar Ages: Memories"",""overview"":""On the night of memories Avatar performed songs from Thoughts of No Tomorrow, Schlacht and Avatar as voted on by the fans."",""popularity"":2.66,""poster\_path"":""/xDNNQ2cnxAv3o7u0nT6JJacQrhp.jpg"",""release\_date"":""2021-01-30"",""title"":""Avatar Ages: Memories"",""video"":false,""vote\_average"":10,""vote\_count"":1},{""adult"":false,""backdrop\_path"":null,""genre\_ids"":[10402],""id"":874768,""original\_language"":""en"",""original\_title"":""Avatar Ages: Madness"",""overview"":""On the night of madness Avatar performed songs from Black Waltz and Hail The Apocalypse as voted on by the fans."",""popularity"":2.024,""poster\_path"":""/wVyTuruUctV3UbdzE5cncnpyNoY.jpg"",""release\_date"":""2021-01-23"",""title"":""Avatar Ages: Madness"",""video"":false,""vote\_average"":8,""vote\_count"":1},{""adult"":false,""backdrop\_path"":""/dj8g4jrYMfK6tQ26ra3IaqOx5Ho.jpg"",""genre\_ids"":[10402],""id"":874700,""original\_language"":""en"",""original\_title"":""Avatar Ages: Dreams"",""overview"":""On the night of dreams Avatar performed Hunter Gatherer in its entirety, plus a selection of their most popular songs. Originally aired January 9th 2021"",""popularity"":1.957,""poster\_path"":""/4twG59wnuHpGIRR9gYsqZnVysSP.jpg"",""release\_date"":""2021-01-09"",""title"":""Avatar Ages: Dreams"",""video"":false,""vote\_average"":0,""vote\_count"":0}],""total\_pages"":3,""total\_results"":57}  
  
 > Finished chain.  
  
  
  
  
  
 ' This response contains 57 movies related to the search query ""Avatar"". The first movie in the list is the 2009 movie ""Avatar"" starring Sam Worthington. Other movies in the list include sequels to Avatar, documentaries, and live performances.'  

```
Listen API Example[​](#listen-api-example ""Direct link to Listen API Example"")
------------------------------------------------------------------------------


```
import os  
from langchain.llms import OpenAI  
from langchain.chains.api import podcast\_docs  
from langchain.chains import APIChain  
  
# Get api key here: https://www.listennotes.com/api/pricing/  
listen\_api\_key = 'xxx'  
  
llm = OpenAI(temperature=0)  
headers = {""X-ListenAPI-Key"": listen\_api\_key}  
chain = APIChain.from\_llm\_and\_api\_docs(llm, podcast\_docs.PODCAST\_DOCS, headers=headers, verbose=True)  
chain.run(""Search for 'silicon valley bank' podcast episodes, audio length is more than 30 minutes, return only 1 results"")  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/use_cases/question_answering/how_to/analyze_document,"Analyze Document
================

The AnalyzeDocumentChain can be used as an end-to-end to chain. This chain takes in a single document, splits it up, and then runs it through a CombineDocumentsChain.


```
with open(""../../state\_of\_the\_union.txt"") as f:  
 state\_of\_the\_union = f.read()  

```
Summarize[​](#summarize ""Direct link to Summarize"")
---------------------------------------------------

Let's take a look at it in action below, using it summarize a long document.


```
from langchain import OpenAI  
from langchain.chains.summarize import load\_summarize\_chain  
  
llm = OpenAI(temperature=0)  
summary\_chain = load\_summarize\_chain(llm, chain\_type=""map\_reduce"")  

```

```
from langchain.chains import AnalyzeDocumentChain  

```

```
summarize\_document\_chain = AnalyzeDocumentChain(combine\_docs\_chain=summary\_chain)  

```

```
summarize\_document\_chain.run(state\_of\_the\_union)  

```

```
 "" In this speech, President Biden addresses the American people and the world, discussing the recent aggression of Russia's Vladimir Putin in Ukraine and the US response. He outlines economic sanctions and other measures taken to hold Putin accountable, and announces the US Department of Justice's task force to go after the crimes of Russian oligarchs. He also announces plans to fight inflation and lower costs for families, invest in American manufacturing, and provide military, economic, and humanitarian assistance to Ukraine. He calls for immigration reform, protecting the rights of women, and advancing the rights of LGBTQ+ Americans, and pays tribute to military families. He concludes with optimism for the future of America.""  

```
Question Answering[​](#question-answering ""Direct link to Question Answering"")
------------------------------------------------------------------------------

Let's take a look at this using a question answering chain.


```
from langchain.chains.question\_answering import load\_qa\_chain  

```

```
qa\_chain = load\_qa\_chain(llm, chain\_type=""map\_reduce"")  

```

```
qa\_document\_chain = AnalyzeDocumentChain(combine\_docs\_chain=qa\_chain)  

```

```
qa\_document\_chain.run(input\_document=state\_of\_the\_union, question=""what did the president say about justice breyer?"")  

```

```
 ' The president thanked Justice Breyer for his service.'  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/use_cases/question_answering/how_to/chat_vector_db,"Store and reference chat history
================================

The ConversationalRetrievalQA chain builds on RetrievalQAChain to provide a chat history component.

It first combines the chat history (either explicitly passed in or retrieved from the provided memory) and the question into a standalone question, then looks up relevant documents from the retriever, and finally passes those documents and the question to a question answering chain to return a response.

To create one, you will need a retriever. In the below example, we will create one from a vector store, which can be created from embeddings.


```
from langchain.embeddings.openai import OpenAIEmbeddings  
from langchain.vectorstores import Chroma  
from langchain.text\_splitter import CharacterTextSplitter  
from langchain.llms import OpenAI  
from langchain.chains import ConversationalRetrievalChain  

```
Load in documents. You can replace this with a loader for whatever type of data you want


```
from langchain.document\_loaders import TextLoader  
loader = TextLoader(""../../state\_of\_the\_union.txt"")  
documents = loader.load()  

```
If you had multiple loaders that you wanted to combine, you do something like:


```
# loaders = [....]  
# docs = []  
# for loader in loaders:  
# docs.extend(loader.load())  

```
We now split the documents, create embeddings for them, and put them in a vectorstore. This allows us to do semantic search over them.


```
text\_splitter = CharacterTextSplitter(chunk\_size=1000, chunk\_overlap=0)  
documents = text\_splitter.split\_documents(documents)  
  
embeddings = OpenAIEmbeddings()  
vectorstore = Chroma.from\_documents(documents, embeddings)  

```

```
 Using embedded DuckDB without persistence: data will be transient  

```
We can now create a memory object, which is necessary to track the inputs/outputs and hold a conversation.


```
from langchain.memory import ConversationBufferMemory  
memory = ConversationBufferMemory(memory\_key=""chat\_history"", return\_messages=True)  

```
We now initialize the `ConversationalRetrievalChain`


```
qa = ConversationalRetrievalChain.from\_llm(OpenAI(temperature=0), vectorstore.as\_retriever(), memory=memory)  

```

```
query = ""What did the president say about Ketanji Brown Jackson""  
result = qa({""question"": query})  

```

```
result[""answer""]  

```

```
 "" The president said that Ketanji Brown Jackson is one of the nation's top legal minds, a former top litigator in private practice, a former federal public defender, and from a family of public school educators and police officers. He also said that she is a consensus builder and has received a broad range of support from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.""  

```

```
query = ""Did he mention who she succeeded""  
result = qa({""question"": query})  

```

```
result['answer']  

```

```
 ' Ketanji Brown Jackson succeeded Justice Stephen Breyer on the United States Supreme Court.'  

```
Pass in chat history[​](#pass-in-chat-history ""Direct link to Pass in chat history"")
------------------------------------------------------------------------------------

In the above example, we used a Memory object to track chat history. We can also just pass it in explicitly. In order to do this, we need to initialize a chain without any memory object.


```
qa = ConversationalRetrievalChain.from\_llm(OpenAI(temperature=0), vectorstore.as\_retriever())  

```
Here's an example of asking a question with no chat history


```
chat\_history = []  
query = ""What did the president say about Ketanji Brown Jackson""  
result = qa({""question"": query, ""chat\_history"": chat\_history})  

```

```
result[""answer""]  

```

```
 "" The president said that Ketanji Brown Jackson is one of the nation's top legal minds, a former top litigator in private practice, a former federal public defender, and from a family of public school educators and police officers. He also said that she is a consensus builder and has received a broad range of support from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.""  

```
Here's an example of asking a question with some chat history


```
chat\_history = [(query, result[""answer""])]  
query = ""Did he mention who she succeeded""  
result = qa({""question"": query, ""chat\_history"": chat\_history})  

```

```
result['answer']  

```

```
 ' Ketanji Brown Jackson succeeded Justice Stephen Breyer on the United States Supreme Court.'  

```
Using a different model for condensing the question[​](#using-a-different-model-for-condensing-the-question ""Direct link to Using a different model for condensing the question"")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

This chain has two steps. First, it condenses the current question and the chat history into a standalone question. This is necessary to create a standanlone vector to use for retrieval. After that, it does retrieval and then answers the question using retrieval augmented generation with a separate model. Part of the power of the declarative nature of LangChain is that you can easily use a separate language model for each call. This can be useful to use a cheaper and faster model for the simpler task of condensing the question, and then a more expensive model for answering the question. Here is an example of doing so.


```
from langchain.chat\_models import ChatOpenAI  

```

```
qa = ConversationalRetrievalChain.from\_llm(  
 ChatOpenAI(temperature=0, model=""gpt-4""),  
 vectorstore.as\_retriever(),  
 condense\_question\_llm = ChatOpenAI(temperature=0, model='gpt-3.5-turbo'),  
)  

```

```
chat\_history = []  
query = ""What did the president say about Ketanji Brown Jackson""  
result = qa({""question"": query, ""chat\_history"": chat\_history})  

```

```
chat\_history = [(query, result[""answer""])]  
query = ""Did he mention who she succeeded""  
result = qa({""question"": query, ""chat\_history"": chat\_history})  

```
Return Source Documents[​](#return-source-documents ""Direct link to Return Source Documents"")
---------------------------------------------------------------------------------------------

You can also easily return source documents from the ConversationalRetrievalChain. This is useful for when you want to inspect what documents were returned.


```
qa = ConversationalRetrievalChain.from\_llm(OpenAI(temperature=0), vectorstore.as\_retriever(), return\_source\_documents=True)  

```

```
chat\_history = []  
query = ""What did the president say about Ketanji Brown Jackson""  
result = qa({""question"": query, ""chat\_history"": chat\_history})  

```

```
result['source\_documents'][0]  

```

```
 Document(page\_content='Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections. \n\nTonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service. \n\nOne of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court. \n\nAnd I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.', metadata={'source': '../../state\_of\_the\_union.txt'})  

```
ConversationalRetrievalChain with `search_distance`[​](#conversationalretrievalchain-with-search_distance ""Direct link to conversationalretrievalchain-with-search_distance"")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

If you are using a vector store that supports filtering by search distance, you can add a threshold value parameter.


```
vectordbkwargs = {""search\_distance"": 0.9}  

```

```
qa = ConversationalRetrievalChain.from\_llm(OpenAI(temperature=0), vectorstore.as\_retriever(), return\_source\_documents=True)  
chat\_history = []  
query = ""What did the president say about Ketanji Brown Jackson""  
result = qa({""question"": query, ""chat\_history"": chat\_history, ""vectordbkwargs"": vectordbkwargs})  

```
ConversationalRetrievalChain with `map_reduce`[​](#conversationalretrievalchain-with-map_reduce ""Direct link to conversationalretrievalchain-with-map_reduce"")
--------------------------------------------------------------------------------------------------------------------------------------------------------------

We can also use different types of combine document chains with the ConversationalRetrievalChain chain.


```
from langchain.chains import LLMChain  
from langchain.chains.question\_answering import load\_qa\_chain  
from langchain.chains.conversational\_retrieval.prompts import CONDENSE\_QUESTION\_PROMPT  

```

```
llm = OpenAI(temperature=0)  
question\_generator = LLMChain(llm=llm, prompt=CONDENSE\_QUESTION\_PROMPT)  
doc\_chain = load\_qa\_chain(llm, chain\_type=""map\_reduce"")  
  
chain = ConversationalRetrievalChain(  
 retriever=vectorstore.as\_retriever(),  
 question\_generator=question\_generator,  
 combine\_docs\_chain=doc\_chain,  
)  

```

```
chat\_history = []  
query = ""What did the president say about Ketanji Brown Jackson""  
result = chain({""question"": query, ""chat\_history"": chat\_history})  

```

```
result['answer']  

```

```
 "" The president said that Ketanji Brown Jackson is one of the nation's top legal minds, a former top litigator in private practice, a former federal public defender, from a family of public school educators and police officers, a consensus builder, and has received a broad range of support from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.""  

```
ConversationalRetrievalChain with Question Answering with sources[​](#conversationalretrievalchain-with-question-answering-with-sources ""Direct link to ConversationalRetrievalChain with Question Answering with sources"")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

You can also use this chain with the question answering with sources chain.


```
from langchain.chains.qa\_with\_sources import load\_qa\_with\_sources\_chain  

```

```
llm = OpenAI(temperature=0)  
question\_generator = LLMChain(llm=llm, prompt=CONDENSE\_QUESTION\_PROMPT)  
doc\_chain = load\_qa\_with\_sources\_chain(llm, chain\_type=""map\_reduce"")  
  
chain = ConversationalRetrievalChain(  
 retriever=vectorstore.as\_retriever(),  
 question\_generator=question\_generator,  
 combine\_docs\_chain=doc\_chain,  
)  

```

```
chat\_history = []  
query = ""What did the president say about Ketanji Brown Jackson""  
result = chain({""question"": query, ""chat\_history"": chat\_history})  

```

```
result['answer']  

```

```
 "" The president said that Ketanji Brown Jackson is one of the nation's top legal minds, a former top litigator in private practice, a former federal public defender, from a family of public school educators and police officers, a consensus builder, and has received a broad range of support from the Fraternal Order of Police to former judges appointed by Democrats and Republicans. \nSOURCES: ../../state\_of\_the\_union.txt""  

```
ConversationalRetrievalChain with streaming to `stdout`[​](#conversationalretrievalchain-with-streaming-to-stdout ""Direct link to conversationalretrievalchain-with-streaming-to-stdout"")
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Output from the chain will be streamed to `stdout` token by token in this example.


```
from langchain.chains.llm import LLMChain  
from langchain.callbacks.streaming\_stdout import StreamingStdOutCallbackHandler  
from langchain.chains.conversational\_retrieval.prompts import CONDENSE\_QUESTION\_PROMPT, QA\_PROMPT  
from langchain.chains.question\_answering import load\_qa\_chain  
  
# Construct a ConversationalRetrievalChain with a streaming llm for combine docs  
# and a separate, non-streaming llm for question generation  
llm = OpenAI(temperature=0)  
streaming\_llm = OpenAI(streaming=True, callbacks=[StreamingStdOutCallbackHandler()], temperature=0)  
  
question\_generator = LLMChain(llm=llm, prompt=CONDENSE\_QUESTION\_PROMPT)  
doc\_chain = load\_qa\_chain(streaming\_llm, chain\_type=""stuff"", prompt=QA\_PROMPT)  
  
qa = ConversationalRetrievalChain(  
 retriever=vectorstore.as\_retriever(), combine\_docs\_chain=doc\_chain, question\_generator=question\_generator)  

```

```
chat\_history = []  
query = ""What did the president say about Ketanji Brown Jackson""  
result = qa({""question"": query, ""chat\_history"": chat\_history})  

```

```
 The president said that Ketanji Brown Jackson is one of the nation's top legal minds, a former top litigator in private practice, a former federal public defender, and from a family of public school educators and police officers. He also said that she is a consensus builder and has received a broad range of support from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.  

```

```
chat\_history = [(query, result[""answer""])]  
query = ""Did he mention who she succeeded""  
result = qa({""question"": query, ""chat\_history"": chat\_history})  

```

```
 Ketanji Brown Jackson succeeded Justice Stephen Breyer on the United States Supreme Court.  

```
get\_chat\_history Function[​](#get_chat_history-function ""Direct link to get_chat_history Function"")
-----------------------------------------------------------------------------------------------------

You can also specify a `get_chat_history` function, which can be used to format the chat\_history string.


```
def get\_chat\_history(inputs) -> str:  
 res = []  
 for human, ai in inputs:  
 res.append(f""Human:{human}\nAI:{ai}"")  
 return ""\n"".join(res)  
qa = ConversationalRetrievalChain.from\_llm(OpenAI(temperature=0), vectorstore.as\_retriever(), get\_chat\_history=get\_chat\_history)  

```

```
chat\_history = []  
query = ""What did the president say about Ketanji Brown Jackson""  
result = qa({""question"": query, ""chat\_history"": chat\_history})  

```

```
result['answer']  

```

```
 "" The president said that Ketanji Brown Jackson is one of the nation's top legal minds, a former top litigator in private practice, a former federal public defender, and from a family of public school educators and police officers. He also said that she is a consensus builder and has received a broad range of support from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.""  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/use_cases/question_answering/how_to/multi_retrieval_qa_router,"Dynamically select from multiple retrievers
===========================================

This notebook demonstrates how to use the `RouterChain` paradigm to create a chain that dynamically selects which Retrieval system to use. Specifically we show how to use the `MultiRetrievalQAChain` to create a question-answering chain that selects the retrieval QA chain which is most relevant for a given question, and then answers the question using it.


```
from langchain.chains.router import MultiRetrievalQAChain  
from langchain.llms import OpenAI  

```

```
from langchain.embeddings import OpenAIEmbeddings  
from langchain.document\_loaders import TextLoader  
from langchain.vectorstores import FAISS  
  
sou\_docs = TextLoader('../../state\_of\_the\_union.txt').load\_and\_split()  
sou\_retriever = FAISS.from\_documents(sou\_docs, OpenAIEmbeddings()).as\_retriever()  
  
pg\_docs = TextLoader('../../paul\_graham\_essay.txt').load\_and\_split()  
pg\_retriever = FAISS.from\_documents(pg\_docs, OpenAIEmbeddings()).as\_retriever()  
  
personal\_texts = [  
 ""I love apple pie"",  
 ""My favorite color is fuchsia"",  
 ""My dream is to become a professional dancer"",  
 ""I broke my arm when I was 12"",  
 ""My parents are from Peru"",  
]  
personal\_retriever = FAISS.from\_texts(personal\_texts, OpenAIEmbeddings()).as\_retriever()  

```

```
retriever\_infos = [  
 {  
 ""name"": ""state of the union"",   
 ""description"": ""Good for answering questions about the 2023 State of the Union address"",   
 ""retriever"": sou\_retriever  
 },  
 {  
 ""name"": ""pg essay"",   
 ""description"": ""Good for answering questions about Paul Graham's essay on his career"",  
 ""retriever"": pg\_retriever  
 },  
 {  
 ""name"": ""personal"",   
 ""description"": ""Good for answering questions about me"",   
 ""retriever"": personal\_retriever  
 }  
]  

```

```
chain = MultiRetrievalQAChain.from\_retrievers(OpenAI(), retriever\_infos, verbose=True)  

```

```
print(chain.run(""What did the president say about the economy?""))  

```

```
   
   
 > Entering new MultiRetrievalQAChain chain...  
 state of the union: {'query': 'What did the president say about the economy in the 2023 State of the Union address?'}  
 > Finished chain.  
 The president said that the economy was stronger than it had been a year prior, and that the American Rescue Plan helped create record job growth and fuel economic relief for millions of Americans. He also proposed a plan to fight inflation and lower costs for families, including cutting the cost of prescription drugs and energy, providing investments and tax credits for energy efficiency, and increasing access to child care and Pre-K.  

```

```
print(chain.run(""What is something Paul Graham regrets about his work?""))  

```

```
   
   
 > Entering new MultiRetrievalQAChain chain...  
 pg essay: {'query': 'What is something Paul Graham regrets about his work?'}  
 > Finished chain.  
 Paul Graham regrets that he did not take a vacation after selling his company, instead of immediately starting to paint.  

```

```
print(chain.run(""What is my background?""))  

```

```
   
   
 > Entering new MultiRetrievalQAChain chain...  
 personal: {'query': 'What is my background?'}  
 > Finished chain.  
 Your background is Peruvian.  

```

```
print(chain.run(""What year was the Internet created in?""))  

```

```
   
   
 > Entering new MultiRetrievalQAChain chain...  
 None: {'query': 'What year was the Internet created in?'}  
 > Finished chain.  
 The Internet was created in 1969 through a project called ARPANET, which was funded by the United States Department of Defense. However, the World Wide Web, which is often confused with the Internet, was created in 1989 by British computer scientist Tim Berners-Lee.  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/use_cases/question_answering/how_to/question_answering,"QA over in-memory documents
===========================

Here we walk through how to use LangChain for question answering over a list of documents. Under the hood we'll be using our [Document chains](/docs/modules/chains/document/).

Prepare Data[​](#prepare-data ""Direct link to Prepare Data"")
------------------------------------------------------------

First we prepare the data. For this example we do similarity search over a vector database, but these documents could be fetched in any manner (the point of this notebook to highlight what to do AFTER you fetch the documents).


```
from langchain.embeddings.openai import OpenAIEmbeddings  
from langchain.text\_splitter import CharacterTextSplitter  
from langchain.vectorstores import Chroma  
from langchain.docstore.document import Document  
from langchain.prompts import PromptTemplate  
from langchain.indexes.vectorstore import VectorstoreIndexCreator  

```

```
with open(""../../state\_of\_the\_union.txt"") as f:  
 state\_of\_the\_union = f.read()  
text\_splitter = CharacterTextSplitter(chunk\_size=1000, chunk\_overlap=0)  
texts = text\_splitter.split\_text(state\_of\_the\_union)  
  
embeddings = OpenAIEmbeddings()  

```

```
docsearch = Chroma.from\_texts(texts, embeddings, metadatas=[{""source"": str(i)} for i in range(len(texts))]).as\_retriever()  

```

```
 Running Chroma using direct local API.  
 Using DuckDB in-memory for database. Data will be transient.  

```

```
query = ""What did the president say about Justice Breyer""  
docs = docsearch.get\_relevant\_documents(query)  

```

```
from langchain.chains.question\_answering import load\_qa\_chain  
from langchain.llms import OpenAI  

```
Quickstart[​](#quickstart ""Direct link to Quickstart"")
------------------------------------------------------

If you just want to get started as quickly as possible, this is the recommended way to do it:


```
chain = load\_qa\_chain(OpenAI(temperature=0), chain\_type=""stuff"")  
query = ""What did the president say about Justice Breyer""  
chain.run(input\_documents=docs, question=query)  

```

```
 ' The president said that Justice Breyer has dedicated his life to serve the country and thanked him for his service.'  

```
If you want more control and understanding over what is happening, please see the information below.

The `stuff` Chain[​](#the-stuff-chain ""Direct link to the-stuff-chain"")
-----------------------------------------------------------------------

This sections shows results of using the `stuff` Chain to do question answering.


```
chain = load\_qa\_chain(OpenAI(temperature=0), chain\_type=""stuff"")  

```

```
query = ""What did the president say about Justice Breyer""  
chain({""input\_documents"": docs, ""question"": query}, return\_only\_outputs=True)  

```

```
 {'output\_text': ' The president said that Justice Breyer has dedicated his life to serve the country and thanked him for his service.'}  

```
**Custom Prompts**

You can also use your own prompts with this chain. In this example, we will respond in Italian.


```
prompt\_template = """"""Use the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.  
  
{context}  
  
Question: {question}  
Answer in Italian:""""""  
PROMPT = PromptTemplate(  
 template=prompt\_template, input\_variables=[""context"", ""question""]  
)  
chain = load\_qa\_chain(OpenAI(temperature=0), chain\_type=""stuff"", prompt=PROMPT)  
chain({""input\_documents"": docs, ""question"": query}, return\_only\_outputs=True)  

```

```
 {'output\_text': ' Il presidente ha detto che Justice Breyer ha dedicato la sua vita a servire questo paese e ha ricevuto una vasta gamma di supporto.'}  

```
The `map_reduce` Chain[​](#the-map_reduce-chain ""Direct link to the-map_reduce-chain"")
--------------------------------------------------------------------------------------

This sections shows results of using the `map_reduce` Chain to do question answering.


```
chain = load\_qa\_chain(OpenAI(temperature=0), chain\_type=""map\_reduce"")  

```

```
query = ""What did the president say about Justice Breyer""  
chain({""input\_documents"": docs, ""question"": query}, return\_only\_outputs=True)  

```

```
 {'output\_text': ' The president said that Justice Breyer is an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court, and thanked him for his service.'}  

```
**Intermediate Steps**

We can also return the intermediate steps for `map_reduce` chains, should we want to inspect them. This is done with the `return_map_steps` variable.


```
chain = load\_qa\_chain(OpenAI(temperature=0), chain\_type=""map\_reduce"", return\_map\_steps=True)  

```

```
chain({""input\_documents"": docs, ""question"": query}, return\_only\_outputs=True)  

```

```
 {'intermediate\_steps': [' ""Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service.""',  
 ' A former top litigator in private practice. A former federal public defender. And from a family of public school educators and police officers. A consensus builder. Since she’s been nominated, she’s received a broad range of support—from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.',  
 ' None',  
 ' None'],  
 'output\_text': ' The president said that Justice Breyer is an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court, and thanked him for his service.'}  

```
**Custom Prompts**

You can also use your own prompts with this chain. In this example, we will respond in Italian.


```
question\_prompt\_template = """"""Use the following portion of a long document to see if any of the text is relevant to answer the question.   
Return any relevant text translated into italian.  
{context}  
Question: {question}  
Relevant text, if any, in Italian:""""""  
QUESTION\_PROMPT = PromptTemplate(  
 template=question\_prompt\_template, input\_variables=[""context"", ""question""]  
)  
  
combine\_prompt\_template = """"""Given the following extracted parts of a long document and a question, create a final answer italian.   
If you don't know the answer, just say that you don't know. Don't try to make up an answer.  
  
QUESTION: {question}  
=========  
{summaries}  
=========  
Answer in Italian:""""""  
COMBINE\_PROMPT = PromptTemplate(  
 template=combine\_prompt\_template, input\_variables=[""summaries"", ""question""]  
)  
chain = load\_qa\_chain(OpenAI(temperature=0), chain\_type=""map\_reduce"", return\_map\_steps=True, question\_prompt=QUESTION\_PROMPT, combine\_prompt=COMBINE\_PROMPT)  
chain({""input\_documents"": docs, ""question"": query}, return\_only\_outputs=True)  

```

```
 {'intermediate\_steps': [""\nStasera vorrei onorare qualcuno che ha dedicato la sua vita a servire questo paese: il giustizia Stephen Breyer - un veterano dell'esercito, uno studioso costituzionale e un giustizia in uscita della Corte Suprema degli Stati Uniti. Giustizia Breyer, grazie per il tuo servizio."",  
 '\nNessun testo pertinente.',  
 ' Non ha detto nulla riguardo a Justice Breyer.',  
 "" Non c'è testo pertinente.""],  
 'output\_text': ' Non ha detto nulla riguardo a Justice Breyer.'}  

```
**Batch Size**

When using the `map_reduce` chain, one thing to keep in mind is the batch size you are using during the map step. If this is too high, it could cause rate limiting errors. You can control this by setting the batch size on the LLM used. Note that this only applies for LLMs with this parameter. Below is an example of doing so:


```
llm = OpenAI(batch\_size=5, temperature=0)  

```
The `refine` Chain[​](#the-refine-chain ""Direct link to the-refine-chain"")
--------------------------------------------------------------------------

This sections shows results of using the `refine` Chain to do question answering.


```
chain = load\_qa\_chain(OpenAI(temperature=0), chain\_type=""refine"")  

```

```
query = ""What did the president say about Justice Breyer""  
chain({""input\_documents"": docs, ""question"": query}, return\_only\_outputs=True)  

```

```
 {'output\_text': '\n\nThe president said that he wanted to honor Justice Breyer for his dedication to serving the country, his legacy of excellence, and his commitment to advancing liberty and justice, as well as for his support of the Equality Act and his commitment to protecting the rights of LGBTQ+ Americans. He also praised Justice Breyer for his role in helping to pass the Bipartisan Infrastructure Law, which he said would be the most sweeping investment to rebuild America in history and would help the country compete for the jobs of the 21st Century.'}  

```
**Intermediate Steps**

We can also return the intermediate steps for `refine` chains, should we want to inspect them. This is done with the `return_refine_steps` variable.


```
chain = load\_qa\_chain(OpenAI(temperature=0), chain\_type=""refine"", return\_refine\_steps=True)  

```

```
chain({""input\_documents"": docs, ""question"": query}, return\_only\_outputs=True)  

```

```
 {'intermediate\_steps': ['\nThe president said that he wanted to honor Justice Breyer for his dedication to serving the country and his legacy of excellence.',  
 '\nThe president said that he wanted to honor Justice Breyer for his dedication to serving the country, his legacy of excellence, and his commitment to advancing liberty and justice.',  
 '\n\nThe president said that he wanted to honor Justice Breyer for his dedication to serving the country, his legacy of excellence, and his commitment to advancing liberty and justice, as well as for his support of the Equality Act and his commitment to protecting the rights of LGBTQ+ Americans.',  
 '\n\nThe president said that he wanted to honor Justice Breyer for his dedication to serving the country, his legacy of excellence, and his commitment to advancing liberty and justice, as well as for his support of the Equality Act and his commitment to protecting the rights of LGBTQ+ Americans. He also praised Justice Breyer for his role in helping to pass the Bipartisan Infrastructure Law, which is the most sweeping investment to rebuild America in history.'],  
 'output\_text': '\n\nThe president said that he wanted to honor Justice Breyer for his dedication to serving the country, his legacy of excellence, and his commitment to advancing liberty and justice, as well as for his support of the Equality Act and his commitment to protecting the rights of LGBTQ+ Americans. He also praised Justice Breyer for his role in helping to pass the Bipartisan Infrastructure Law, which is the most sweeping investment to rebuild America in history.'}  

```
**Custom Prompts**

You can also use your own prompts with this chain. In this example, we will respond in Italian.


```
refine\_prompt\_template = (  
 ""The original question is as follows: {question}\n""  
 ""We have provided an existing answer: {existing\_answer}\n""  
 ""We have the opportunity to refine the existing answer""  
 ""(only if needed) with some more context below.\n""  
 ""------------\n""  
 ""{context\_str}\n""  
 ""------------\n""  
 ""Given the new context, refine the original answer to better ""  
 ""answer the question. ""  
 ""If the context isn't useful, return the original answer. Reply in Italian.""  
)  
refine\_prompt = PromptTemplate(  
 input\_variables=[""question"", ""existing\_answer"", ""context\_str""],  
 template=refine\_prompt\_template,  
)  
  
  
initial\_qa\_template = (  
 ""Context information is below. \n""  
 ""---------------------\n""  
 ""{context\_str}""  
 ""\n---------------------\n""  
 ""Given the context information and not prior knowledge, ""  
 ""answer the question: {question}\nYour answer should be in Italian.\n""  
)  
initial\_qa\_prompt = PromptTemplate(  
 input\_variables=[""context\_str"", ""question""], template=initial\_qa\_template  
)  
chain = load\_qa\_chain(OpenAI(temperature=0), chain\_type=""refine"", return\_refine\_steps=True,  
 question\_prompt=initial\_qa\_prompt, refine\_prompt=refine\_prompt)  
chain({""input\_documents"": docs, ""question"": query}, return\_only\_outputs=True)  

```

```
 {'intermediate\_steps': ['\nIl presidente ha detto che Justice Breyer ha dedicato la sua vita al servizio di questo paese e ha reso omaggio al suo servizio.',  
 ""\nIl presidente ha detto che Justice Breyer ha dedicato la sua vita al servizio di questo paese, ha reso omaggio al suo servizio e ha sostenuto la nomina di una top litigatrice in pratica privata, un ex difensore pubblico federale e una famiglia di insegnanti e agenti di polizia delle scuole pubbliche. Ha anche sottolineato l'importanza di avanzare la libertà e la giustizia attraverso la sicurezza delle frontiere e la risoluzione del sistema di immigrazione."",  
 ""\nIl presidente ha detto che Justice Breyer ha dedicato la sua vita al servizio di questo paese, ha reso omaggio al suo servizio e ha sostenuto la nomina di una top litigatrice in pratica privata, un ex difensore pubblico federale e una famiglia di insegnanti e agenti di polizia delle scuole pubbliche. Ha anche sottolineato l'importanza di avanzare la libertà e la giustizia attraverso la sicurezza delle frontiere, la risoluzione del sistema di immigrazione, la protezione degli americani LGBTQ+ e l'approvazione dell'Equality Act. Ha inoltre sottolineato l'importanza di lavorare insieme per sconfiggere l'epidemia di oppiacei."",  
 ""\n\nIl presidente ha detto che Justice Breyer ha dedicato la sua vita al servizio di questo paese, ha reso omaggio al suo servizio e ha sostenuto la nomina di una top litigatrice in pratica privata, un ex difensore pubblico federale e una famiglia di insegnanti e agenti di polizia delle scuole pubbliche. Ha anche sottolineato l'importanza di avanzare la libertà e la giustizia attraverso la sicurezza delle frontiere, la risoluzione del sistema di immigrazione, la protezione degli americani LGBTQ+ e l'approvazione dell'Equality Act. Ha inoltre sottolineato l'importanza di lavorare insieme per sconfiggere l'epidemia di oppiacei e per investire in America, educare gli americani, far crescere la forza lavoro e costruire l'economia dal""],  
 'output\_text': ""\n\nIl presidente ha detto che Justice Breyer ha dedicato la sua vita al servizio di questo paese, ha reso omaggio al suo servizio e ha sostenuto la nomina di una top litigatrice in pratica privata, un ex difensore pubblico federale e una famiglia di insegnanti e agenti di polizia delle scuole pubbliche. Ha anche sottolineato l'importanza di avanzare la libertà e la giustizia attraverso la sicurezza delle frontiere, la risoluzione del sistema di immigrazione, la protezione degli americani LGBTQ+ e l'approvazione dell'Equality Act. Ha inoltre sottolineato l'importanza di lavorare insieme per sconfiggere l'epidemia di oppiacei e per investire in America, educare gli americani, far crescere la forza lavoro e costruire l'economia dal""}  

```
The `map-rerank` Chain[​](#the-map-rerank-chain ""Direct link to the-map-rerank-chain"")
--------------------------------------------------------------------------------------

This sections shows results of using the `map-rerank` Chain to do question answering with sources.


```
chain = load\_qa\_chain(OpenAI(temperature=0), chain\_type=""map\_rerank"", return\_intermediate\_steps=True)  

```

```
query = ""What did the president say about Justice Breyer""  
results = chain({""input\_documents"": docs, ""question"": query}, return\_only\_outputs=True)  

```

```
results[""output\_text""]  

```

```
 ' The President thanked Justice Breyer for his service and honored him for dedicating his life to serve the country.'  

```

```
results[""intermediate\_steps""]  

```

```
 [{'answer': ' The President thanked Justice Breyer for his service and honored him for dedicating his life to serve the country.',  
 'score': '100'},  
 {'answer': ' This document does not answer the question', 'score': '0'},  
 {'answer': ' This document does not answer the question', 'score': '0'},  
 {'answer': ' This document does not answer the question', 'score': '0'}]  

```
**Custom Prompts**

You can also use your own prompts with this chain. In this example, we will respond in Italian.


```
from langchain.output\_parsers import RegexParser  
  
output\_parser = RegexParser(  
 regex=r""(.\*?)\nScore: (.\*)"",  
 output\_keys=[""answer"", ""score""],  
)  
  
prompt\_template = """"""Use the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.  
  
In addition to giving an answer, also return a score of how fully it answered the user's question. This should be in the following format:  
  
Question: [question here]  
Helpful Answer In Italian: [answer here]  
Score: [score between 0 and 100]  
  
Begin!  
  
Context:  
---------  
{context}  
---------  
Question: {question}  
Helpful Answer In Italian:""""""  
PROMPT = PromptTemplate(  
 template=prompt\_template,  
 input\_variables=[""context"", ""question""],  
 output\_parser=output\_parser,  
)  
  
chain = load\_qa\_chain(OpenAI(temperature=0), chain\_type=""map\_rerank"", return\_intermediate\_steps=True, prompt=PROMPT)  
query = ""What did the president say about Justice Breyer""  
chain({""input\_documents"": docs, ""question"": query}, return\_only\_outputs=True)  

```

```
 {'intermediate\_steps': [{'answer': ' Il presidente ha detto che Justice Breyer ha dedicato la sua vita a servire questo paese.',  
 'score': '100'},  
 {'answer': ' Il presidente non ha detto nulla sulla Giustizia Breyer.',  
 'score': '100'},  
 {'answer': ' Non so.', 'score': '0'},  
 {'answer': ' Non so.', 'score': '0'}],  
 'output\_text': ' Il presidente ha detto che Justice Breyer ha dedicato la sua vita a servire questo paese.'}  

```
Document QA with sources[​](#document-qa-with-sources ""Direct link to Document QA with sources"")
------------------------------------------------------------------------------------------------

We can also perform document QA and return the sources that were used to answer the question. To do this we'll just need to make sure each document has a ""source"" key in the metadata, and we'll use the `load_qa_with_sources` helper to construct our chain:


```
docsearch = Chroma.from\_texts(texts, embeddings, metadatas=[{""source"": str(i)} for i in range(len(texts))])  
query = ""What did the president say about Justice Breyer""  
docs = docsearch.similarity\_search(query)  

```

```
from langchain.chains.qa\_with\_sources import load\_qa\_with\_sources\_chain  
  
chain = load\_qa\_with\_sources\_chain(OpenAI(temperature=0), chain\_type=""stuff"")  
query = ""What did the president say about Justice Breyer""  
chain({""input\_documents"": docs, ""question"": query}, return\_only\_outputs=True)  

```

```
 {'output\_text': ' The president thanked Justice Breyer for his service.\nSOURCES: 30-pl'}  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/use_cases/question_answering/how_to/vector_db_qa,"QA using a Retriever
====================

This example showcases question answering over an index.


```
from langchain.chains import RetrievalQA  
from langchain.document\_loaders import TextLoader  
from langchain.embeddings.openai import OpenAIEmbeddings  
from langchain.llms import OpenAI  
from langchain.text\_splitter import CharacterTextSplitter  
from langchain.vectorstores import Chroma  

```

```
loader = TextLoader(""../../state\_of\_the\_union.txt"")  
documents = loader.load()  
text\_splitter = CharacterTextSplitter(chunk\_size=1000, chunk\_overlap=0)  
texts = text\_splitter.split\_documents(documents)  
  
embeddings = OpenAIEmbeddings()  
docsearch = Chroma.from\_documents(texts, embeddings)  
  
qa = RetrievalQA.from\_chain\_type(llm=OpenAI(), chain\_type=""stuff"", retriever=docsearch.as\_retriever())  

```

```
query = ""What did the president say about Ketanji Brown Jackson""  
qa.run(query)  

```

```
 "" The president said that she is one of the nation's top legal minds, a former top litigator in private practice, a former federal public defender, and from a family of public school educators and police officers. He also said that she is a consensus builder and has received a broad range of support, from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.""  

```
Chain Type[​](#chain-type ""Direct link to Chain Type"")
------------------------------------------------------

You can easily specify different chain types to load and use in the RetrievalQA chain. For a more detailed walkthrough of these types, please see [this notebook](/docs/modules/chains/additional/question_answering.html).

There are two ways to load different chain types. First, you can specify the chain type argument in the `from_chain_type` method. This allows you to pass in the name of the chain type you want to use. For example, in the below we change the chain type to `map_reduce`.


```
qa = RetrievalQA.from\_chain\_type(llm=OpenAI(), chain\_type=""map\_reduce"", retriever=docsearch.as\_retriever())  

```

```
query = ""What did the president say about Ketanji Brown Jackson""  
qa.run(query)  

```

```
 "" The president said that Judge Ketanji Brown Jackson is one of our nation's top legal minds, a former top litigator in private practice and a former federal public defender, from a family of public school educators and police officers, a consensus builder and has received a broad range of support from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.""  

```
The above way allows you to really simply change the chain\_type, but it doesn't provide a ton of flexibility over parameters to that chain type. If you want to control those parameters, you can load the chain directly (as you did in [this notebook](/docs/modules/chains/additional/question_answering.html)) and then pass that directly to the the RetrievalQA chain with the `combine_documents_chain` parameter. For example:


```
from langchain.chains.question\_answering import load\_qa\_chain  
qa\_chain = load\_qa\_chain(OpenAI(temperature=0), chain\_type=""stuff"")  
qa = RetrievalQA(combine\_documents\_chain=qa\_chain, retriever=docsearch.as\_retriever())  

```

```
query = ""What did the president say about Ketanji Brown Jackson""  
qa.run(query)  

```

```
 "" The president said that Ketanji Brown Jackson is one of the nation's top legal minds, a former top litigator in private practice, a former federal public defender, and from a family of public school educators and police officers. He also said that she is a consensus builder and has received a broad range of support from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.""  

```
Custom Prompts[​](#custom-prompts ""Direct link to Custom Prompts"")
------------------------------------------------------------------

You can pass in custom prompts to do question answering. These prompts are the same prompts as you can pass into the [base question answering chain](/docs/modules/chains/additional/question_answering.html)


```
from langchain.prompts import PromptTemplate  
prompt\_template = """"""Use the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.  
  
{context}  
  
Question: {question}  
Answer in Italian:""""""  
PROMPT = PromptTemplate(  
 template=prompt\_template, input\_variables=[""context"", ""question""]  
)  

```

```
chain\_type\_kwargs = {""prompt"": PROMPT}  
qa = RetrievalQA.from\_chain\_type(llm=OpenAI(), chain\_type=""stuff"", retriever=docsearch.as\_retriever(), chain\_type\_kwargs=chain\_type\_kwargs)  

```

```
query = ""What did the president say about Ketanji Brown Jackson""  
qa.run(query)  

```

```
 "" Il presidente ha detto che Ketanji Brown Jackson è una delle menti legali più importanti del paese, che continuerà l'eccellenza di Justice Breyer e che ha ricevuto un ampio sostegno, da Fraternal Order of Police a ex giudici nominati da democratici e repubblicani.""  

```
Return Source Documents[​](#return-source-documents ""Direct link to Return Source Documents"")
---------------------------------------------------------------------------------------------

Additionally, we can return the source documents used to answer the question by specifying an optional parameter when constructing the chain.


```
qa = RetrievalQA.from\_chain\_type(llm=OpenAI(), chain\_type=""stuff"", retriever=docsearch.as\_retriever(), return\_source\_documents=True)  

```

```
query = ""What did the president say about Ketanji Brown Jackson""  
result = qa({""query"": query})  

```

```
result[""result""]  

```

```
 "" The president said that Ketanji Brown Jackson is one of the nation's top legal minds, a former top litigator in private practice and a former federal public defender from a family of public school educators and police officers, and that she has received a broad range of support from the Fraternal Order of Police to former judges appointed by Democrats and Republicans.""  

```

```
result[""source\_documents""]  

```

```
 [Document(page\_content='Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections. \n\nTonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service. \n\nOne of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court. \n\nAnd I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.', lookup\_str='', metadata={'source': '../../state\_of\_the\_union.txt'}, lookup\_index=0),  
 Document(page\_content='A former top litigator in private practice. A former federal public defender. And from a family of public school educators and police officers. A consensus builder. Since she’s been nominated, she’s received a broad range of support—from the Fraternal Order of Police to former judges appointed by Democrats and Republicans. \n\nAnd if we are to advance liberty and justice, we need to secure the Border and fix the immigration system. \n\nWe can do both. At our border, we’ve installed new technology like cutting-edge scanners to better detect drug smuggling. \n\nWe’ve set up joint patrols with Mexico and Guatemala to catch more human traffickers. \n\nWe’re putting in place dedicated immigration judges so families fleeing persecution and violence can have their cases heard faster. \n\nWe’re securing commitments and supporting partners in South and Central America to host more refugees and secure their own borders.', lookup\_str='', metadata={'source': '../../state\_of\_the\_union.txt'}, lookup\_index=0),  
 Document(page\_content='And for our LGBTQ+ Americans, let’s finally get the bipartisan Equality Act to my desk. The onslaught of state laws targeting transgender Americans and their families is wrong. \n\nAs I said last year, especially to our younger transgender Americans, I will always have your back as your President, so you can be yourself and reach your God-given potential. \n\nWhile it often appears that we never agree, that isn’t true. I signed 80 bipartisan bills into law last year. From preventing government shutdowns to protecting Asian-Americans from still-too-common hate crimes to reforming military justice. \n\nAnd soon, we’ll strengthen the Violence Against Women Act that I first wrote three decades ago. It is important for us to show the nation that we can come together and do big things. \n\nSo tonight I’m offering a Unity Agenda for the Nation. Four big things we can do together. \n\nFirst, beat the opioid epidemic.', lookup\_str='', metadata={'source': '../../state\_of\_the\_union.txt'}, lookup\_index=0),  
 Document(page\_content='Tonight, I’m announcing a crackdown on these companies overcharging American businesses and consumers. \n\nAnd as Wall Street firms take over more nursing homes, quality in those homes has gone down and costs have gone up. \n\nThat ends on my watch. \n\nMedicare is going to set higher standards for nursing homes and make sure your loved ones get the care they deserve and expect. \n\nWe’ll also cut costs and keep the economy going strong by giving workers a fair shot, provide more training and apprenticeships, hire them based on their skills not degrees. \n\nLet’s pass the Paycheck Fairness Act and paid leave. \n\nRaise the minimum wage to $15 an hour and extend the Child Tax Credit, so no one has to raise a family in poverty. \n\nLet’s increase Pell Grants and increase our historic support of HBCUs, and invest in what Jill—our First Lady who teaches full-time—calls America’s best-kept secret: community colleges.', lookup\_str='', metadata={'source': '../../state\_of\_the\_union.txt'}, lookup\_index=0)]  

```
Alternatively, if our document have a ""source"" metadata key, we can use the `RetrievalQAWithSourceChain` to cite our sources:


```
docsearch = Chroma.from\_texts(texts, embeddings, metadatas=[{""source"": f""{i}-pl""} for i in range(len(texts))])  

```

```
from langchain.chains import RetrievalQAWithSourcesChain  
from langchain import OpenAI  
  
chain = RetrievalQAWithSourcesChain.from\_chain\_type(OpenAI(temperature=0), chain\_type=""stuff"", retriever=docsearch.as\_retriever())  

```

```
chain({""question"": ""What did the president say about Justice Breyer""}, return\_only\_outputs=True)  

```

```
 {'answer': ' The president honored Justice Breyer for his service and mentioned his legacy of excellence.\n',  
 'sources': '31-pl'}  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/use_cases/summarization/summarize,"Summarization
=============

A summarization chain can be used to summarize multiple documents. One way is to input multiple smaller documents, after they have been divided into chunks, and operate over them with a MapReduceDocumentsChain. You can also choose instead for the chain that does summarization to be a StuffDocumentsChain, or a RefineDocumentsChain.

Prepare Data[​](#prepare-data ""Direct link to Prepare Data"")
------------------------------------------------------------

First we prepare the data. For this example we create multiple documents from one long one, but these documents could be fetched in any manner (the point of this notebook to highlight what to do AFTER you fetch the documents).


```
from langchain import OpenAI, PromptTemplate, LLMChain  
from langchain.text\_splitter import CharacterTextSplitter  
from langchain.chains.mapreduce import MapReduceChain  
from langchain.prompts import PromptTemplate  
  
llm = OpenAI(temperature=0)  
  
text\_splitter = CharacterTextSplitter()  

```

```
with open(""../../state\_of\_the\_union.txt"") as f:  
 state\_of\_the\_union = f.read()  
texts = text\_splitter.split\_text(state\_of\_the\_union)  

```

```
from langchain.docstore.document import Document  
  
docs = [Document(page\_content=t) for t in texts[:3]]  

```
Quickstart[​](#quickstart ""Direct link to Quickstart"")
------------------------------------------------------

If you just want to get started as quickly as possible, this is the recommended way to do it:


```
from langchain.chains.summarize import load\_summarize\_chain  

```

```
chain = load\_summarize\_chain(llm, chain\_type=""map\_reduce"")  
chain.run(docs)  

```

```
 ' In response to Russian aggression in Ukraine, the United States and its allies are taking action to hold Putin accountable, including economic sanctions, asset seizures, and military assistance. The US is also providing economic and humanitarian aid to Ukraine, and has passed the American Rescue Plan and the Bipartisan Infrastructure Law to help struggling families and create jobs. The US remains unified and determined to protect Ukraine and the free world.'  

```
If you want more control and understanding over what is happening, please see the information below.

The `stuff` Chain[​](#the-stuff-chain ""Direct link to the-stuff-chain"")
-----------------------------------------------------------------------

This sections shows results of using the `stuff` Chain to do summarization.


```
chain = load\_summarize\_chain(llm, chain\_type=""stuff"")  

```

```
chain.run(docs)  

```

```
 ' In his speech, President Biden addressed the crisis in Ukraine, the American Rescue Plan, and the Bipartisan Infrastructure Law. He discussed the need to invest in America, educate Americans, and build the economy from the bottom up. He also announced the release of 60 million barrels of oil from reserves around the world, and the creation of a dedicated task force to go after the crimes of Russian oligarchs. He concluded by emphasizing the need to Buy American and use taxpayer dollars to rebuild America.'  

```
**Custom Prompts**

You can also use your own prompts with this chain. In this example, we will respond in Italian.


```
prompt\_template = """"""Write a concise summary of the following:  
  
  
{text}  
  
  
CONCISE SUMMARY IN ITALIAN:""""""  
PROMPT = PromptTemplate(template=prompt\_template, input\_variables=[""text""])  
chain = load\_summarize\_chain(llm, chain\_type=""stuff"", prompt=PROMPT)  
chain.run(docs)  

```

```
 ""\n\nIn questa serata, il Presidente degli Stati Uniti ha annunciato una serie di misure per affrontare la crisi in Ucraina, causata dall'aggressione di Putin. Ha anche annunciato l'invio di aiuti economici, militari e umanitari all'Ucraina. Ha anche annunciato che gli Stati Uniti e i loro alleati stanno imponendo sanzioni economiche a Putin e stanno rilasciando 60 milioni di barili di petrolio dalle riserve di tutto il mondo. Inoltre, ha annunciato che il Dipartimento di Giustizia degli Stati Uniti sta creando una task force dedicata ai crimini degli oligarchi russi. Il Presidente ha anche annunciato l'approvazione della legge bipartitica sull'infrastruttura, che prevede investimenti per la ricostruzione dell'America. Questo porterà a creare posti""  

```
The `map_reduce` Chain[​](#the-map_reduce-chain ""Direct link to the-map_reduce-chain"")
--------------------------------------------------------------------------------------

This sections shows results of using the `map_reduce` Chain to do summarization.


```
chain = load\_summarize\_chain(llm, chain\_type=""map\_reduce"")  

```

```
chain.run(docs)  

```

```
 "" In response to Russia's aggression in Ukraine, the United States and its allies have imposed economic sanctions and are taking other measures to hold Putin accountable. The US is also providing economic and military assistance to Ukraine, protecting NATO countries, and releasing oil from its Strategic Petroleum Reserve. President Biden and Vice President Harris have passed legislation to help struggling families and rebuild America's infrastructure.""  

```
**Intermediate Steps**

We can also return the intermediate steps for `map_reduce` chains, should we want to inspect them. This is done with the `return_map_steps` variable.


```
chain = load\_summarize\_chain(OpenAI(temperature=0), chain\_type=""map\_reduce"", return\_intermediate\_steps=True)  

```

```
chain({""input\_documents"": docs}, return\_only\_outputs=True)  

```

```
 {'map\_steps': ["" In response to Russia's aggression in Ukraine, the United States has united with other freedom-loving nations to impose economic sanctions and hold Putin accountable. The U.S. Department of Justice is also assembling a task force to go after the crimes of Russian oligarchs and seize their ill-gotten gains."",  
 ' The United States and its European allies are taking action to punish Russia for its invasion of Ukraine, including seizing assets, closing off airspace, and providing economic and military assistance to Ukraine. The US is also mobilizing forces to protect NATO countries and has released 30 million barrels of oil from its Strategic Petroleum Reserve to help blunt gas prices. The world is uniting in support of Ukraine and democracy, and the US stands with its Ukrainian-American citizens.',  
 "" President Biden and Vice President Harris ran for office with a new economic vision for America, and have since passed the American Rescue Plan and the Bipartisan Infrastructure Law to help struggling families and rebuild America's infrastructure. This includes creating jobs, modernizing roads, airports, ports, and waterways, replacing lead pipes, providing affordable high-speed internet, and investing in American products to support American jobs.""],  
 'output\_text': "" In response to Russia's aggression in Ukraine, the United States and its allies have imposed economic sanctions and are taking other measures to hold Putin accountable. The US is also providing economic and military assistance to Ukraine, protecting NATO countries, and passing legislation to help struggling families and rebuild America's infrastructure. The world is uniting in support of Ukraine and democracy, and the US stands with its Ukrainian-American citizens.""}  

```
**Custom Prompts**

You can also use your own prompts with this chain. In this example, we will respond in Italian.


```
prompt\_template = """"""Write a concise summary of the following:  
  
  
{text}  
  
  
CONCISE SUMMARY IN ITALIAN:""""""  
PROMPT = PromptTemplate(template=prompt\_template, input\_variables=[""text""])  
chain = load\_summarize\_chain(OpenAI(temperature=0), chain\_type=""map\_reduce"", return\_intermediate\_steps=True, map\_prompt=PROMPT, combine\_prompt=PROMPT)  
chain({""input\_documents"": docs}, return\_only\_outputs=True)  

```

```
 {'intermediate\_steps': [""\n\nQuesta sera, ci incontriamo come democratici, repubblicani e indipendenti, ma soprattutto come americani. La Russia di Putin ha cercato di scuotere le fondamenta del mondo libero, ma ha sottovalutato la forza della gente ucraina. Gli Stati Uniti e i loro alleati stanno ora imponendo sanzioni economiche a Putin e stanno tagliando l'accesso della Russia alla tecnologia. Il Dipartimento di Giustizia degli Stati Uniti sta anche creando una task force dedicata per andare dopo i crimini degli oligarchi russi."",  
 ""\n\nStiamo unendo le nostre forze con quelle dei nostri alleati europei per sequestrare yacht, appartamenti di lusso e jet privati di Putin. Abbiamo chiuso lo spazio aereo americano ai voli russi e stiamo fornendo più di un miliardo di dollari in assistenza all'Ucraina. Abbiamo anche mobilitato le nostre forze terrestri, aeree e navali per proteggere i paesi della NATO. Abbiamo anche rilasciato 60 milioni di barili di petrolio dalle riserve di tutto il mondo, di cui 30 milioni dalla nostra riserva strategica di petrolio. Stiamo affrontando una prova reale e ci vorrà del tempo, ma alla fine Putin non riuscirà a spegnere l'amore dei popoli per la libertà."",  
 ""\n\nIl Presidente Biden ha lottato per passare l'American Rescue Plan per aiutare le persone che soffrivano a causa della pandemia. Il piano ha fornito sollievo economico immediato a milioni di americani, ha aiutato a mettere cibo sulla loro tavola, a mantenere un tetto sopra le loro teste e a ridurre il costo dell'assicurazione sanitaria. Il piano ha anche creato più di 6,5 milioni di nuovi posti di lavoro, il più alto numero di posti di lavoro creati in un anno nella storia degli Stati Uniti. Il Presidente Biden ha anche firmato la legge bipartitica sull'infrastruttura, la più ampia iniziativa di ricostruzione della storia degli Stati Uniti. Il piano prevede di modernizzare le strade, gli aeroporti, i porti e le vie navigabili in""],  
 'output\_text': ""\n\nIl Presidente Biden sta lavorando per aiutare le persone che soffrono a causa della pandemia attraverso l'American Rescue Plan e la legge bipartitica sull'infrastruttura. Gli Stati Uniti e i loro alleati stanno anche imponendo sanzioni economiche a Putin e tagliando l'accesso della Russia alla tecnologia. Stanno anche sequestrando yacht, appartamenti di lusso e jet privati di Putin e fornendo più di un miliardo di dollari in assistenza all'Ucraina. Alla fine, Putin non riuscirà a spegnere l'amore dei popoli per la libertà.""}  

```
The custom `MapReduceChain`[​](#the-custom-mapreducechain ""Direct link to the-custom-mapreducechain"")
-----------------------------------------------------------------------------------------------------

**Multi input prompt**

You can also use prompt with multi input. In this example, we will use a MapReduce chain to answer specific question about our code.


```
from langchain.chains.combine\_documents.map\_reduce import MapReduceDocumentsChain  
from langchain.chains.combine\_documents.stuff import StuffDocumentsChain  
  
map\_template\_string = """"""Give the following python code information, generate a description that explains what the code does and also mention the time complexity.  
Code:  
{code}  
  
Return the the description in the following format:  
name of the function: description of the function  
""""""  
  
  
reduce\_template\_string = """"""Given the following python function names and descriptions, answer the following question  
{code\_description}  
Question: {question}  
Answer:  
""""""  
  
# Prompt to use in map and reduce stages   
MAP\_PROMPT = PromptTemplate(input\_variables=[""code""], template=map\_template\_string)  
REDUCE\_PROMPT = PromptTemplate(input\_variables=[""code\_description"", ""question""], template=reduce\_template\_string)  
  
# LLM to use in map and reduce stages   
llm = OpenAI()  
map\_llm\_chain = LLMChain(llm=llm, prompt=MAP\_PROMPT)  
reduce\_llm\_chain = LLMChain(llm=llm, prompt=REDUCE\_PROMPT)  
  
# Takes a list of documents and combines them into a single string  
combine\_documents\_chain = StuffDocumentsChain(  
 llm\_chain=reduce\_llm\_chain,  
 document\_variable\_name=""code\_description"",  
)  
  
# Combines and iteravely reduces the mapped documents   
reduce\_documents\_chain = ReduceDocumentsChain(  
 # This is final chain that is called.  
 combine\_documents\_chain=combine\_documents\_chain,  
 # If documents exceed context for `combine\_documents\_chain`  
 collapse\_documents\_chain=combine\_documents\_chain,  
 # The maximum number of tokens to group documents into  
 token\_max=3000)  
  
# Combining documents by mapping a chain over them, then combining results with reduce chain  
combine\_documents = MapReduceDocumentsChain(  
 # Map chain  
 llm\_chain=map\_llm\_chain,  
 # Reduce chain  
 reduce\_documents\_chain=reduce\_documents\_chain,  
 # The variable name in the llm\_chain to put the documents in  
 document\_variable\_name=""code"",  
)  
  
map\_reduce = MapReduceChain(  
 combine\_documents\_chain=combine\_documents,  
 text\_splitter=CharacterTextSplitter(separator=""\n##\n"", chunk\_size=100, chunk\_overlap=0),  
)  

```

```
code = """"""  
def bubblesort(list):  
 for iter\_num in range(len(list)-1,0,-1):  
 for idx in range(iter\_num):  
 if list[idx]>list[idx+1]:  
 temp = list[idx]  
 list[idx] = list[idx+1]  
 list[idx+1] = temp  
 return list  
##  
def insertion\_sort(InputList):  
 for i in range(1, len(InputList)):  
 j = i-1  
 nxt\_element = InputList[i]  
 while (InputList[j] > nxt\_element) and (j >= 0):  
 InputList[j+1] = InputList[j]  
 j=j-1  
 InputList[j+1] = nxt\_element  
 return InputList  
##  
def shellSort(input\_list):  
 gap = len(input\_list) // 2  
 while gap > 0:  
 for i in range(gap, len(input\_list)):  
 temp = input\_list[i]  
 j = i  
 while j >= gap and input\_list[j - gap] > temp:  
 input\_list[j] = input\_list[j - gap]  
 j = j-gap  
 input\_list[j] = temp  
 gap = gap//2  
 return input\_list  
  
""""""  

```

```
map\_reduce.run(input\_text=code, question=""Which function has a better time complexity?"")  

```

```
 Created a chunk of size 247, which is longer than the specified 100  
 Created a chunk of size 267, which is longer than the specified 100  
  
  
  
  
  
 'shellSort has a better time complexity than both bubblesort and insertion\_sort, as it has a time complexity of O(n^2), while the other two have a time complexity of O(n^2).'  

```
The `refine` Chain[​](#the-refine-chain ""Direct link to the-refine-chain"")
--------------------------------------------------------------------------

This sections shows results of using the `refine` Chain to do summarization.


```
chain = load\_summarize\_chain(llm, chain\_type=""refine"")  
  
chain.run(docs)  

```

```
 ""\n\nIn response to Russia's aggression in Ukraine, the United States has united with other freedom-loving nations to impose economic sanctions and hold Putin accountable. The U.S. Department of Justice is also assembling a task force to go after the crimes of Russian oligarchs and seize their ill-gotten gains. We are joining with our European allies to find and seize the assets of Russian oligarchs, including yachts, luxury apartments, and private jets. The U.S. is also closing off American airspace to all Russian flights, further isolating Russia and adding an additional squeeze on their economy. The U.S. and its allies are providing support to the Ukrainians in their fight for freedom, including military, economic, and humanitarian assistance. The U.S. is also mobilizing ground forces, air squadrons, and ship deployments to protect NATO countries. The U.S. and its allies are also releasing 60 million barrels of oil from reserves around the world, with the U.S. contributing 30 million barrels from its own Strategic Petroleum Reserve. In addition, the U.S. has passed the American Rescue Plan to provide immediate economic relief for tens of millions of Americans, and the Bipartisan Infrastructure Law to rebuild America and create jobs. This investment will""  

```
**Intermediate Steps**

We can also return the intermediate steps for `refine` chains, should we want to inspect them. This is done with the `return_refine_steps` variable.


```
chain = load\_summarize\_chain(OpenAI(temperature=0), chain\_type=""refine"", return\_intermediate\_steps=True)  
  
chain({""input\_documents"": docs}, return\_only\_outputs=True)  

```

```
 {'refine\_steps': ["" In response to Russia's aggression in Ukraine, the United States has united with other freedom-loving nations to impose economic sanctions and hold Putin accountable. The U.S. Department of Justice is also assembling a task force to go after the crimes of Russian oligarchs and seize their ill-gotten gains."",  
 ""\n\nIn response to Russia's aggression in Ukraine, the United States has united with other freedom-loving nations to impose economic sanctions and hold Putin accountable. The U.S. Department of Justice is also assembling a task force to go after the crimes of Russian oligarchs and seize their ill-gotten gains. We are joining with our European allies to find and seize the assets of Russian oligarchs, including yachts, luxury apartments, and private jets. The U.S. is also closing off American airspace to all Russian flights, further isolating Russia and adding an additional squeeze on their economy. The U.S. and its allies are providing support to the Ukrainians in their fight for freedom, including military, economic, and humanitarian assistance. The U.S. is also mobilizing ground forces, air squadrons, and ship deployments to protect NATO countries. The U.S. and its allies are also releasing 60 million barrels of oil from reserves around the world, with the U.S. contributing 30 million barrels from its own Strategic Petroleum Reserve. Putin's war on Ukraine has left Russia weaker and the rest of the world stronger, with the world uniting in support of democracy and peace."",  
 ""\n\nIn response to Russia's aggression in Ukraine, the United States has united with other freedom-loving nations to impose economic sanctions and hold Putin accountable. The U.S. Department of Justice is also assembling a task force to go after the crimes of Russian oligarchs and seize their ill-gotten gains. We are joining with our European allies to find and seize the assets of Russian oligarchs, including yachts, luxury apartments, and private jets. The U.S. is also closing off American airspace to all Russian flights, further isolating Russia and adding an additional squeeze on their economy. The U.S. and its allies are providing support to the Ukrainians in their fight for freedom, including military, economic, and humanitarian assistance. The U.S. is also mobilizing ground forces, air squadrons, and ship deployments to protect NATO countries. The U.S. and its allies are also releasing 60 million barrels of oil from reserves around the world, with the U.S. contributing 30 million barrels from its own Strategic Petroleum Reserve. In addition, the U.S. has passed the American Rescue Plan to provide immediate economic relief for tens of millions of Americans, and the Bipartisan Infrastructure Law to rebuild America and create jobs. This includes investing""],  
 'output\_text': ""\n\nIn response to Russia's aggression in Ukraine, the United States has united with other freedom-loving nations to impose economic sanctions and hold Putin accountable. The U.S. Department of Justice is also assembling a task force to go after the crimes of Russian oligarchs and seize their ill-gotten gains. We are joining with our European allies to find and seize the assets of Russian oligarchs, including yachts, luxury apartments, and private jets. The U.S. is also closing off American airspace to all Russian flights, further isolating Russia and adding an additional squeeze on their economy. The U.S. and its allies are providing support to the Ukrainians in their fight for freedom, including military, economic, and humanitarian assistance. The U.S. is also mobilizing ground forces, air squadrons, and ship deployments to protect NATO countries. The U.S. and its allies are also releasing 60 million barrels of oil from reserves around the world, with the U.S. contributing 30 million barrels from its own Strategic Petroleum Reserve. In addition, the U.S. has passed the American Rescue Plan to provide immediate economic relief for tens of millions of Americans, and the Bipartisan Infrastructure Law to rebuild America and create jobs. This includes investing""}  

```
**Custom Prompts**

You can also use your own prompts with this chain. In this example, we will respond in Italian.


```
prompt\_template = """"""Write a concise summary of the following:  
  
  
{text}  
  
  
CONCISE SUMMARY IN ITALIAN:""""""  
PROMPT = PromptTemplate(template=prompt\_template, input\_variables=[""text""])  
refine\_template = (  
 ""Your job is to produce a final summary\n""  
 ""We have provided an existing summary up to a certain point: {existing\_answer}\n""  
 ""We have the opportunity to refine the existing summary""  
 ""(only if needed) with some more context below.\n""  
 ""------------\n""  
 ""{text}\n""  
 ""------------\n""  
 ""Given the new context, refine the original summary in Italian""  
 ""If the context isn't useful, return the original summary.""  
)  
refine\_prompt = PromptTemplate(  
 input\_variables=[""existing\_answer"", ""text""],  
 template=refine\_template,  
)  
chain = load\_summarize\_chain(OpenAI(temperature=0), chain\_type=""refine"", return\_intermediate\_steps=True, question\_prompt=PROMPT, refine\_prompt=refine\_prompt)  
chain({""input\_documents"": docs}, return\_only\_outputs=True)  

```

```
 {'intermediate\_steps': [""\n\nQuesta sera, ci incontriamo come democratici, repubblicani e indipendenti, ma soprattutto come americani. La Russia di Putin ha cercato di scuotere le fondamenta del mondo libero, ma ha sottovalutato la forza della gente ucraina. Insieme ai nostri alleati, stiamo imponendo sanzioni economiche, tagliando l'accesso della Russia alla tecnologia e bloccando i suoi più grandi istituti bancari dal sistema finanziario internazionale. Il Dipartimento di Giustizia degli Stati Uniti sta anche assemblando una task force dedicata per andare dopo i crimini degli oligarchi russi."",  
 ""\n\nQuesta sera, ci incontriamo come democratici, repubblicani e indipendenti, ma soprattutto come americani. La Russia di Putin ha cercato di scuotere le fondamenta del mondo libero, ma ha sottovalutato la forza della gente ucraina. Insieme ai nostri alleati, stiamo imponendo sanzioni economiche, tagliando l'accesso della Russia alla tecnologia, bloccando i suoi più grandi istituti bancari dal sistema finanziario internazionale e chiudendo lo spazio aereo americano a tutti i voli russi. Il Dipartimento di Giustizia degli Stati Uniti sta anche assemblando una task force dedicata per andare dopo i crimini degli oligarchi russi. Stiamo fornendo più di un miliardo di dollari in assistenza diretta all'Ucraina e fornendo assistenza militare,"",  
 ""\n\nQuesta sera, ci incontriamo come democratici, repubblicani e indipendenti, ma soprattutto come americani. La Russia di Putin ha cercato di scuotere le fondamenta del mondo libero, ma ha sottovalutato la forza della gente ucraina. Insieme ai nostri alleati, stiamo imponendo sanzioni economiche, tagliando l'accesso della Russia alla tecnologia, bloccando i suoi più grandi istituti bancari dal sistema finanziario internazionale e chiudendo lo spazio aereo americano a tutti i voli russi. Il Dipartimento di Giustizia degli Stati Uniti sta anche assemblando una task force dedicata per andare dopo i crimini degli oligarchi russi. Stiamo fornendo più di un miliardo di dollari in assistenza diretta all'Ucraina e fornendo assistenza militare.""],  
 'output\_text': ""\n\nQuesta sera, ci incontriamo come democratici, repubblicani e indipendenti, ma soprattutto come americani. La Russia di Putin ha cercato di scuotere le fondamenta del mondo libero, ma ha sottovalutato la forza della gente ucraina. Insieme ai nostri alleati, stiamo imponendo sanzioni economiche, tagliando l'accesso della Russia alla tecnologia, bloccando i suoi più grandi istituti bancari dal sistema finanziario internazionale e chiudendo lo spazio aereo americano a tutti i voli russi. Il Dipartimento di Giustizia degli Stati Uniti sta anche assemblando una task force dedicata per andare dopo i crimini degli oligarchi russi. Stiamo fornendo più di un miliardo di dollari in assistenza diretta all'Ucraina e fornendo assistenza militare.""}  

```
",{'source_type': <SourceType.Official: 'Official'>}
https://python.langchain.com/docs/use_cases/tabular/sqlite,"SQL
===

This example demonstrates the use of the `SQLDatabaseChain` for answering questions over a SQL database.

Under the hood, LangChain uses SQLAlchemy to connect to SQL databases. The `SQLDatabaseChain` can therefore be used with any SQL dialect supported by SQLAlchemy, such as MS SQL, MySQL, MariaDB, PostgreSQL, Oracle SQL, [Databricks](/docs/ecosystem/integrations/databricks.html) and SQLite. Please refer to the SQLAlchemy documentation for more information about requirements for connecting to your database. For example, a connection to MySQL requires an appropriate connector such as PyMySQL. A URI for a MySQL connection might look like: `mysql+pymysql://user:pass@some_mysql_db_address/db_name`.

This demonstration uses SQLite and the example Chinook database.
To set it up, follow the instructions on <https://database.guide/2-sample-databases-sqlite/>, placing the `.db` file in a notebooks folder at the root of this repository.


```
from langchain.llms import OpenAI  
from langchain.utilities import SQLDatabase  
from langchain\_experimental.sql import SQLDatabaseChain  

```

```
db = SQLDatabase.from\_uri(""sqlite:///../../../../notebooks/Chinook.db"")  
llm = OpenAI(temperature=0, verbose=True)  

```
**NOTE:** For data-sensitive projects, you can specify `return_direct=True` in the `SQLDatabaseChain` initialization to directly return the output of the SQL query without any additional formatting. This prevents the LLM from seeing any contents within the database. Note, however, the LLM still has access to the database scheme (i.e. dialect, table and key names) by default.


```
db\_chain = SQLDatabaseChain.from\_llm(llm, db, verbose=True)  

```

```
db\_chain.run(""How many employees are there?"")  

```

```
   
   
 > Entering new SQLDatabaseChain chain...  
 How many employees are there?  
 SQLQuery:  
  
 /workspace/langchain/langchain/sql\_database.py:191: SAWarning: Dialect sqlite+pysqlite does \*not\* support Decimal objects natively, and SQLAlchemy must convert from floating point - rounding errors and other issues may occur. Please consider storing Decimal numbers as strings or integers on this platform for lossless storage.  
 sample\_rows = connection.execute(command)  
  
  
 SELECT COUNT(\*) FROM ""Employee"";  
 SQLResult: [(8,)]  
 Answer:There are 8 employees.  
 > Finished chain.  
  
  
  
  
  
 'There are 8 employees.'  

```
Use Query Checker[​](#use-query-checker ""Direct link to Use Query Checker"")
---------------------------------------------------------------------------

Sometimes the Language Model generates invalid SQL with small mistakes that can be self-corrected using the same technique used by the SQL Database Agent to try and fix the SQL using the LLM. You can simply specify this option when creating the chain:


```
db\_chain = SQLDatabaseChain.from\_llm(llm, db, verbose=True, use\_query\_checker=True)  

```

```
db\_chain.run(""How many albums by Aerosmith?"")  

```

```
   
   
 > Entering new SQLDatabaseChain chain...  
 How many albums by Aerosmith?  
 SQLQuery:SELECT COUNT(\*) FROM Album WHERE ArtistId = 3;  
 SQLResult: [(1,)]  
 Answer:There is 1 album by Aerosmith.  
 > Finished chain.  
  
  
  
  
  
 'There is 1 album by Aerosmith.'  

```
Customize Prompt[​](#customize-prompt ""Direct link to Customize Prompt"")
------------------------------------------------------------------------

You can also customize the prompt that is used. Here is an example prompting it to understand that foobar is the same as the Employee table


```
from langchain.prompts.prompt import PromptTemplate  
  
\_DEFAULT\_TEMPLATE = """"""Given an input question, first create a syntactically correct {dialect} query to run, then look at the results of the query and return the answer.  
Use the following format:  
  
Question: ""Question here""  
SQLQuery: ""SQL Query to run""  
SQLResult: ""Result of the SQLQuery""  
Answer: ""Final answer here""  
  
Only use the following tables:  
  
{table\_info}  
  
If someone asks for the table foobar, they really mean the employee table.  
  
Question: {input}""""""  
PROMPT = PromptTemplate(  
 input\_variables=[""input"", ""table\_info"", ""dialect""], template=\_DEFAULT\_TEMPLATE  
)  

```

```
db\_chain = SQLDatabaseChain.from\_llm(llm, db, prompt=PROMPT, verbose=True)  

```

```
db\_chain.run(""How many employees are there in the foobar table?"")  

```

```
   
   
 > Entering new SQLDatabaseChain chain...  
 How many employees are there in the foobar table?  
 SQLQuery:SELECT COUNT(\*) FROM Employee;  
 SQLResult: [(8,)]  
 Answer:There are 8 employees in the foobar table.  
 > Finished chain.  
  
  
  
  
  
 'There are 8 employees in the foobar table.'  

```
Return Intermediate Steps[​](#return-intermediate-steps ""Direct link to Return Intermediate Steps"")
---------------------------------------------------------------------------------------------------

You can also return the intermediate steps of the SQLDatabaseChain. This allows you to access the SQL statement that was generated, as well as the result of running that against the SQL Database.


```
db\_chain = SQLDatabaseChain.from\_llm(llm, db, prompt=PROMPT, verbose=True, use\_query\_checker=True, return\_intermediate\_steps=True)  

```

```
result = db\_chain(""How many employees are there in the foobar table?"")  
result[""intermediate\_steps""]  

```

```
   
   
 > Entering new SQLDatabaseChain chain...  
 How many employees are there in the foobar table?  
 SQLQuery:SELECT COUNT(\*) FROM Employee;  
 SQLResult: [(8,)]  
 Answer:There are 8 employees in the foobar table.  
 > Finished chain.  
  
  
  
  
  
 [{'input': 'How many employees are there in the foobar table?\nSQLQuery:SELECT COUNT(\*) FROM Employee;\nSQLResult: [(8,)]\nAnswer:',  
 'top\_k': '5',  
 'dialect': 'sqlite',  
 'table\_info': '\nCREATE TABLE ""Artist"" (\n\t""ArtistId"" INTEGER NOT NULL, \n\t""Name"" NVARCHAR(120), \n\tPRIMARY KEY (""ArtistId"")\n)\n\n/\*\n3 rows from Artist table:\nArtistId\tName\n1\tAC/DC\n2\tAccept\n3\tAerosmith\n\*/\n\n\nCREATE TABLE ""Employee"" (\n\t""EmployeeId"" INTEGER NOT NULL, \n\t""LastName"" NVARCHAR(20) NOT NULL, \n\t""FirstName"" NVARCHAR(20) NOT NULL, \n\t""Title"" NVARCHAR(30), \n\t""ReportsTo"" INTEGER, \n\t""BirthDate"" DATETIME, \n\t""HireDate"" DATETIME, \n\t""Address"" NVARCHAR(70), \n\t""City"" NVARCHAR(40), \n\t""State"" NVARCHAR(40), \n\t""Country"" NVARCHAR(40), \n\t""PostalCode"" NVARCHAR(10), \n\t""Phone"" NVARCHAR(24), \n\t""Fax"" NVARCHAR(24), \n\t""Email"" NVARCHAR(60), \n\tPRIMARY KEY (""EmployeeId""), \n\tFOREIGN KEY(""ReportsTo"") REFERENCES ""Employee"" (""EmployeeId"")\n)\n\n/\*\n3 rows from Employee table:\nEmployeeId\tLastName\tFirstName\tTitle\tReportsTo\tBirthDate\tHireDate\tAddress\tCity\tState\tCountry\tPostalCode\tPhone\tFax\tEmail\n1\tAdams\tAndrew\tGeneral Manager\tNone\t1962-02-18 00:00:00\t2002-08-14 00:00:00\t11120 Jasper Ave NW\tEdmonton\tAB\tCanada\tT5K 2N1\t+1 (780) 428-9482\t+1 (780) 428-3457\tandrew@chinookcorp.com\n2\tEdwards\tNancy\tSales Manager\t1\t1958-12-08 00:00:00\t2002-05-01 00:00:00\t825 8 Ave SW\tCalgary\tAB\tCanada\tT2P 2T3\t+1 (403) 262-3443\t+1 (403) 262-3322\tnancy@chinookcorp.com\n3\tPeacock\tJane\tSales Support Agent\t2\t1973-08-29 00:00:00\t2002-04-01 00:00:00\t1111 6 Ave SW\tCalgary\tAB\tCanada\tT2P 5M5\t+1 (403) 262-3443\t+1 (403) 262-6712\tjane@chinookcorp.com\n\*/\n\n\nCREATE TABLE ""Genre"" (\n\t""GenreId"" INTEGER NOT NULL, \n\t""Name"" NVARCHAR(120), \n\tPRIMARY KEY (""GenreId"")\n)\n\n/\*\n3 rows from Genre table:\nGenreId\tName\n1\tRock\n2\tJazz\n3\tMetal\n\*/\n\n\nCREATE TABLE ""MediaType"" (\n\t""MediaTypeId"" INTEGER NOT NULL, \n\t""Name"" NVARCHAR(120), \n\tPRIMARY KEY (""MediaTypeId"")\n)\n\n/\*\n3 rows from MediaType table:\nMediaTypeId\tName\n1\tMPEG audio file\n2\tProtected AAC audio file\n3\tProtected MPEG-4 video file\n\*/\n\n\nCREATE TABLE ""Playlist"" (\n\t""PlaylistId"" INTEGER NOT NULL, \n\t""Name"" NVARCHAR(120), \n\tPRIMARY KEY (""PlaylistId"")\n)\n\n/\*\n3 rows from Playlist table:\nPlaylistId\tName\n1\tMusic\n2\tMovies\n3\tTV Shows\n\*/\n\n\nCREATE TABLE ""Album"" (\n\t""AlbumId"" INTEGER NOT NULL, \n\t""Title"" NVARCHAR(160) NOT NULL, \n\t""ArtistId"" INTEGER NOT NULL, \n\tPRIMARY KEY (""AlbumId""), \n\tFOREIGN KEY(""ArtistId"") REFERENCES ""Artist"" (""ArtistId"")\n)\n\n/\*\n3 rows from Album table:\nAlbumId\tTitle\tArtistId\n1\tFor Those About To Rock We Salute You\t1\n2\tBalls to the Wall\t2\n3\tRestless and Wild\t2\n\*/\n\n\nCREATE TABLE ""Customer"" (\n\t""CustomerId"" INTEGER NOT NULL, \n\t""FirstName"" NVARCHAR(40) NOT NULL, \n\t""LastName"" NVARCHAR(20) NOT NULL, \n\t""Company"" NVARCHAR(80), \n\t""Address"" NVARCHAR(70), \n\t""City"" NVARCHAR(40), \n\t""State"" NVARCHAR(40), \n\t""Country"" NVARCHAR(40), \n\t""PostalCode"" NVARCHAR(10), \n\t""Phone"" NVARCHAR(24), \n\t""Fax"" NVARCHAR(24), \n\t""Email"" NVARCHAR(60) NOT NULL, \n\t""SupportRepId"" INTEGER, \n\tPRIMARY KEY (""CustomerId""), \n\tFOREIGN KEY(""SupportRepId"") REFERENCES ""Employee"" (""EmployeeId"")\n)\n\n/\*\n3 rows from Customer table:\nCustomerId\tFirstName\tLastName\tCompany\tAddress\tCity\tState\tCountry\tPostalCode\tPhone\tFax\tEmail\tSupportRepId\n1\tLuís\tGonçalves\tEmbraer - Empresa Brasileira de Aeronáutica S.A.\tAv. Brigadeiro Faria Lima, 2170\tSão José dos Campos\tSP\tBrazil\t12227-000\t+55 (12) 3923-5555\t+55 (12) 3923-5566\tluisg@embraer.com.br\t3\n2\tLeonie\tKöhler\tNone\tTheodor-Heuss-Straße 34\tStuttgart\tNone\tGermany\t70174\t+49 0711 2842222\tNone\tleonekohler@surfeu.de\t5\n3\tFrançois\tTremblay\tNone\t1498 rue Bélanger\tMontréal\tQC\tCanada\tH2G 1A7\t+1 (514) 721-4711\tNone\tftremblay@gmail.com\t3\n\*/\n\n\nCREATE TABLE ""Invoice"" (\n\t""InvoiceId"" INTEGER NOT NULL, \n\t""CustomerId"" INTEGER NOT NULL, \n\t""InvoiceDate"" DATETIME NOT NULL, \n\t""BillingAddress"" NVARCHAR(70), \n\t""BillingCity"" NVARCHAR(40), \n\t""BillingState"" NVARCHAR(40), \n\t""BillingCountry"" NVARCHAR(40), \n\t""BillingPostalCode"" NVARCHAR(10), \n\t""Total"" NUMERIC(10, 2) NOT NULL, \n\tPRIMARY KEY (""InvoiceId""), \n\tFOREIGN KEY(""CustomerId"") REFERENCES ""Customer"" (""CustomerId"")\n)\n\n/\*\n3 rows from Invoice table:\nInvoiceId\tCustomerId\tInvoiceDate\tBillingAddress\tBillingCity\tBillingState\tBillingCountry\tBillingPostalCode\tTotal\n1\t2\t2009-01-01 00:00:00\tTheodor-Heuss-Straße 34\tStuttgart\tNone\tGermany\t70174\t1.98\n2\t4\t2009-01-02 00:00:00\tUllevålsveien 14\tOslo\tNone\tNorway\t0171\t3.96\n3\t8\t2009-01-03 00:00:00\tGrétrystraat 63\tBrussels\tNone\tBelgium\t1000\t5.94\n\*/\n\n\nCREATE TABLE ""Track"" (\n\t""TrackId"" INTEGER NOT NULL, \n\t""Name"" NVARCHAR(200) NOT NULL, \n\t""AlbumId"" INTEGER, \n\t""MediaTypeId"" INTEGER NOT NULL, \n\t""GenreId"" INTEGER, \n\t""Composer"" NVARCHAR(220), \n\t""Milliseconds"" INTEGER NOT NULL, \n\t""Bytes"" INTEGER, \n\t""UnitPrice"" NUMERIC(10, 2) NOT NULL, \n\tPRIMARY KEY (""TrackId""), \n\tFOREIGN KEY(""MediaTypeId"") REFERENCES ""MediaType"" (""MediaTypeId""), \n\tFOREIGN KEY(""GenreId"") REFERENCES ""Genre"" (""GenreId""), \n\tFOREIGN KEY(""AlbumId"") REFERENCES ""Album"" (""AlbumId"")\n)\n\n/\*\n3 rows from Track table:\nTrackId\tName\tAlbumId\tMediaTypeId\tGenreId\tComposer\tMilliseconds\tBytes\tUnitPrice\n1\tFor Those About To Rock (We Salute You)\t1\t1\t1\tAngus Young, Malcolm Young, Brian Johnson\t343719\t11170334\t0.99\n2\tBalls to the Wall\t2\t2\t1\tNone\t342562\t5510424\t0.99\n3\tFast As a Shark\t3\t2\t1\tF. Baltes, S. Kaufman, U. Dirkscneider & W. Hoffman\t230619\t3990994\t0.99\n\*/\n\n\nCREATE TABLE ""InvoiceLine"" (\n\t""InvoiceLineId"" INTEGER NOT NULL, \n\t""InvoiceId"" INTEGER NOT NULL, \n\t""TrackId"" INTEGER NOT NULL, \n\t""UnitPrice"" NUMERIC(10, 2) NOT NULL, \n\t""Quantity"" INTEGER NOT NULL, \n\tPRIMARY KEY (""InvoiceLineId""), \n\tFOREIGN KEY(""TrackId"") REFERENCES ""Track"" (""TrackId""), \n\tFOREIGN KEY(""InvoiceId"") REFERENCES ""Invoice"" (""InvoiceId"")\n)\n\n/\*\n3 rows from InvoiceLine table:\nInvoiceLineId\tInvoiceId\tTrackId\tUnitPrice\tQuantity\n1\t1\t2\t0.99\t1\n2\t1\t4\t0.99\t1\n3\t2\t6\t0.99\t1\n\*/\n\n\nCREATE TABLE ""PlaylistTrack"" (\n\t""PlaylistId"" INTEGER NOT NULL, \n\t""TrackId"" INTEGER NOT NULL, \n\tPRIMARY KEY (""PlaylistId"", ""TrackId""), \n\tFOREIGN KEY(""TrackId"") REFERENCES ""Track"" (""TrackId""), \n\tFOREIGN KEY(""PlaylistId"") REFERENCES ""Playlist"" (""PlaylistId"")\n)\n\n/\*\n3 rows from PlaylistTrack table:\nPlaylistId\tTrackId\n1\t3402\n1\t3389\n1\t3390\n\*/',  
 'stop': ['\nSQLResult:']},  
 'SELECT COUNT(\*) FROM Employee;',  
 {'query': 'SELECT COUNT(\*) FROM Employee;', 'dialect': 'sqlite'},  
 'SELECT COUNT(\*) FROM Employee;',  
 '[(8,)]']  

```
Choosing how to limit the number of rows returned[​](#choosing-how-to-limit-the-number-of-rows-returned ""Direct link to Choosing how to limit the number of rows returned"")
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

If you are querying for several rows of a table you can select the maximum number of results you want to get by using the 'top\_k' parameter (default is 10). This is useful for avoiding query results that exceed the prompt max length or consume tokens unnecessarily.


```
db\_chain = SQLDatabaseChain.from\_llm(llm, db, verbose=True, use\_query\_checker=True, top\_k=3)  

```

```
db\_chain.run(""What are some example tracks by composer Johann Sebastian Bach?"")  

```

```
   
   
 > Entering new SQLDatabaseChain chain...  
 What are some example tracks by composer Johann Sebastian Bach?  
 SQLQuery:SELECT Name FROM Track WHERE Composer = 'Johann Sebastian Bach' LIMIT 3  
 SQLResult: [('Concerto for 2 Violins in D Minor, BWV 1043: I. Vivace',), ('Aria Mit 30 Veränderungen, BWV 988 ""Goldberg Variations"": Aria',), ('Suite for Solo Cello No. 1 in G Major, BWV 1007: I. Prélude',)]  
 Answer:Examples of tracks by Johann Sebastian Bach are Concerto for 2 Violins in D Minor, BWV 1043: I. Vivace, Aria Mit 30 Veränderungen, BWV 988 ""Goldberg Variations"": Aria, and Suite for Solo Cello No. 1 in G Major, BWV 1007: I. Prélude.  
 > Finished chain.  
  
  
  
  
  
 'Examples of tracks by Johann Sebastian Bach are Concerto for 2 Violins in D Minor, BWV 1043: I. Vivace, Aria Mit 30 Veränderungen, BWV 988 ""Goldberg Variations"": Aria, and Suite for Solo Cello No. 1 in G Major, BWV 1007: I. Prélude.'  

```
Adding example rows from each table[​](#adding-example-rows-from-each-table ""Direct link to Adding example rows from each table"")
---------------------------------------------------------------------------------------------------------------------------------

Sometimes, the format of the data is not obvious and it is optimal to include a sample of rows from the tables in the prompt to allow the LLM to understand the data before providing a final query. Here we will use this feature to let the LLM know that artists are saved with their full names by providing two rows from the `Track` table.


```
db = SQLDatabase.from\_uri(  
 ""sqlite:///../../../../notebooks/Chinook.db"",  
 include\_tables=['Track'], # we include only one table to save tokens in the prompt :)  
 sample\_rows\_in\_table\_info=2)  

```
The sample rows are added to the prompt after each corresponding table's column information:


```
print(db.table\_info)  

```

```
   
 CREATE TABLE ""Track"" (  
 ""TrackId"" INTEGER NOT NULL,   
 ""Name"" NVARCHAR(200) NOT NULL,   
 ""AlbumId"" INTEGER,   
 ""MediaTypeId"" INTEGER NOT NULL,   
 ""GenreId"" INTEGER,   
 ""Composer"" NVARCHAR(220),   
 ""Milliseconds"" INTEGER NOT NULL,   
 ""Bytes"" INTEGER,   
 ""UnitPrice"" NUMERIC(10, 2) NOT NULL,   
 PRIMARY KEY (""TrackId""),   
 FOREIGN KEY(""MediaTypeId"") REFERENCES ""MediaType"" (""MediaTypeId""),   
 FOREIGN KEY(""GenreId"") REFERENCES ""Genre"" (""GenreId""),   
 FOREIGN KEY(""AlbumId"") REFERENCES ""Album"" (""AlbumId"")  
 )  
   
 /\*  
 2 rows from Track table:  
 TrackId Name AlbumId MediaTypeId GenreId Composer Milliseconds Bytes UnitPrice  
 1 For Those About To Rock (We Salute You) 1 1 1 Angus Young, Malcolm Young, Brian Johnson 343719 11170334 0.99  
 2 Balls to the Wall 2 2 1 None 342562 5510424 0.99  
 \*/  

```

```
db\_chain = SQLDatabaseChain.from\_llm(llm, db, use\_query\_checker=True, verbose=True)  

```

```
db\_chain.run(""What are some example tracks by Bach?"")  

```

```
   
   
 > Entering new SQLDatabaseChain chain...  
 What are some example tracks by Bach?  
 SQLQuery:SELECT ""Name"", ""Composer"" FROM ""Track"" WHERE ""Composer"" LIKE '%Bach%' LIMIT 5  
 SQLResult: [('American Woman', 'B. Cummings/G. Peterson/M.J. Kale/R. Bachman'), ('Concerto for 2 Violins in D Minor, BWV 1043: I. Vivace', 'Johann Sebastian Bach'), ('Aria Mit 30 Veränderungen, BWV 988 ""Goldberg Variations"": Aria', 'Johann Sebastian Bach'), ('Suite for Solo Cello No. 1 in G Major, BWV 1007: I. Prélude', 'Johann Sebastian Bach'), ('Toccata and Fugue in D Minor, BWV 565: I. Toccata', 'Johann Sebastian Bach')]  
 Answer:Tracks by Bach include 'American Woman', 'Concerto for 2 Violins in D Minor, BWV 1043: I. Vivace', 'Aria Mit 30 Veränderungen, BWV 988 ""Goldberg Variations"": Aria', 'Suite for Solo Cello No. 1 in G Major, BWV 1007: I. Prélude', and 'Toccata and Fugue in D Minor, BWV 565: I. Toccata'.  
 > Finished chain.  
  
  
  
  
  
 'Tracks by Bach include \'American Woman\', \'Concerto for 2 Violins in D Minor, BWV 1043: I. Vivace\', \'Aria Mit 30 Veränderungen, BWV 988 ""Goldberg Variations"": Aria\', \'Suite for Solo Cello No. 1 in G Major, BWV 1007: I. Prélude\', and \'Toccata and Fugue in D Minor, BWV 565: I. Toccata\'.'  

```
### Custom Table Info[​](#custom-table-info ""Direct link to Custom Table Info"")

In some cases, it can be useful to provide custom table information instead of using the automatically generated table definitions and the first `sample_rows_in_table_info` sample rows. For example, if you know that the first few rows of a table are uninformative, it could help to manually provide example rows that are more diverse or provide more information to the model. It is also possible to limit the columns that will be visible to the model if there are unnecessary columns. 

This information can be provided as a dictionary with table names as the keys and table information as the values. For example, let's provide a custom definition and sample rows for the Track table with only a few columns:


```
custom\_table\_info = {  
 ""Track"": """"""CREATE TABLE Track (  
 ""TrackId"" INTEGER NOT NULL,   
 ""Name"" NVARCHAR(200) NOT NULL,  
 ""Composer"" NVARCHAR(220),  
 PRIMARY KEY (""TrackId"")  
)  
/\*  
3 rows from Track table:  
TrackId Name Composer  
1 For Those About To Rock (We Salute You) Angus Young, Malcolm Young, Brian Johnson  
2 Balls to the Wall None  
3 My favorite song ever The coolest composer of all time  
\*/""""""  
}  

```

```
db = SQLDatabase.from\_uri(  
 ""sqlite:///../../../../notebooks/Chinook.db"",  
 include\_tables=['Track', 'Playlist'],  
 sample\_rows\_in\_table\_info=2,  
 custom\_table\_info=custom\_table\_info)  
  
print(db.table\_info)  

```

```
   
 CREATE TABLE ""Playlist"" (  
 ""PlaylistId"" INTEGER NOT NULL,   
 ""Name"" NVARCHAR(120),   
 PRIMARY KEY (""PlaylistId"")  
 )  
   
 /\*  
 2 rows from Playlist table:  
 PlaylistId Name  
 1 Music  
 2 Movies  
 \*/  
   
 CREATE TABLE Track (  
 ""TrackId"" INTEGER NOT NULL,   
 ""Name"" NVARCHAR(200) NOT NULL,  
 ""Composer"" NVARCHAR(220),  
 PRIMARY KEY (""TrackId"")  
 )  
 /\*  
 3 rows from Track table:  
 TrackId Name Composer  
 1 For Those About To Rock (We Salute You) Angus Young, Malcolm Young, Brian Johnson  
 2 Balls to the Wall None  
 3 My favorite song ever The coolest composer of all time  
 \*/  

```
Note how our custom table definition and sample rows for `Track` overrides the `sample_rows_in_table_info` parameter. Tables that are not overridden by `custom_table_info`, in this example `Playlist`, will have their table info gathered automatically as usual.


```
db\_chain = SQLDatabaseChain.from\_llm(llm, db, verbose=True)  
db\_chain.run(""What are some example tracks by Bach?"")  

```

```
   
   
 > Entering new SQLDatabaseChain chain...  
 What are some example tracks by Bach?  
 SQLQuery:SELECT ""Name"" FROM Track WHERE ""Composer"" LIKE '%Bach%' LIMIT 5;  
 SQLResult: [('American Woman',), ('Concerto for 2 Violins in D Minor, BWV 1043: I. Vivace',), ('Aria Mit 30 Veränderungen, BWV 988 ""Goldberg Variations"": Aria',), ('Suite for Solo Cello No. 1 in G Major, BWV 1007: I. Prélude',), ('Toccata and Fugue in D Minor, BWV 565: I. Toccata',)]  
 Answer:text='You are a SQLite expert. Given an input question, first create a syntactically correct SQLite query to run, then look at the results of the query and return the answer to the input question.\nUnless the user specifies in the question a specific number of examples to obtain, query for at most 5 results using the LIMIT clause as per SQLite. You can order the results to return the most informative data in the database.\nNever query for all columns from a table. You must query only the columns that are needed to answer the question. Wrap each column name in double quotes ("") to denote them as delimited identifiers.\nPay attention to use only the column names you can see in the tables below. Be careful to not query for columns that do not exist. Also, pay attention to which column is in which table.\n\nUse the following format:\n\nQuestion: ""Question here""\nSQLQuery: ""SQL Query to run""\nSQLResult: ""Result of the SQLQuery""\nAnswer: ""Final answer here""\n\nOnly use the following tables:\n\nCREATE TABLE ""Playlist"" (\n\t""PlaylistId"" INTEGER NOT NULL, \n\t""Name"" NVARCHAR(120), \n\tPRIMARY KEY (""PlaylistId"")\n)\n\n/\*\n2 rows from Playlist table:\nPlaylistId\tName\n1\tMusic\n2\tMovies\n\*/\n\nCREATE TABLE Track (\n\t""TrackId"" INTEGER NOT NULL, \n\t""Name"" NVARCHAR(200) NOT NULL,\n\t""Composer"" NVARCHAR(220),\n\tPRIMARY KEY (""TrackId"")\n)\n/\*\n3 rows from Track table:\nTrackId\tName\tComposer\n1\tFor Those About To Rock (We Salute You)\tAngus Young, Malcolm Young, Brian Johnson\n2\tBalls to the Wall\tNone\n3\tMy favorite song ever\tThe coolest composer of all time\n\*/\n\nQuestion: What are some example tracks by Bach?\nSQLQuery:SELECT ""Name"" FROM Track WHERE ""Composer"" LIKE \'%Bach%\' LIMIT 5;\nSQLResult: [(\'American Woman\',), (\'Concerto for 2 Violins in D Minor, BWV 1043: I. Vivace\',), (\'Aria Mit 30 Veränderungen, BWV 988 ""Goldberg Variations"": Aria\',), (\'Suite for Solo Cello No. 1 in G Major, BWV 1007: I. Prélude\',), (\'Toccata and Fugue in D Minor, BWV 565: I. Toccata\',)]\nAnswer:'  
 You are a SQLite expert. Given an input question, first create a syntactically correct SQLite query to run, then look at the results of the query and return the answer to the input question.  
 Unless the user specifies in the question a specific number of examples to obtain, query for at most 5 results using the LIMIT clause as per SQLite. You can order the results to return the most informative data in the database.  
 Never query for all columns from a table. You must query only the columns that are needed to answer the question. Wrap each column name in double quotes ("") to denote them as delimited identifiers.  
 Pay attention to use only the column names you can see in the tables below. Be careful to not query for columns that do not exist. Also, pay attention to which column is in which table.  
   
 Use the following format:  
   
 Question: ""Question here""  
 SQLQuery: ""SQL Query to run""  
 SQLResult: ""Result of the SQLQuery""  
 Answer: ""Final answer here""  
   
 Only use the following tables:  
   
 CREATE TABLE ""Playlist"" (  
 ""PlaylistId"" INTEGER NOT NULL,   
 ""Name"" NVARCHAR(120),   
 PRIMARY KEY (""PlaylistId"")  
 )  
   
 /\*  
 2 rows from Playlist table:  
 PlaylistId Name  
 1 Music  
 2 Movies  
 \*/  
   
 CREATE TABLE Track (  
 ""TrackId"" INTEGER NOT NULL,   
 ""Name"" NVARCHAR(200) NOT NULL,  
 ""Composer"" NVARCHAR(220),  
 PRIMARY KEY (""TrackId"")  
 )  
 /\*  
 3 rows from Track table:  
 TrackId Name Composer  
 1 For Those About To Rock (We Salute You) Angus Young, Malcolm Young, Brian Johnson  
 2 Balls to the Wall None  
 3 My favorite song ever The coolest composer of all time  
 \*/  
   
 Question: What are some example tracks by Bach?  
 SQLQuery:SELECT ""Name"" FROM Track WHERE ""Composer"" LIKE '%Bach%' LIMIT 5;  
 SQLResult: [('American Woman',), ('Concerto for 2 Violins in D Minor, BWV 1043: I. Vivace',), ('Aria Mit 30 Veränderungen, BWV 988 ""Goldberg Variations"": Aria',), ('Suite for Solo Cello No. 1 in G Major, BWV 1007: I. Prélude',), ('Toccata and Fugue in D Minor, BWV 565: I. Toccata',)]  
 Answer:  
 {'input': 'What are some example tracks by Bach?\nSQLQuery:SELECT ""Name"" FROM Track WHERE ""Composer"" LIKE \'%Bach%\' LIMIT 5;\nSQLResult: [(\'American Woman\',), (\'Concerto for 2 Violins in D Minor, BWV 1043: I. Vivace\',), (\'Aria Mit 30 Veränderungen, BWV 988 ""Goldberg Variations"": Aria\',), (\'Suite for Solo Cello No. 1 in G Major, BWV 1007: I. Prélude\',), (\'Toccata and Fugue in D Minor, BWV 565: I. Toccata\',)]\nAnswer:', 'top\_k': '5', 'dialect': 'sqlite', 'table\_info': '\nCREATE TABLE ""Playlist"" (\n\t""PlaylistId"" INTEGER NOT NULL, \n\t""Name"" NVARCHAR(120), \n\tPRIMARY KEY (""PlaylistId"")\n)\n\n/\*\n2 rows from Playlist table:\nPlaylistId\tName\n1\tMusic\n2\tMovies\n\*/\n\nCREATE TABLE Track (\n\t""TrackId"" INTEGER NOT NULL, \n\t""Name"" NVARCHAR(200) NOT NULL,\n\t""Composer"" NVARCHAR(220),\n\tPRIMARY KEY (""TrackId"")\n)\n/\*\n3 rows from Track table:\nTrackId\tName\tComposer\n1\tFor Those About To Rock (We Salute You)\tAngus Young, Malcolm Young, Brian Johnson\n2\tBalls to the Wall\tNone\n3\tMy favorite song ever\tThe coolest composer of all time\n\*/', 'stop': ['\nSQLResult:']}  
 Examples of tracks by Bach include ""American Woman"", ""Concerto for 2 Violins in D Minor, BWV 1043: I. Vivace"", ""Aria Mit 30 Veränderungen, BWV 988 'Goldberg Variations': Aria"", ""Suite for Solo Cello No. 1 in G Major, BWV 1007: I. Prélude"", and ""Toccata and Fugue in D Minor, BWV 565: I. Toccata"".  
 > Finished chain.  
  
  
  
  
  
 'Examples of tracks by Bach include ""American Woman"", ""Concerto for 2 Violins in D Minor, BWV 1043: I. Vivace"", ""Aria Mit 30 Veränderungen, BWV 988 \'Goldberg Variations\': Aria"", ""Suite for Solo Cello No. 1 in G Major, BWV 1007: I. Prélude"", and ""Toccata and Fugue in D Minor, BWV 565: I. Toccata"".'  

```
### SQL Views[​](#sql-views ""Direct link to SQL Views"")

In some case, the table schema can be hidden behind a JSON or JSONB column. Adding row samples into the prompt might help won't always describe the data perfectly. 

For this reason, a custom SQL views can help.


```
CREATE VIEW accounts\_v AS  
 select id, firstname, lastname, email, created\_at, updated\_at,  
 cast(stats->>'total\_post' as int) as total\_post,  
 cast(stats->>'total\_comments' as int) as total\_comments,  
 cast(stats->>'ltv' as int) as ltv  
  
 FROM accounts;  

```
Then limit the tables visible from SQLDatabase to the created view.


```
db = SQLDatabase.from\_uri(  
 ""sqlite:///../../../../notebooks/Chinook.db"",  
 include\_tables=['accounts\_v']) # we include only the view  

```
SQLDatabaseSequentialChain[​](#sqldatabasesequentialchain ""Direct link to SQLDatabaseSequentialChain"")
------------------------------------------------------------------------------------------------------

Chain for querying SQL database that is a sequential chain.

The chain is as follows:


```
1. Based on the query, determine which tables to use.  
2. Based on those tables, call the normal SQL database chain.  

```
This is useful in cases where the number of tables in the database is large.


```
from langchain\_experimental.sql import SQLDatabaseSequentialChain  
db = SQLDatabase.from\_uri(""sqlite:///../../../../notebooks/Chinook.db"")  

```

```
chain = SQLDatabaseSequentialChain.from\_llm(llm, db, verbose=True)  

```

```
chain.run(""How many employees are also customers?"")  

```

```
   
   
 > Entering new SQLDatabaseSequentialChain chain...  
 Table names to use:  
 ['Employee', 'Customer']  
   
 > Entering new SQLDatabaseChain chain...  
 How many employees are also customers?  
 SQLQuery:SELECT COUNT(\*) FROM Employee e INNER JOIN Customer c ON e.EmployeeId = c.SupportRepId;  
 SQLResult: [(59,)]  
 Answer:59 employees are also customers.  
 > Finished chain.  
   
 > Finished chain.  
  
  
  
  
  
 '59 employees are also customers.'  

```
Using Local Language Models[​](#using-local-language-models ""Direct link to Using Local Language Models"")
---------------------------------------------------------------------------------------------------------

Sometimes you may not have the luxury of using OpenAI or other service-hosted large language model. You can, ofcourse, try to use the `SQLDatabaseChain` with a local model, but will quickly realize that most models you can run locally even with a large GPU struggle to generate the right output.


```
import logging  
import torch  
from transformers import AutoTokenizer, GPT2TokenizerFast, pipeline, AutoModelForSeq2SeqLM, AutoModelForCausalLM  
from langchain import HuggingFacePipeline  
  
# Note: This model requires a large GPU, e.g. an 80GB A100. See documentation for other ways to run private non-OpenAI models.  
model\_id = ""google/flan-ul2""  
model = AutoModelForSeq2SeqLM.from\_pretrained(model\_id, temperature=0)  
  
device\_id = -1 # default to no-GPU, but use GPU and half precision mode if available  
if torch.cuda.is\_available():  
 device\_id = 0  
 try:  
 model = model.half()  
 except RuntimeError as exc:  
 logging.warn(f""Could not run model in half precision mode: {str(exc)}"")  
  
tokenizer = AutoTokenizer.from\_pretrained(model\_id)  
pipe = pipeline(task=""text2text-generation"", model=model, tokenizer=tokenizer, max\_length=1024, device=device\_id)  
  
local\_llm = HuggingFacePipeline(pipeline=pipe)  

```

```
 /workspace/langchain/.venv/lib/python3.9/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user\_install.html  
 from .autonotebook import tqdm as notebook\_tqdm  
 Loading checkpoint shards: 100%|██████████| 8/8 [00:32<00:00, 4.11s/it]  

```

```
from langchain.utilities import SQLDatabase  
from langchain\_experimental.sql import SQLDatabaseChain  
  
db = SQLDatabase.from\_uri(""sqlite:///../../../../notebooks/Chinook.db"", include\_tables=['Customer'])  
local\_chain = SQLDatabaseChain.from\_llm(local\_llm, db, verbose=True, return\_intermediate\_steps=True, use\_query\_checker=True)  

```
This model should work for very simple SQL queries, as long as you use the query checker as specified above, e.g.:


```
local\_chain(""How many customers are there?"")  

```

```
   
   
 > Entering new SQLDatabaseChain chain...  
 How many customers are there?  
 SQLQuery:  
  
 /workspace/langchain/.venv/lib/python3.9/site-packages/transformers/pipelines/base.py:1070: UserWarning: You seem to be using the pipelines sequentially on GPU. In order to maximize efficiency please use a dataset  
 warnings.warn(  
 /workspace/langchain/.venv/lib/python3.9/site-packages/transformers/pipelines/base.py:1070: UserWarning: You seem to be using the pipelines sequentially on GPU. In order to maximize efficiency please use a dataset  
 warnings.warn(  
  
  
 SELECT count(\*) FROM Customer  
 SQLResult: [(59,)]  
 Answer:  
  
 /workspace/langchain/.venv/lib/python3.9/site-packages/transformers/pipelines/base.py:1070: UserWarning: You seem to be using the pipelines sequentially on GPU. In order to maximize efficiency please use a dataset  
 warnings.warn(  
  
  
 [59]  
 > Finished chain.  
  
  
  
  
  
 {'query': 'How many customers are there?',  
 'result': '[59]',  
 'intermediate\_steps': [{'input': 'How many customers are there?\nSQLQuery:SELECT count(\*) FROM Customer\nSQLResult: [(59,)]\nAnswer:',  
 'top\_k': '5',  
 'dialect': 'sqlite',  
 'table\_info': '\nCREATE TABLE ""Customer"" (\n\t""CustomerId"" INTEGER NOT NULL, \n\t""FirstName"" NVARCHAR(40) NOT NULL, \n\t""LastName"" NVARCHAR(20) NOT NULL, \n\t""Company"" NVARCHAR(80), \n\t""Address"" NVARCHAR(70), \n\t""City"" NVARCHAR(40), \n\t""State"" NVARCHAR(40), \n\t""Country"" NVARCHAR(40), \n\t""PostalCode"" NVARCHAR(10), \n\t""Phone"" NVARCHAR(24), \n\t""Fax"" NVARCHAR(24), \n\t""Email"" NVARCHAR(60) NOT NULL, \n\t""SupportRepId"" INTEGER, \n\tPRIMARY KEY (""CustomerId""), \n\tFOREIGN KEY(""SupportRepId"") REFERENCES ""Employee"" (""EmployeeId"")\n)\n\n/\*\n3 rows from Customer table:\nCustomerId\tFirstName\tLastName\tCompany\tAddress\tCity\tState\tCountry\tPostalCode\tPhone\tFax\tEmail\tSupportRepId\n1\tLuís\tGonçalves\tEmbraer - Empresa Brasileira de Aeronáutica S.A.\tAv. Brigadeiro Faria Lima, 2170\tSão José dos Campos\tSP\tBrazil\t12227-000\t+55 (12) 3923-5555\t+55 (12) 3923-5566\tluisg@embraer.com.br\t3\n2\tLeonie\tKöhler\tNone\tTheodor-Heuss-Straße 34\tStuttgart\tNone\tGermany\t70174\t+49 0711 2842222\tNone\tleonekohler@surfeu.de\t5\n3\tFrançois\tTremblay\tNone\t1498 rue Bélanger\tMontréal\tQC\tCanada\tH2G 1A7\t+1 (514) 721-4711\tNone\tftremblay@gmail.com\t3\n\*/',  
 'stop': ['\nSQLResult:']},  
 'SELECT count(\*) FROM Customer',  
 {'query': 'SELECT count(\*) FROM Customer', 'dialect': 'sqlite'},  
 'SELECT count(\*) FROM Customer',  
 '[(59,)]']}  

```
Even this relatively large model will most likely fail to generate more complicated SQL by itself. However, you can log its inputs and outputs so that you can hand-correct them and use the corrected examples for few shot prompt examples later. In practice, you could log any executions of your chain that raise exceptions (as shown in the example below) or get direct user feedback in cases where the results are incorrect (but did not raise an exception).


```
poetry run pip install pyyaml chromadb  
import yaml  

```

```
 huggingface/tokenizers: The current process just got forked, after parallelism has already been used. Disabling parallelism to avoid deadlocks...  
 To disable this warning, you can either:  
 - Avoid using `tokenizers` before the fork if possible  
 - Explicitly set the environment variable TOKENIZERS\_PARALLELISM=(true | false)  
  
  
 11842.36s - pydevd: Sending message related to process being replaced timed-out after 5 seconds  
  
  
 Requirement already satisfied: pyyaml in /workspace/langchain/.venv/lib/python3.9/site-packages (6.0)  
 Requirement already satisfied: chromadb in /workspace/langchain/.venv/lib/python3.9/site-packages (0.3.21)  
 Requirement already satisfied: pandas>=1.3 in /workspace/langchain/.venv/lib/python3.9/site-packages (from chromadb) (2.0.1)  
 Requirement already satisfied: requests>=2.28 in /workspace/langchain/.venv/lib/python3.9/site-packages (from chromadb) (2.28.2)  
 Requirement already satisfied: pydantic>=1.9 in /workspace/langchain/.venv/lib/python3.9/site-packages (from chromadb) (1.10.7)  
 Requirement already satisfied: hnswlib>=0.7 in /workspace/langchain/.venv/lib/python3.9/site-packages (from chromadb) (0.7.0)  
 Requirement already satisfied: clickhouse-connect>=0.5.7 in /workspace/langchain/.venv/lib/python3.9/site-packages (from chromadb) (0.5.20)  
 Requirement already satisfied: sentence-transformers>=2.2.2 in /workspace/langchain/.venv/lib/python3.9/site-packages (from chromadb) (2.2.2)  
 Requirement already satisfied: duckdb>=0.7.1 in /workspace/langchain/.venv/lib/python3.9/site-packages (from chromadb) (0.7.1)  
 Requirement already satisfied: fastapi>=0.85.1 in /workspace/langchain/.venv/lib/python3.9/site-packages (from chromadb) (0.95.1)  
 Requirement already satisfied: uvicorn[standard]>=0.18.3 in /workspace/langchain/.venv/lib/python3.9/site-packages (from chromadb) (0.21.1)  
 Requirement already satisfied: numpy>=1.21.6 in /workspace/langchain/.venv/lib/python3.9/site-packages (from chromadb) (1.24.3)  
 Requirement already satisfied: posthog>=2.4.0 in /workspace/langchain/.venv/lib/python3.9/site-packages (from chromadb) (3.0.1)  
 Requirement already satisfied: certifi in /workspace/langchain/.venv/lib/python3.9/site-packages (from clickhouse-connect>=0.5.7->chromadb) (2022.12.7)  
 Requirement already satisfied: urllib3>=1.26 in /workspace/langchain/.venv/lib/python3.9/site-packages (from clickhouse-connect>=0.5.7->chromadb) (1.26.15)  
 Requirement already satisfied: pytz in /workspace/langchain/.venv/lib/python3.9/site-packages (from clickhouse-connect>=0.5.7->chromadb) (2023.3)  
 Requirement already satisfied: zstandard in /workspace/langchain/.venv/lib/python3.9/site-packages (from clickhouse-connect>=0.5.7->chromadb) (0.21.0)  
 Requirement already satisfied: lz4 in /workspace/langchain/.venv/lib/python3.9/site-packages (from clickhouse-connect>=0.5.7->chromadb) (4.3.2)  
 Requirement already satisfied: starlette<0.27.0,>=0.26.1 in /workspace/langchain/.venv/lib/python3.9/site-packages (from fastapi>=0.85.1->chromadb) (0.26.1)  
 Requirement already satisfied: python-dateutil>=2.8.2 in /workspace/langchain/.venv/lib/python3.9/site-packages (from pandas>=1.3->chromadb) (2.8.2)  
 Requirement already satisfied: tzdata>=2022.1 in /workspace/langchain/.venv/lib/python3.9/site-packages (from pandas>=1.3->chromadb) (2023.3)  
 Requirement already satisfied: six>=1.5 in /workspace/langchain/.venv/lib/python3.9/site-packages (from posthog>=2.4.0->chromadb) (1.16.0)  
 Requirement already satisfied: monotonic>=1.5 in /workspace/langchain/.venv/lib/python3.9/site-packages (from posthog>=2.4.0->chromadb) (1.6)  
 Requirement already satisfied: backoff>=1.10.0 in /workspace/langchain/.venv/lib/python3.9/site-packages (from posthog>=2.4.0->chromadb) (2.2.1)  
 Requirement already satisfied: typing-extensions>=4.2.0 in /workspace/langchain/.venv/lib/python3.9/site-packages (from pydantic>=1.9->chromadb) (4.5.0)  
 Requirement already satisfied: charset-normalizer<4,>=2 in /workspace/langchain/.venv/lib/python3.9/site-packages (from requests>=2.28->chromadb) (3.1.0)  
 Requirement already satisfied: idna<4,>=2.5 in /workspace/langchain/.venv/lib/python3.9/site-packages (from requests>=2.28->chromadb) (3.4)  
 Requirement already satisfied: transformers<5.0.0,>=4.6.0 in /workspace/langchain/.venv/lib/python3.9/site-packages (from sentence-transformers>=2.2.2->chromadb) (4.28.1)  
 Requirement already satisfied: tqdm in /workspace/langchain/.venv/lib/python3.9/site-packages (from sentence-transformers>=2.2.2->chromadb) (4.65.0)  
 Requirement already satisfied: torch>=1.6.0 in /workspace/langchain/.venv/lib/python3.9/site-packages (from sentence-transformers>=2.2.2->chromadb) (1.13.1)  
 Requirement already satisfied: torchvision in /workspace/langchain/.venv/lib/python3.9/site-packages (from sentence-transformers>=2.2.2->chromadb) (0.14.1)  
 Requirement already satisfied: scikit-learn in /workspace/langchain/.venv/lib/python3.9/site-packages (from sentence-transformers>=2.2.2->chromadb) (1.2.2)  
 Requirement already satisfied: scipy in /workspace/langchain/.venv/lib/python3.9/site-packages (from sentence-transformers>=2.2.2->chromadb) (1.9.3)  
 Requirement already satisfied: nltk in /workspace/langchain/.venv/lib/python3.9/site-packages (from sentence-transformers>=2.2.2->chromadb) (3.8.1)  
 Requirement already satisfied: sentencepiece in /workspace/langchain/.venv/lib/python3.9/site-packages (from sentence-transformers>=2.2.2->chromadb) (0.1.98)  
 Requirement already satisfied: huggingface-hub>=0.4.0 in /workspace/langchain/.venv/lib/python3.9/site-packages (from sentence-transformers>=2.2.2->chromadb) (0.13.4)  
 Requirement already satisfied: click>=7.0 in /workspace/langchain/.venv/lib/python3.9/site-packages (from uvicorn[standard]>=0.18.3->chromadb) (8.1.3)  
 Requirement already satisfied: h11>=0.8 in /workspace/langchain/.venv/lib/python3.9/site-packages (from uvicorn[standard]>=0.18.3->chromadb) (0.14.0)  
 Requirement already satisfied: httptools>=0.5.0 in /workspace/langchain/.venv/lib/python3.9/site-packages (from uvicorn[standard]>=0.18.3->chromadb) (0.5.0)  
 Requirement already satisfied: python-dotenv>=0.13 in /workspace/langchain/.venv/lib/python3.9/site-packages (from uvicorn[standard]>=0.18.3->chromadb) (1.0.0)  
 Requirement already satisfied: uvloop!=0.15.0,!=0.15.1,>=0.14.0 in /workspace/langchain/.venv/lib/python3.9/site-packages (from uvicorn[standard]>=0.18.3->chromadb) (0.17.0)  
 Requirement already satisfied: watchfiles>=0.13 in /workspace/langchain/.venv/lib/python3.9/site-packages (from uvicorn[standard]>=0.18.3->chromadb) (0.19.0)  
 Requirement already satisfied: websockets>=10.4 in /workspace/langchain/.venv/lib/python3.9/site-packages (from uvicorn[standard]>=0.18.3->chromadb) (11.0.2)  
 Requirement already satisfied: filelock in /workspace/langchain/.venv/lib/python3.9/site-packages (from huggingface-hub>=0.4.0->sentence-transformers>=2.2.2->chromadb) (3.12.0)  
 Requirement already satisfied: packaging>=20.9 in /workspace/langchain/.venv/lib/python3.9/site-packages (from huggingface-hub>=0.4.0->sentence-transformers>=2.2.2->chromadb) (23.1)  
 Requirement already satisfied: anyio<5,>=3.4.0 in /workspace/langchain/.venv/lib/python3.9/site-packages (from starlette<0.27.0,>=0.26.1->fastapi>=0.85.1->chromadb) (3.6.2)  
 Requirement already satisfied: nvidia-cuda-runtime-cu11==11.7.99 in /workspace/langchain/.venv/lib/python3.9/site-packages (from torch>=1.6.0->sentence-transformers>=2.2.2->chromadb) (11.7.99)  
 Requirement already satisfied: nvidia-cudnn-cu11==8.5.0.96 in /workspace/langchain/.venv/lib/python3.9/site-packages (from torch>=1.6.0->sentence-transformers>=2.2.2->chromadb) (8.5.0.96)  
 Requirement already satisfied: nvidia-cublas-cu11==11.10.3.66 in /workspace/langchain/.venv/lib/python3.9/site-packages (from torch>=1.6.0->sentence-transformers>=2.2.2->chromadb) (11.10.3.66)  
 Requirement already satisfied: nvidia-cuda-nvrtc-cu11==11.7.99 in /workspace/langchain/.venv/lib/python3.9/site-packages (from torch>=1.6.0->sentence-transformers>=2.2.2->chromadb) (11.7.99)  
 Requirement already satisfied: setuptools in /workspace/langchain/.venv/lib/python3.9/site-packages (from nvidia-cublas-cu11==11.10.3.66->torch>=1.6.0->sentence-transformers>=2.2.2->chromadb) (67.7.1)  
 Requirement already satisfied: wheel in /workspace/langchain/.venv/lib/python3.9/site-packages (from nvidia-cublas-cu11==11.10.3.66->torch>=1.6.0->sentence-transformers>=2.2.2->chromadb) (0.40.0)  
 Requirement already satisfied: regex!=2019.12.17 in /workspace/langchain/.venv/lib/python3.9/site-packages (from transformers<5.0.0,>=4.6.0->sentence-transformers>=2.2.2->chromadb) (2023.3.23)  
 Requirement already satisfied: tokenizers!=0.11.3,<0.14,>=0.11.1 in /workspace/langchain/.venv/lib/python3.9/site-packages (from transformers<5.0.0,>=4.6.0->sentence-transformers>=2.2.2->chromadb) (0.13.3)  
 Requirement already satisfied: joblib in /workspace/langchain/.venv/lib/python3.9/site-packages (from nltk->sentence-transformers>=2.2.2->chromadb) (1.2.0)  
 Requirement already satisfied: threadpoolctl>=2.0.0 in /workspace/langchain/.venv/lib/python3.9/site-packages (from scikit-learn->sentence-transformers>=2.2.2->chromadb) (3.1.0)  
 Requirement already satisfied: pillow!=8.3.\*,>=5.3.0 in /workspace/langchain/.venv/lib/python3.9/site-packages (from torchvision->sentence-transformers>=2.2.2->chromadb) (9.5.0)  
 Requirement already satisfied: sniffio>=1.1 in /workspace/langchain/.venv/lib/python3.9/site-packages (from anyio<5,>=3.4.0->starlette<0.27.0,>=0.26.1->fastapi>=0.85.1->chromadb) (1.3.0)  

```

```
from typing import Dict  
  
QUERY = ""List all the customer first names that start with 'a'""  
  
def \_parse\_example(result: Dict) -> Dict:  
 sql\_cmd\_key = ""sql\_cmd""  
 sql\_result\_key = ""sql\_result""  
 table\_info\_key = ""table\_info""  
 input\_key = ""input""  
 final\_answer\_key = ""answer""  
  
 \_example = {  
 ""input"": result.get(""query""),  
 }  
  
 steps = result.get(""intermediate\_steps"")  
 answer\_key = sql\_cmd\_key # the first one  
 for step in steps:  
 # The steps are in pairs, a dict (input) followed by a string (output).  
 # Unfortunately there is no schema but you can look at the input key of the  
 # dict to see what the output is supposed to be  
 if isinstance(step, dict):  
 # Grab the table info from input dicts in the intermediate steps once  
 if table\_info\_key not in \_example:  
 \_example[table\_info\_key] = step.get(table\_info\_key)  
  
 if input\_key in step:  
 if step[input\_key].endswith(""SQLQuery:""):  
 answer\_key = sql\_cmd\_key # this is the SQL generation input  
 if step[input\_key].endswith(""Answer:""):  
 answer\_key = final\_answer\_key # this is the final answer input  
 elif sql\_cmd\_key in step:  
 \_example[sql\_cmd\_key] = step[sql\_cmd\_key]  
 answer\_key = sql\_result\_key # this is SQL execution input  
 elif isinstance(step, str):  
 # The preceding element should have set the answer\_key  
 \_example[answer\_key] = step  
 return \_example  
  
example: any  
try:  
 result = local\_chain(QUERY)  
 print(""\*\*\* Query succeeded"")  
 example = \_parse\_example(result)  
except Exception as exc:  
 print(""\*\*\* Query failed"")  
 result = {  
 ""query"": QUERY,  
 ""intermediate\_steps"": exc.intermediate\_steps  
 }  
 example = \_parse\_example(result)  
  
  
# print for now, in reality you may want to write this out to a YAML file or database for manual fix-ups offline  
yaml\_example = yaml.dump(example, allow\_unicode=True)  
print(""\n"" + yaml\_example)  

```

```
   
   
 > Entering new SQLDatabaseChain chain...  
 List all the customer first names that start with 'a'  
 SQLQuery:  
  
 /workspace/langchain/.venv/lib/python3.9/site-packages/transformers/pipelines/base.py:1070: UserWarning: You seem to be using the pipelines sequentially on GPU. In order to maximize efficiency please use a dataset  
 warnings.warn(  
  
  
 SELECT firstname FROM customer WHERE firstname LIKE '%a%'  
 SQLResult: [('François',), ('František',), ('Helena',), ('Astrid',), ('Daan',), ('Kara',), ('Eduardo',), ('Alexandre',), ('Fernanda',), ('Mark',), ('Frank',), ('Jack',), ('Dan',), ('Kathy',), ('Heather',), ('Frank',), ('Richard',), ('Patrick',), ('Julia',), ('Edward',), ('Martha',), ('Aaron',), ('Madalena',), ('Hannah',), ('Niklas',), ('Camille',), ('Marc',), ('Wyatt',), ('Isabelle',), ('Ladislav',), ('Lucas',), ('Johannes',), ('Stanisław',), ('Joakim',), ('Emma',), ('Mark',), ('Manoj',), ('Puja',)]  
 Answer:  
  
 /workspace/langchain/.venv/lib/python3.9/site-packages/transformers/pipelines/base.py:1070: UserWarning: You seem to be using the pipelines sequentially on GPU. In order to maximize efficiency please use a dataset  
 warnings.warn(  
  
  
 [('François', 'Frantiek', 'Helena', 'Astrid', 'Daan', 'Kara', 'Eduardo', 'Alexandre', 'Fernanda', 'Mark', 'Frank', 'Jack', 'Dan', 'Kathy', 'Heather', 'Frank', 'Richard', 'Patrick', 'Julia', 'Edward', 'Martha', 'Aaron', 'Madalena', 'Hannah', 'Niklas', 'Camille', 'Marc', 'Wyatt', 'Isabelle', 'Ladislav', 'Lucas', 'Johannes', 'Stanisaw', 'Joakim', 'Emma', 'Mark', 'Manoj', 'Puja']  
 > Finished chain.  
 \*\*\* Query succeeded  
   
 answer: '[(''François'', ''Frantiek'', ''Helena'', ''Astrid'', ''Daan'', ''Kara'',  
 ''Eduardo'', ''Alexandre'', ''Fernanda'', ''Mark'', ''Frank'', ''Jack'', ''Dan'',  
 ''Kathy'', ''Heather'', ''Frank'', ''Richard'', ''Patrick'', ''Julia'', ''Edward'',  
 ''Martha'', ''Aaron'', ''Madalena'', ''Hannah'', ''Niklas'', ''Camille'', ''Marc'',  
 ''Wyatt'', ''Isabelle'', ''Ladislav'', ''Lucas'', ''Johannes'', ''Stanisaw'', ''Joakim'',  
 ''Emma'', ''Mark'', ''Manoj'', ''Puja'']'  
 input: List all the customer first names that start with 'a'  
 sql\_cmd: SELECT firstname FROM customer WHERE firstname LIKE '%a%'  
 sql\_result: '[(''François'',), (''František'',), (''Helena'',), (''Astrid'',), (''Daan'',),  
 (''Kara'',), (''Eduardo'',), (''Alexandre'',), (''Fernanda'',), (''Mark'',), (''Frank'',),  
 (''Jack'',), (''Dan'',), (''Kathy'',), (''Heather'',), (''Frank'',), (''Richard'',),  
 (''Patrick'',), (''Julia'',), (''Edward'',), (''Martha'',), (''Aaron'',), (''Madalena'',),  
 (''Hannah'',), (''Niklas'',), (''Camille'',), (''Marc'',), (''Wyatt'',), (''Isabelle'',),  
 (''Ladislav'',), (''Lucas'',), (''Johannes'',), (''Stanisław'',), (''Joakim'',),  
 (''Emma'',), (''Mark'',), (''Manoj'',), (''Puja'',)]'  
 table\_info: ""\nCREATE TABLE \""Customer\"" (\n\t\""CustomerId\"" INTEGER NOT NULL, \n\t\  
 \""FirstName\"" NVARCHAR(40) NOT NULL, \n\t\""LastName\"" NVARCHAR(20) NOT NULL, \n\t\  
 \""Company\"" NVARCHAR(80), \n\t\""Address\"" NVARCHAR(70), \n\t\""City\"" NVARCHAR(40),\  
 \ \n\t\""State\"" NVARCHAR(40), \n\t\""Country\"" NVARCHAR(40), \n\t\""PostalCode\"" NVARCHAR(10),\  
 \ \n\t\""Phone\"" NVARCHAR(24), \n\t\""Fax\"" NVARCHAR(24), \n\t\""Email\"" NVARCHAR(60)\  
 \ NOT NULL, \n\t\""SupportRepId\"" INTEGER, \n\tPRIMARY KEY (\""CustomerId\""), \n\t\  
 FOREIGN KEY(\""SupportRepId\"") REFERENCES \""Employee\"" (\""EmployeeId\"")\n)\n\n/\*\n\  
 3 rows from Customer table:\nCustomerId\tFirstName\tLastName\tCompany\tAddress\t\  
 City\tState\tCountry\tPostalCode\tPhone\tFax\tEmail\tSupportRepId\n1\tLuís\tGonçalves\t\  
 Embraer - Empresa Brasileira de Aeronáutica S.A.\tAv. Brigadeiro Faria Lima, 2170\t\  
 São José dos Campos\tSP\tBrazil\t12227-000\t+55 (12) 3923-5555\t+55 (12) 3923-5566\t\  
 luisg@embraer.com.br\t3\n2\tLeonie\tKöhler\tNone\tTheodor-Heuss-Straße 34\tStuttgart\t\  
 None\tGermany\t70174\t+49 0711 2842222\tNone\tleonekohler@surfeu.de\t5\n3\tFrançois\t\  
 Tremblay\tNone\t1498 rue Bélanger\tMontréal\tQC\tCanada\tH2G 1A7\t+1 (514) 721-4711\t\  
 None\tftremblay@gmail.com\t3\n\*/""  
   

```
Run the snippet above a few times, or log exceptions in your deployed environment, to collect lots of examples of inputs, table\_info and sql\_cmd generated by your language model. The sql\_cmd values will be incorrect and you can manually fix them up to build a collection of examples, e.g. here we are using YAML to keep a neat record of our inputs and corrected SQL output that we can build up over time.


```
YAML\_EXAMPLES = """"""  
- input: How many customers are not from Brazil?  
 table\_info: |  
 CREATE TABLE ""Customer"" (  
 ""CustomerId"" INTEGER NOT NULL,   
 ""FirstName"" NVARCHAR(40) NOT NULL,   
 ""LastName"" NVARCHAR(20) NOT NULL,   
 ""Company"" NVARCHAR(80),   
 ""Address"" NVARCHAR(70),   
 ""City"" NVARCHAR(40),   
 ""State"" NVARCHAR(40),   
 ""Country"" NVARCHAR(40),   
 ""PostalCode"" NVARCHAR(10),   
 ""Phone"" NVARCHAR(24),   
 ""Fax"" NVARCHAR(24),   
 ""Email"" NVARCHAR(60) NOT NULL,   
 ""SupportRepId"" INTEGER,   
 PRIMARY KEY (""CustomerId""),   
 FOREIGN KEY(""SupportRepId"") REFERENCES ""Employee"" (""EmployeeId"")  
 )  
 sql\_cmd: SELECT COUNT(\*) FROM ""Customer"" WHERE NOT ""Country"" = ""Brazil"";  
 sql\_result: ""[(54,)]""  
 answer: 54 customers are not from Brazil.  
- input: list all the genres that start with 'r'  
 table\_info: |  
 CREATE TABLE ""Genre"" (  
 ""GenreId"" INTEGER NOT NULL,   
 ""Name"" NVARCHAR(120),   
 PRIMARY KEY (""GenreId"")  
 )  
  
 /\*  
 3 rows from Genre table:  
 GenreId Name  
 1 Rock  
 2 Jazz  
 3 Metal  
 \*/  
 sql\_cmd: SELECT ""Name"" FROM ""Genre"" WHERE ""Name"" LIKE 'r%';  
 sql\_result: ""[('Rock',), ('Rock and Roll',), ('Reggae',), ('R&B/Soul',)]""  
 answer: The genres that start with 'r' are Rock, Rock and Roll, Reggae and R&B/Soul.   
""""""  

```
Now that you have some examples (with manually corrected output SQL), you can do few shot prompt seeding the usual way:


```
from langchain import FewShotPromptTemplate, PromptTemplate  
from langchain.chains.sql\_database.prompt import \_sqlite\_prompt, PROMPT\_SUFFIX  
from langchain.embeddings.huggingface import HuggingFaceEmbeddings  
from langchain.prompts.example\_selector.semantic\_similarity import SemanticSimilarityExampleSelector  
from langchain.vectorstores import Chroma  
  
example\_prompt = PromptTemplate(  
 input\_variables=[""table\_info"", ""input"", ""sql\_cmd"", ""sql\_result"", ""answer""],  
 template=""{table\_info}\n\nQuestion: {input}\nSQLQuery: {sql\_cmd}\nSQLResult: {sql\_result}\nAnswer: {answer}"",  
)  
  
examples\_dict = yaml.safe\_load(YAML\_EXAMPLES)  
  
local\_embeddings = HuggingFaceEmbeddings(model\_name=""sentence-transformers/all-MiniLM-L6-v2"")  
  
example\_selector = SemanticSimilarityExampleSelector.from\_examples(  
 # This is the list of examples available to select from.  
 examples\_dict,  
 # This is the embedding class used to produce embeddings which are used to measure semantic similarity.  
 local\_embeddings,  
 # This is the VectorStore class that is used to store the embeddings and do a similarity search over.  
 Chroma, # type: ignore  
 # This is the number of examples to produce and include per prompt  
 k=min(3, len(examples\_dict)),  
 )  
  
few\_shot\_prompt = FewShotPromptTemplate(  
 example\_selector=example\_selector,  
 example\_prompt=example\_prompt,  
 prefix=\_sqlite\_prompt + ""Here are some examples:"",  
 suffix=PROMPT\_SUFFIX,  
 input\_variables=[""table\_info"", ""input"", ""top\_k""],  
)  

```

```
 Using embedded DuckDB without persistence: data will be transient  

```
The model should do better now with this few shot prompt, especially for inputs similar to the examples you have seeded it with.


```
local\_chain = SQLDatabaseChain.from\_llm(local\_llm, db, prompt=few\_shot\_prompt, use\_query\_checker=True, verbose=True, return\_intermediate\_steps=True)  

```

```
result = local\_chain(""How many customers are from Brazil?"")  

```

```
   
   
 > Entering new SQLDatabaseChain chain...  
 How many customers are from Brazil?  
 SQLQuery:SELECT count(\*) FROM Customer WHERE Country = ""Brazil"";  
 SQLResult: [(5,)]  
 Answer:[5]  
 > Finished chain.  

```

```
result = local\_chain(""How many customers are not from Brazil?"")  

```

```
   
   
 > Entering new SQLDatabaseChain chain...  
 How many customers are not from Brazil?  
 SQLQuery:SELECT count(\*) FROM customer WHERE country NOT IN (SELECT country FROM customer WHERE country = 'Brazil')  
 SQLResult: [(54,)]  
 Answer:54 customers are not from Brazil.  
 > Finished chain.  

```

```
result = local\_chain(""How many customers are there in total?"")  

```

```
   
   
 > Entering new SQLDatabaseChain chain...  
 How many customers are there in total?  
 SQLQuery:SELECT count(\*) FROM Customer;  
 SQLResult: [(59,)]  
 Answer:There are 59 customers in total.  
 > Finished chain.  

```
",{'source_type': <SourceType.Official: 'Official'>}
